{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/deepCopier.ts"],
  "sourcesContent": ["import { Logger } from \"./logger\";\r\n\r\nconst CloneValue = (source: any, destinationObject: any, shallowCopyValues: boolean) => {\r\n    if (!source) {\r\n        return null;\r\n    }\r\n\r\n    if (source.getClassName && source.getClassName() === \"Mesh\") {\r\n        return null;\r\n    }\r\n\r\n    if (source.getClassName && (source.getClassName() === \"SubMesh\" || source.getClassName() === \"PhysicsBody\")) {\r\n        return source.clone(destinationObject);\r\n    } else if (source.clone) {\r\n        return source.clone();\r\n    } else if (Array.isArray(source)) {\r\n        return source.slice();\r\n    } else if (shallowCopyValues && typeof source === \"object\") {\r\n        return { ...source };\r\n    }\r\n    return null;\r\n};\r\n\r\nfunction GetAllPropertyNames(obj: any): string[] {\r\n    const props: string[] = [];\r\n\r\n    do {\r\n        Object.getOwnPropertyNames(obj).forEach(function (prop) {\r\n            if (props.indexOf(prop) === -1) {\r\n                props.push(prop);\r\n            }\r\n        });\r\n    } while ((obj = Object.getPrototypeOf(obj)));\r\n\r\n    return props;\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for deep copy.\r\n */\r\nexport class DeepCopier {\r\n    /**\r\n     * Tries to copy an object by duplicating every property\r\n     * @param source defines the source object\r\n     * @param destination defines the target object\r\n     * @param doNotCopyList defines a list of properties to avoid\r\n     * @param mustCopyList defines a list of properties to copy (even if they start with _)\r\n     * @param shallowCopyValues defines wether properties referencing objects (none cloneable) must be shallow copied (false by default)\r\n     * @remarks shallowCopyValues will not instantite the copied values which makes it only usable for \"JSON objects\"\r\n     */\r\n    public static DeepCopy(source: any, destination: any, doNotCopyList?: string[], mustCopyList?: string[], shallowCopyValues = false): void {\r\n        const properties = GetAllPropertyNames(source);\r\n        for (const prop of properties) {\r\n            if (prop[0] === \"_\" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {\r\n                continue;\r\n            }\r\n\r\n            if (prop.endsWith(\"Observable\")) {\r\n                continue;\r\n            }\r\n\r\n            if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {\r\n                continue;\r\n            }\r\n\r\n            const sourceValue = source[prop];\r\n            const typeOfSourceValue = typeof sourceValue;\r\n\r\n            if (typeOfSourceValue === \"function\") {\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                if (typeOfSourceValue === \"object\") {\r\n                    if (sourceValue instanceof Uint8Array) {\r\n                        destination[prop] = Uint8Array.from(sourceValue);\r\n                    } else if (sourceValue instanceof Array) {\r\n                        destination[prop] = [];\r\n\r\n                        if (sourceValue.length > 0) {\r\n                            if (typeof sourceValue[0] == \"object\") {\r\n                                for (let index = 0; index < sourceValue.length; index++) {\r\n                                    const clonedValue = CloneValue(sourceValue[index], destination, shallowCopyValues);\r\n\r\n                                    if (destination[prop].indexOf(clonedValue) === -1) {\r\n                                        // Test if auto inject was not done\r\n                                        destination[prop].push(clonedValue);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                destination[prop] = sourceValue.slice(0);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        destination[prop] = CloneValue(sourceValue, destination, shallowCopyValues);\r\n                    }\r\n                } else {\r\n                    destination[prop] = sourceValue;\r\n                }\r\n            } catch (e) {\r\n                // Log a warning (it could be because of a read-only property)\r\n                Logger.Warn(e.message);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;AAEA,IAAM,aAAa,CAAC,QAAa,mBAAwB,sBAA8B;AACnF,MAAI,CAAC,QAAQ;AACT,WAAO;EACX;AAEA,MAAI,OAAO,gBAAgB,OAAO,aAAY,MAAO,QAAQ;AACzD,WAAO;EACX;AAEA,MAAI,OAAO,iBAAiB,OAAO,aAAY,MAAO,aAAa,OAAO,aAAY,MAAO,gBAAgB;AACzG,WAAO,OAAO,MAAM,iBAAiB;EACzC,WAAW,OAAO,OAAO;AACrB,WAAO,OAAO,MAAK;EACvB,WAAW,MAAM,QAAQ,MAAM,GAAG;AAC9B,WAAO,OAAO,MAAK;EACvB,WAAW,qBAAqB,OAAO,WAAW,UAAU;AACxD,WAAO,EAAE,GAAG,OAAM;EACtB;AACA,SAAO;AACX;AAEA,SAAS,oBAAoB,KAAQ;AACjC,QAAM,QAAkB,CAAA;AAExB,KAAG;AACC,WAAO,oBAAoB,GAAG,EAAE,QAAQ,SAAU,MAAI;AAClD,UAAI,MAAM,QAAQ,IAAI,MAAM,IAAI;AAC5B,cAAM,KAAK,IAAI;MACnB;IACJ,CAAC;EACL,SAAU,MAAM,OAAO,eAAe,GAAG;AAEzC,SAAO;AACX;AAKM,IAAO,aAAP,MAAiB;;;;;;;;;;EAUZ,OAAO,SAAS,QAAa,aAAkB,eAA0B,cAAyB,oBAAoB,OAAK;AAC9H,UAAM,aAAa,oBAAoB,MAAM;AAC7C,eAAW,QAAQ,YAAY;AAC3B,UAAI,KAAK,CAAC,MAAM,QAAQ,CAAC,gBAAgB,aAAa,QAAQ,IAAI,MAAM,KAAK;AACzE;MACJ;AAEA,UAAI,KAAK,SAAS,YAAY,GAAG;AAC7B;MACJ;AAEA,UAAI,iBAAiB,cAAc,QAAQ,IAAI,MAAM,IAAI;AACrD;MACJ;AAEA,YAAM,cAAc,OAAO,IAAI;AAC/B,YAAM,oBAAoB,OAAO;AAEjC,UAAI,sBAAsB,YAAY;AAClC;MACJ;AAEA,UAAI;AACA,YAAI,sBAAsB,UAAU;AAChC,cAAI,uBAAuB,YAAY;AACnC,wBAAY,IAAI,IAAI,WAAW,KAAK,WAAW;UACnD,WAAW,uBAAuB,OAAO;AACrC,wBAAY,IAAI,IAAI,CAAA;AAEpB,gBAAI,YAAY,SAAS,GAAG;AACxB,kBAAI,OAAO,YAAY,CAAC,KAAK,UAAU;AACnC,yBAAS,QAAQ,GAAG,QAAQ,YAAY,QAAQ,SAAS;AACrD,wBAAM,cAAc,WAAW,YAAY,KAAK,GAAG,aAAa,iBAAiB;AAEjF,sBAAI,YAAY,IAAI,EAAE,QAAQ,WAAW,MAAM,IAAI;AAE/C,gCAAY,IAAI,EAAE,KAAK,WAAW;kBACtC;gBACJ;cACJ,OAAO;AACH,4BAAY,IAAI,IAAI,YAAY,MAAM,CAAC;cAC3C;YACJ;UACJ,OAAO;AACH,wBAAY,IAAI,IAAI,WAAW,aAAa,aAAa,iBAAiB;UAC9E;QACJ,OAAO;AACH,sBAAY,IAAI,IAAI;QACxB;MACJ,SAAS,GAAG;AAER,eAAO,KAAK,EAAE,OAAO;MACzB;IACJ;EACJ;;",
  "names": []
}
