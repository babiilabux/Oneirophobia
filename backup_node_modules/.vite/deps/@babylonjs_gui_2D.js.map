{
  "version": 3,
  "sources": ["../../../dev/gui/src/2D/valueAndUnit.ts", "../../../dev/gui/src/2D/measure.ts", "../../../dev/gui/src/2D/math2D.ts", "../../../dev/gui/src/2D/controls/control.ts", "../../../dev/gui/src/2D/controls/container.ts", "../../../dev/gui/src/2D/controls/rectangle.ts", "../../../dev/gui/src/2D/controls/textBlock.ts", "../../../dev/gui/src/2D/controls/image.ts", "../../../dev/gui/src/2D/controls/button.ts", "../../../dev/gui/src/2D/controls/stackPanel.ts", "../../../dev/gui/src/2D/controls/checkbox.ts", "../../../dev/gui/src/2D/controls/textWrapper.ts", "../../../dev/gui/src/2D/controls/inputText.ts", "../../../dev/gui/src/2D/controls/grid.ts", "../../../dev/gui/src/2D/controls/colorpicker.ts", "../../../dev/gui/src/2D/controls/ellipse.ts", "../../../dev/gui/src/2D/controls/focusableButton.ts", "../../../dev/gui/src/2D/controls/inputTextArea.ts", "../../../dev/gui/src/2D/controls/inputPassword.ts", "../../../dev/gui/src/2D/controls/line.ts", "../../../dev/gui/src/2D/multiLinePoint.ts", "../../../dev/gui/src/2D/controls/multiLine.ts", "../../../dev/gui/src/2D/controls/radioButton.ts", "../../../dev/gui/src/2D/controls/sliders/baseSlider.ts", "../../../dev/gui/src/2D/controls/sliders/slider.ts", "../../../dev/gui/src/2D/controls/selector.ts", "../../../dev/gui/src/2D/controls/scrollViewers/scrollViewerWindow.ts", "../../../dev/gui/src/2D/controls/sliders/scrollBar.ts", "../../../dev/gui/src/2D/controls/sliders/imageScrollBar.ts", "../../../dev/gui/src/2D/controls/scrollViewers/scrollViewer.ts", "../../../dev/gui/src/2D/controls/toggleButton.ts", "../../../dev/gui/src/2D/controls/virtualKeyboard.ts", "../../../dev/gui/src/2D/controls/displayGrid.ts", "../../../dev/gui/src/2D/controls/sliders/imageBasedSlider.ts", "../../../dev/gui/src/2D/controls/statics.ts", "../../../dev/gui/src/2D/controls/gradient/BaseGradient.ts", "../../../dev/gui/src/2D/controls/gradient/LinearGradient.ts", "../../../dev/gui/src/2D/controls/gradient/RadialGradient.ts", "../../../dev/gui/src/2D/style.ts", "../../../dev/gui/src/2D/advancedDynamicTexture.ts", "../../../dev/gui/src/2D/adtInstrumentation.ts", "../../../dev/gui/src/2D/FrameGraph/guiTask.ts", "../../../dev/gui/src/2D/FrameGraph/renderGraphGUIBlock.ts", "../../../dev/gui/src/2D/xmlLoader.ts"],
  "sourcesContent": ["import { Observable } from \"core/Misc/observable\";\r\nimport type { AdvancedDynamicTexture } from \"./advancedDynamicTexture\";\r\n\r\n/**\r\n * Class used to specific a value and its associated unit\r\n */\r\nexport class ValueAndUnit {\r\n    private _value = 1;\r\n    private _unit = ValueAndUnit.UNITMODE_PIXEL;\r\n    private _originalUnit: number;\r\n\r\n    /**\r\n     * Gets or sets a value indicating that this value will not scale accordingly with adaptive scaling property\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public ignoreAdaptiveScaling = false;\r\n\r\n    /**\r\n     * Observable event triggered each time the value or unit changes\r\n     */\r\n    public onChangedObservable = new Observable<void>();\r\n\r\n    /**\r\n     * Creates a new ValueAndUnit\r\n     * @param value defines the value to store\r\n     * @param unit defines the unit to store - defaults to ValueAndUnit.UNITMODE_PIXEL\r\n     * @param negativeValueAllowed defines a boolean indicating if the value can be negative\r\n     */\r\n    public constructor(\r\n        value: number,\r\n        /** defines the unit to store */\r\n        unit = ValueAndUnit.UNITMODE_PIXEL,\r\n        /** defines a boolean indicating if the value can be negative */\r\n        public negativeValueAllowed = true\r\n    ) {\r\n        this._value = value;\r\n        this._unit = unit;\r\n        this._originalUnit = unit;\r\n    }\r\n\r\n    /** Gets a boolean indicating if the value is a percentage */\r\n    public get isPercentage(): boolean {\r\n        return this._unit === ValueAndUnit.UNITMODE_PERCENTAGE;\r\n    }\r\n\r\n    /** Gets a boolean indicating if the value is store as pixel */\r\n    public get isPixel(): boolean {\r\n        return this._unit === ValueAndUnit.UNITMODE_PIXEL;\r\n    }\r\n\r\n    /**\r\n     * Gets value (without units)\r\n     * @deprecated use value property instead\r\n     */\r\n    public get internalValue(): number {\r\n        return this._value;\r\n    }\r\n\r\n    /** Gets value (without units) */\r\n    public get value(): number {\r\n        return this._value;\r\n    }\r\n\r\n    /** Sets value (without units) */\r\n    public set value(value: number) {\r\n        if (value !== this._value) {\r\n            this._value = value;\r\n            this.onChangedObservable.notifyObservers();\r\n        }\r\n    }\r\n\r\n    /** Gets units (without value) */\r\n    public get unit(): number {\r\n        return this._unit;\r\n    }\r\n\r\n    /** Sets units (without value) */\r\n    public set unit(value: number) {\r\n        if (value !== this._unit) {\r\n            this._unit = value;\r\n            this.onChangedObservable.notifyObservers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets value as pixel\r\n     * @param host defines the root host\r\n     * @param refValue defines the reference value for percentages\r\n     * @returns the value as pixel\r\n     */\r\n    public getValueInPixel(host: AdvancedDynamicTexture, refValue: number): number {\r\n        if (this.isPixel) {\r\n            return this.getValue(host);\r\n        }\r\n\r\n        return this.getValue(host) * refValue;\r\n    }\r\n\r\n    /**\r\n     * Update the current value and unit.\r\n     * @param value defines the value to store\r\n     * @param unit defines the unit to store\r\n     * @returns the current ValueAndUnit\r\n     */\r\n    public updateInPlace(value: number, unit = ValueAndUnit.UNITMODE_PIXEL): ValueAndUnit {\r\n        if (this.value !== value || this.unit !== unit) {\r\n            // set member variables to notify only once\r\n            this._value = value;\r\n            this._unit = unit;\r\n            this.onChangedObservable.notifyObservers();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the value accordingly to its unit\r\n     * @param host  defines the root host\r\n     * @returns the value\r\n     */\r\n    public getValue(host: AdvancedDynamicTexture): number {\r\n        if (host && !this.ignoreAdaptiveScaling && this.unit !== ValueAndUnit.UNITMODE_PERCENTAGE) {\r\n            let width: number = 0;\r\n            let height: number = 0;\r\n\r\n            if (host.idealWidth) {\r\n                width = Math.ceil((this._value * host.getSize().width) / host.idealWidth);\r\n            }\r\n\r\n            if (host.idealHeight) {\r\n                height = Math.ceil((this._value * host.getSize().height) / host.idealHeight);\r\n            }\r\n\r\n            if (host.useSmallestIdeal && host.idealWidth && host.idealHeight) {\r\n                return window.innerWidth < window.innerHeight ? width : height;\r\n            }\r\n\r\n            if (host.idealWidth) {\r\n                // horizontal\r\n                return width;\r\n            }\r\n\r\n            if (host.idealHeight) {\r\n                // vertical\r\n                return height;\r\n            }\r\n        }\r\n        return this._value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string representation of the value\r\n     * @param host defines the root host\r\n     * @param decimals defines an optional number of decimals to display\r\n     * @returns a string\r\n     */\r\n    public toString(host: AdvancedDynamicTexture, decimals?: number): string {\r\n        switch (this._unit) {\r\n            case ValueAndUnit.UNITMODE_PERCENTAGE: {\r\n                const percentage = this.getValue(host) * 100;\r\n                return (decimals ? percentage.toFixed(decimals) : percentage) + \"%\";\r\n            }\r\n            case ValueAndUnit.UNITMODE_PIXEL: {\r\n                const pixels = this.getValue(host);\r\n                return (decimals ? pixels.toFixed(decimals) : pixels) + \"px\";\r\n            }\r\n        }\r\n\r\n        return this._unit.toString();\r\n    }\r\n\r\n    /**\r\n     * Store a value parsed from a string\r\n     * @param source defines the source string\r\n     * @returns true if the value was successfully parsed and updated\r\n     */\r\n    public fromString(source: string | number): boolean {\r\n        const match = ValueAndUnit._Regex.exec(source.toString());\r\n\r\n        if (!match || match.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        let sourceValue = parseFloat(match[1]);\r\n        let sourceUnit = this._originalUnit;\r\n\r\n        if (!this.negativeValueAllowed) {\r\n            if (sourceValue < 0) {\r\n                sourceValue = 0;\r\n            }\r\n        }\r\n\r\n        if (match.length === 4) {\r\n            switch (match[3]) {\r\n                case \"px\":\r\n                    sourceUnit = ValueAndUnit.UNITMODE_PIXEL;\r\n                    break;\r\n                case \"%\":\r\n                    sourceUnit = ValueAndUnit.UNITMODE_PERCENTAGE;\r\n                    sourceValue /= 100.0;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (sourceValue === this._value && sourceUnit === this._unit) {\r\n            return false;\r\n        }\r\n\r\n        this._value = sourceValue;\r\n        this._unit = sourceUnit;\r\n        this.onChangedObservable.notifyObservers();\r\n\r\n        return true;\r\n    }\r\n\r\n    // Static\r\n    private static _Regex = /(^-?\\d*(\\.\\d+)?)(%|px)?/;\r\n    private static _UNITMODE_PERCENTAGE = 0;\r\n    private static _UNITMODE_PIXEL = 1;\r\n\r\n    /** UNITMODE_PERCENTAGE */\r\n    public static get UNITMODE_PERCENTAGE(): number {\r\n        return ValueAndUnit._UNITMODE_PERCENTAGE;\r\n    }\r\n\r\n    /** UNITMODE_PIXEL */\r\n    public static get UNITMODE_PIXEL(): number {\r\n        return ValueAndUnit._UNITMODE_PIXEL;\r\n    }\r\n}\r\n", "import type { Matrix2D } from \"./math2D\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nconst tmpRect = [new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0)];\r\n\r\nconst tmpRect2 = [new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0)];\r\n\r\nconst tmpV1 = new Vector2(0, 0);\r\nconst tmpV2 = new Vector2(0, 0);\r\n\r\n/**\r\n * Class used to store 2D control sizes\r\n */\r\nexport class Measure {\r\n    /**\r\n     * Creates a new measure\r\n     * @param left defines left coordinate\r\n     * @param top defines top coordinate\r\n     * @param width defines width dimension\r\n     * @param height defines height dimension\r\n     */\r\n    public constructor(\r\n        /** defines left coordinate */\r\n        public left: number,\r\n        /** defines top coordinate  */\r\n        public top: number,\r\n        /** defines width dimension  */\r\n        public width: number,\r\n        /** defines height dimension */\r\n        public height: number\r\n    ) {}\r\n\r\n    /**\r\n     * Copy from another measure\r\n     * @param other defines the other measure to copy from\r\n     */\r\n    public copyFrom(other: Measure): void {\r\n        this.left = other.left;\r\n        this.top = other.top;\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n    }\r\n\r\n    /**\r\n     * Copy from a group of 4 floats\r\n     * @param left defines left coordinate\r\n     * @param top defines top coordinate\r\n     * @param width defines width dimension\r\n     * @param height defines height dimension\r\n     */\r\n    public copyFromFloats(left: number, top: number, width: number, height: number): void {\r\n        this.left = left;\r\n        this.top = top;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    /**\r\n     * Computes the axis aligned bounding box measure for two given measures\r\n     * @param a Input measure\r\n     * @param b Input measure\r\n     * @param result the resulting bounding measure\r\n     */\r\n    public static CombineToRef(a: Measure, b: Measure, result: Measure) {\r\n        const left = Math.min(a.left, b.left);\r\n        const top = Math.min(a.top, b.top);\r\n        const right = Math.max(a.left + a.width, b.left + b.width);\r\n        const bottom = Math.max(a.top + a.height, b.top + b.height);\r\n        result.left = left;\r\n        result.top = top;\r\n        result.width = right - left;\r\n        result.height = bottom - top;\r\n    }\r\n\r\n    /**\r\n     * Computes the axis aligned bounding box of the measure after it is modified by a given transform\r\n     * @param transform the matrix to transform the measure before computing the AABB\r\n     * @param addX number to add to left\r\n     * @param addY number to add to top\r\n     * @param addWidth number to add to width\r\n     * @param addHeight number to add to height\r\n     * @param result the resulting AABB\r\n     */\r\n    public addAndTransformToRef(transform: Matrix2D, addX: number, addY: number, addWidth: number, addHeight: number, result: Measure) {\r\n        const left = this.left + addX;\r\n        const top = this.top + addY;\r\n        const width = this.width + addWidth;\r\n        const height = this.height + addHeight;\r\n\r\n        tmpRect[0].copyFromFloats(left, top);\r\n        tmpRect[1].copyFromFloats(left + width, top);\r\n        tmpRect[2].copyFromFloats(left + width, top + height);\r\n        tmpRect[3].copyFromFloats(left, top + height);\r\n\r\n        tmpV1.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE);\r\n        tmpV2.copyFromFloats(0, 0);\r\n        for (let i = 0; i < 4; i++) {\r\n            transform.transformCoordinates(tmpRect[i].x, tmpRect[i].y, tmpRect2[i]);\r\n            tmpV1.x = Math.floor(Math.min(tmpV1.x, tmpRect2[i].x));\r\n            tmpV1.y = Math.floor(Math.min(tmpV1.y, tmpRect2[i].y));\r\n            tmpV2.x = Math.ceil(Math.max(tmpV2.x, tmpRect2[i].x));\r\n            tmpV2.y = Math.ceil(Math.max(tmpV2.y, tmpRect2[i].y));\r\n        }\r\n        result.left = tmpV1.x;\r\n        result.top = tmpV1.y;\r\n        result.width = tmpV2.x - tmpV1.x;\r\n        result.height = tmpV2.y - tmpV1.y;\r\n    }\r\n\r\n    /**\r\n     * Computes the axis aligned bounding box of the measure after it is modified by a given transform\r\n     * @param transform the matrix to transform the measure before computing the AABB\r\n     * @param result the resulting AABB\r\n     */\r\n    public transformToRef(transform: Matrix2D, result: Measure) {\r\n        this.addAndTransformToRef(transform, 0, 0, 0, 0, result);\r\n    }\r\n    /**\r\n     * Check equality between this measure and another one\r\n     * @param other defines the other measures\r\n     * @returns true if both measures are equals\r\n     */\r\n    public isEqualsTo(other: Measure): boolean {\r\n        if (this.left !== other.left) {\r\n            return false;\r\n        }\r\n\r\n        if (this.top !== other.top) {\r\n            return false;\r\n        }\r\n\r\n        if (this.width !== other.width) {\r\n            return false;\r\n        }\r\n\r\n        if (this.height !== other.height) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates an empty measure\r\n     * @returns a new measure\r\n     */\r\n    public static Empty(): Measure {\r\n        return new Measure(0, 0, 0, 0);\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\n\r\n/**\r\n * Class used to transport Vector2 information for pointer events\r\n */\r\nexport class Vector2WithInfo extends Vector2 {\r\n    /**\r\n     * Creates a new Vector2WithInfo\r\n     * @param source defines the vector2 data to transport\r\n     * @param buttonIndex defines the current mouse button index\r\n     */\r\n    public constructor(\r\n        source: Vector2,\r\n        /** defines the current mouse button index */\r\n        public buttonIndex: number = 0\r\n    ) {\r\n        super(source.x, source.y);\r\n    }\r\n}\r\n\r\n/** Class used to provide 2D matrix features */\r\nexport class Matrix2D {\r\n    /** Gets the internal array of 6 floats used to store matrix data */\r\n    public m = new Float32Array(6);\r\n\r\n    /**\r\n     * Creates a new matrix\r\n     * @param m00 defines value for (0, 0)\r\n     * @param m01 defines value for (0, 1)\r\n     * @param m10 defines value for (1, 0)\r\n     * @param m11 defines value for (1, 1)\r\n     * @param m20 defines value for (2, 0)\r\n     * @param m21 defines value for (2, 1)\r\n     */\r\n    constructor(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number) {\r\n        this.fromValues(m00, m01, m10, m11, m20, m21);\r\n    }\r\n\r\n    /**\r\n     * Fills the matrix from direct values\r\n     * @param m00 defines value for (0, 0)\r\n     * @param m01 defines value for (0, 1)\r\n     * @param m10 defines value for (1, 0)\r\n     * @param m11 defines value for (1, 1)\r\n     * @param m20 defines value for (2, 0)\r\n     * @param m21 defines value for (2, 1)\r\n     * @returns the current modified matrix\r\n     */\r\n    public fromValues(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number): Matrix2D {\r\n        this.m[0] = m00;\r\n        this.m[1] = m01;\r\n        this.m[2] = m10;\r\n        this.m[3] = m11;\r\n        this.m[4] = m20;\r\n        this.m[5] = m21;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets matrix determinant\r\n     * @returns the determinant\r\n     */\r\n    public determinant(): number {\r\n        return this.m[0] * this.m[3] - this.m[1] * this.m[2];\r\n    }\r\n\r\n    /**\r\n     * Inverses the matrix and stores it in a target matrix\r\n     * @param result defines the target matrix\r\n     * @returns the current matrix\r\n     */\r\n    public invertToRef(result: Matrix2D): Matrix2D {\r\n        const l0 = this.m[0];\r\n        const l1 = this.m[1];\r\n        const l2 = this.m[2];\r\n        const l3 = this.m[3];\r\n        const l4 = this.m[4];\r\n        const l5 = this.m[5];\r\n\r\n        const det = this.determinant();\r\n        if (det < Epsilon * Epsilon) {\r\n            result.m[0] = 0;\r\n            result.m[1] = 0;\r\n            result.m[2] = 0;\r\n            result.m[3] = 0;\r\n            result.m[4] = 0;\r\n            result.m[5] = 0;\r\n            return this;\r\n        }\r\n\r\n        const detDiv = 1 / det;\r\n\r\n        const det4 = l2 * l5 - l3 * l4;\r\n        const det5 = l1 * l4 - l0 * l5;\r\n\r\n        result.m[0] = l3 * detDiv;\r\n        result.m[1] = -l1 * detDiv;\r\n        result.m[2] = -l2 * detDiv;\r\n        result.m[3] = l0 * detDiv;\r\n        result.m[4] = det4 * detDiv;\r\n        result.m[5] = det5 * detDiv;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current matrix with another one\r\n     * @param other defines the second operand\r\n     * @param result defines the target matrix\r\n     * @returns the current matrix\r\n     */\r\n    public multiplyToRef(other: Matrix2D, result: Matrix2D): Matrix2D {\r\n        const l0 = this.m[0];\r\n        const l1 = this.m[1];\r\n        const l2 = this.m[2];\r\n        const l3 = this.m[3];\r\n        const l4 = this.m[4];\r\n        const l5 = this.m[5];\r\n\r\n        const r0 = other.m[0];\r\n        const r1 = other.m[1];\r\n        const r2 = other.m[2];\r\n        const r3 = other.m[3];\r\n        const r4 = other.m[4];\r\n        const r5 = other.m[5];\r\n\r\n        result.m[0] = l0 * r0 + l1 * r2;\r\n        result.m[1] = l0 * r1 + l1 * r3;\r\n        result.m[2] = l2 * r0 + l3 * r2;\r\n        result.m[3] = l2 * r1 + l3 * r3;\r\n        result.m[4] = l4 * r0 + l5 * r2 + r4;\r\n        result.m[5] = l4 * r1 + l5 * r3 + r5;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Applies the current matrix to a set of 2 floats and stores the result in a vector2\r\n     * @param x defines the x coordinate to transform\r\n     * @param y defines the x coordinate to transform\r\n     * @param result defines the target vector2\r\n     * @returns the current matrix\r\n     */\r\n    public transformCoordinates(x: number, y: number, result: Vector2): Matrix2D {\r\n        result.x = x * this.m[0] + y * this.m[2] + this.m[4];\r\n        result.y = x * this.m[1] + y * this.m[3] + this.m[5];\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates an identity matrix\r\n     * @returns a new matrix\r\n     */\r\n    public static Identity(): Matrix2D {\r\n        return new Matrix2D(1, 0, 0, 1, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Creates an identity matrix and stores it in a target matrix\r\n     * @param result defines the target matrix\r\n     */\r\n    public static IdentityToRef(result: Matrix2D): void {\r\n        result.m[0] = 1;\r\n        result.m[1] = 0;\r\n        result.m[2] = 0;\r\n        result.m[3] = 1;\r\n        result.m[4] = 0;\r\n        result.m[5] = 0;\r\n    }\r\n\r\n    /**\r\n     * Creates a translation matrix and stores it in a target matrix\r\n     * @param x defines the x coordinate of the translation\r\n     * @param y defines the y coordinate of the translation\r\n     * @param result defines the target matrix\r\n     */\r\n    public static TranslationToRef(x: number, y: number, result: Matrix2D): void {\r\n        result.fromValues(1, 0, 0, 1, x, y);\r\n    }\r\n\r\n    /**\r\n     * Creates a scaling matrix and stores it in a target matrix\r\n     * @param x defines the x coordinate of the scaling\r\n     * @param y defines the y coordinate of the scaling\r\n     * @param result defines the target matrix\r\n     */\r\n    public static ScalingToRef(x: number, y: number, result: Matrix2D): void {\r\n        result.fromValues(x, 0, 0, y, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation matrix and stores it in a target matrix\r\n     * @param angle defines the rotation angle\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationToRef(angle: number, result: Matrix2D): void {\r\n        const s = Math.sin(angle);\r\n        const c = Math.cos(angle);\r\n\r\n        result.fromValues(c, s, -s, c, 0, 0);\r\n    }\r\n\r\n    private static _TempPreTranslationMatrix = Matrix2D.Identity();\r\n    private static _TempPostTranslationMatrix = Matrix2D.Identity();\r\n    private static _TempRotationMatrix = Matrix2D.Identity();\r\n    private static _TempScalingMatrix = Matrix2D.Identity();\r\n    private static _TempCompose0 = Matrix2D.Identity();\r\n    private static _TempCompose1 = Matrix2D.Identity();\r\n    private static _TempCompose2 = Matrix2D.Identity();\r\n\r\n    /**\r\n     * Composes a matrix from translation, rotation, scaling and parent matrix and stores it in a target matrix\r\n     * @param tx defines the x coordinate of the translation\r\n     * @param ty defines the y coordinate of the translation\r\n     * @param angle defines the rotation angle\r\n     * @param scaleX defines the x coordinate of the scaling\r\n     * @param scaleY defines the y coordinate of the scaling\r\n     * @param parentMatrix defines the parent matrix to multiply by (can be null)\r\n     * @param result defines the target matrix\r\n     */\r\n    public static ComposeToRef(tx: number, ty: number, angle: number, scaleX: number, scaleY: number, parentMatrix: Nullable<Matrix2D>, result: Matrix2D): void {\r\n        Matrix2D.TranslationToRef(tx, ty, Matrix2D._TempPreTranslationMatrix);\r\n\r\n        Matrix2D.ScalingToRef(scaleX, scaleY, Matrix2D._TempScalingMatrix);\r\n\r\n        Matrix2D.RotationToRef(angle, Matrix2D._TempRotationMatrix);\r\n\r\n        Matrix2D.TranslationToRef(-tx, -ty, Matrix2D._TempPostTranslationMatrix);\r\n\r\n        Matrix2D._TempPreTranslationMatrix.multiplyToRef(Matrix2D._TempScalingMatrix, Matrix2D._TempCompose0);\r\n        Matrix2D._TempCompose0.multiplyToRef(Matrix2D._TempRotationMatrix, Matrix2D._TempCompose1);\r\n        if (parentMatrix) {\r\n            Matrix2D._TempCompose1.multiplyToRef(Matrix2D._TempPostTranslationMatrix, Matrix2D._TempCompose2);\r\n            Matrix2D._TempCompose2.multiplyToRef(parentMatrix, result);\r\n        } else {\r\n            Matrix2D._TempCompose1.multiplyToRef(Matrix2D._TempPostTranslationMatrix, result);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Useful math functions\r\n */\r\nexport class MathTools {\r\n    /**\r\n     * Default rounding precision for GUI elements. It should be\r\n     * set to a power of ten, where the exponent means the number\r\n     * of decimal digits to round to, i.e, 100 means 2 decimal digits,\r\n     * 1000 means 3 decimal digits, etc. Default is 100 (2 decimal digits).\r\n     */\r\n    public static DefaultRoundingPrecision = 100;\r\n\r\n    /**\r\n     * Rounds a number to the nearest multiple of a given precision\r\n     * @param value the value to be rounded\r\n     * @param precision the multiple to which the value will be rounded. Default is 100 (2 decimal digits)\r\n     * @returns\r\n     */\r\n    public static Round(value: number, precision: number = MathTools.DefaultRoundingPrecision): number {\r\n        return Math.round(value * precision) / precision;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Vector2, Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { Container } from \"./container\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport { Measure } from \"../measure\";\r\nimport type { Style } from \"../style\";\r\nimport { Matrix2D, Vector2WithInfo } from \"../math2D\";\r\nimport { GetClass, RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { ICanvasGradient, ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\nimport type { IAccessibilityTag } from \"core/IAccessibilityTag\";\r\nimport type { IKeyboardEvent, IPointerEvent } from \"core/Events/deviceInputEvents\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { BaseGradient } from \"./gradient/BaseGradient\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { IFocusableControl } from \"./focusableControl\";\r\n\r\n/**\r\n * Root class used for all 2D controls\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#controls\r\n */\r\nexport class Control implements IAnimatable, IFocusableControl {\r\n    /**\r\n     * Gets or sets a boolean indicating if alpha must be an inherited value (false by default)\r\n     */\r\n    public static AllowAlphaInheritance = false;\r\n\r\n    private _alpha = 1;\r\n    private _alphaSet = false;\r\n    private _zIndex = 0;\r\n    /** @internal */\r\n    public _host: AdvancedDynamicTexture;\r\n    /** Gets or sets the control parent */\r\n    public parent: Nullable<Container>;\r\n    /** @internal */\r\n    public _currentMeasure = Measure.Empty();\r\n    /** @internal */\r\n    public _tempPaddingMeasure = Measure.Empty();\r\n    private _fontFamily = \"\";\r\n    private _fontStyle = \"\";\r\n    private _fontWeight = \"\";\r\n    private _fontSize = new ValueAndUnit(18, ValueAndUnit.UNITMODE_PIXEL, false);\r\n    private _font: string;\r\n    /** @internal */\r\n    public _width = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);\r\n    /** @internal */\r\n    public _height = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);\r\n    /** @internal */\r\n    protected _fontOffset: { ascent: number; height: number; descent: number };\r\n    private _color = \"\";\r\n    private _style: Nullable<Style> = null;\r\n    private _styleObserver: Nullable<Observer<Style>>;\r\n    /** @internal */\r\n    protected _horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    /** @internal */\r\n    protected _verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n    /** @internal */\r\n    protected _isDirty = true;\r\n    /** @internal */\r\n    protected _wasDirty = false;\r\n    /** @internal */\r\n    public _tempParentMeasure = Measure.Empty();\r\n    /** @internal */\r\n    public _prevCurrentMeasureTransformedIntoGlobalSpace = Measure.Empty();\r\n    /** @internal */\r\n    public _cachedParentMeasure = Measure.Empty();\r\n    private _descendantsOnlyPadding = false;\r\n    private _paddingLeft = new ValueAndUnit(0);\r\n    private _paddingRight = new ValueAndUnit(0);\r\n    private _paddingTop = new ValueAndUnit(0);\r\n    private _paddingBottom = new ValueAndUnit(0);\r\n    /** @internal */\r\n    public _left = new ValueAndUnit(0);\r\n    /** @internal */\r\n    public _top = new ValueAndUnit(0);\r\n    private _scaleX = 1.0;\r\n    private _scaleY = 1.0;\r\n    private _rotation = 0;\r\n    private _transformCenterX = 0.5;\r\n    private _transformCenterY = 0.5;\r\n    /** @internal */\r\n    public _transformMatrix = Matrix2D.Identity();\r\n    /** @internal */\r\n    protected _invertTransformMatrix = Matrix2D.Identity();\r\n    /** @internal */\r\n    protected _transformedPosition = Vector2.Zero();\r\n    private _isMatrixDirty = true;\r\n    private _cachedOffsetX: number;\r\n    private _cachedOffsetY: number;\r\n    private _isVisible = true;\r\n    private _isHighlighted = false;\r\n    private _highlightColor = \"#4affff\";\r\n    protected _highlightLineWidth = 2;\r\n    /** @internal */\r\n    public _linkedMesh: Nullable<TransformNode>;\r\n    private _fontSet = false;\r\n    private _dummyVector2 = Vector2.Zero();\r\n    private _downCount = 0;\r\n    private _enterCount = -1;\r\n    private _doNotRender = false;\r\n    private _downPointerIds: { [id: number]: boolean } = {};\r\n    private _evaluatedMeasure = new Measure(0, 0, 0, 0);\r\n    private _evaluatedParentMeasure = new Measure(0, 0, 0, 0);\r\n    protected _isEnabled = true;\r\n    protected _disabledColor = \"#9a9a9a\";\r\n    protected _disabledColorItem = \"#6a6a6a\";\r\n    protected _isReadOnly = false;\r\n    private _gradient: Nullable<BaseGradient> = null;\r\n    /** @internal */\r\n    protected _rebuildLayout = false;\r\n\r\n    /** @internal */\r\n    protected _urlRewriter?: (url: string) => string;\r\n\r\n    /**\r\n     * Observable that fires when the control's enabled state changes\r\n     */\r\n    public onEnabledStateChangedObservable = new Observable<boolean>();\r\n\r\n    /** @internal */\r\n    public _customData: any = {};\r\n\r\n    /** @internal */\r\n    public _isClipped = false;\r\n\r\n    /** @internal */\r\n    public _automaticSize = false;\r\n\r\n    /** @internal */\r\n    public _tag: any;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node. Please note that this number will be updated when the control is added to a container\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the control is readonly (default: false).\r\n     * A readonly control will still raise pointer events but will not react to them\r\n     */\r\n    public get isReadOnly() {\r\n        return this._isReadOnly;\r\n    }\r\n\r\n    public set isReadOnly(value: boolean) {\r\n        this._isReadOnly = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the transformed measure, that is the bounding box of the control after applying all transformations\r\n     */\r\n    public get transformedMeasure(): Measure {\r\n        return this._evaluatedMeasure;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the node\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** Gets or sets a boolean indicating if the control can be hit with pointer events */\r\n    @serialize()\r\n    public isHitTestVisible = true;\r\n    /** Gets or sets a boolean indicating if the control can block pointer events. False by default except on the following controls:\r\n     * * Button controls (Button, RadioButton, ToggleButton)\r\n     * * Checkbox\r\n     * * ColorPicker\r\n     * * InputText\r\n     * * Slider\r\n     */\r\n    @serialize()\r\n    public isPointerBlocker = false;\r\n    /** Gets or sets a boolean indicating if the control can be focusable */\r\n    @serialize()\r\n    public isFocusInvisible = false;\r\n\r\n    protected _clipChildren = true;\r\n    /**\r\n     * Sets/Gets a boolean indicating if the children are clipped to the current control bounds.\r\n     * Please note that not clipping children may generate issues with adt.useInvalidateRectOptimization so it is recommended to turn this optimization off if you want to use unclipped children\r\n     */\r\n    public set clipChildren(value: boolean) {\r\n        this._clipChildren = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get clipChildren() {\r\n        return this._clipChildren;\r\n    }\r\n\r\n    protected _clipContent = true;\r\n    /**\r\n     * Sets/Gets a boolean indicating that control content must be clipped\r\n     * Please note that not clipping content may generate issues with adt.useInvalidateRectOptimization so it is recommended to turn this optimization off if you want to use unclipped children\r\n     */\r\n    public set clipContent(value: boolean) {\r\n        this._clipContent = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get clipContent() {\r\n        return this._clipContent;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the current control should cache its rendering (useful when the control does not change often)\r\n     */\r\n    @serialize()\r\n    public useBitmapCache = false;\r\n\r\n    private _cacheData: Nullable<ImageData>;\r\n\r\n    private _shadowOffsetX = 0;\r\n    /** Gets or sets a value indicating the offset to apply on X axis to render the shadow */\r\n    @serialize()\r\n    public get shadowOffsetX() {\r\n        return this._shadowOffsetX;\r\n    }\r\n\r\n    public set shadowOffsetX(value: number) {\r\n        if (this._shadowOffsetX === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowOffsetX = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _shadowOffsetY = 0;\r\n    /** Gets or sets a value indicating the offset to apply on Y axis to render the shadow */\r\n    @serialize()\r\n    public get shadowOffsetY() {\r\n        return this._shadowOffsetY;\r\n    }\r\n\r\n    public set shadowOffsetY(value: number) {\r\n        if (this._shadowOffsetY === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowOffsetY = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _shadowBlur = 0;\r\n    private _previousShadowBlur = 0;\r\n    /** Gets or sets a value indicating the amount of blur to use to render the shadow */\r\n    @serialize()\r\n    public get shadowBlur() {\r\n        return this._shadowBlur;\r\n    }\r\n\r\n    public set shadowBlur(value: number) {\r\n        if (this._shadowBlur === value) {\r\n            return;\r\n        }\r\n\r\n        this._previousShadowBlur = this._shadowBlur;\r\n\r\n        this._shadowBlur = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _shadowColor = \"black\";\r\n    /** Gets or sets a value indicating the color of the shadow (black by default ie. \"#000\") */\r\n    @serialize()\r\n    public get shadowColor() {\r\n        return this._shadowColor;\r\n    }\r\n\r\n    public set shadowColor(value: string) {\r\n        if (this._shadowColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the cursor to use when the control is hovered */\r\n    @serialize()\r\n    public hoverCursor = \"\";\r\n\r\n    /** @internal */\r\n    protected _linkOffsetX = new ValueAndUnit(0);\r\n    /** @internal */\r\n    protected _linkOffsetY = new ValueAndUnit(0);\r\n\r\n    // Properties\r\n\r\n    /** Gets the control type name */\r\n    public get typeName(): string {\r\n        return this._getTypeName();\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the control.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return this._getTypeName();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the accessibility tag to describe the control for accessibility purpose.\r\n     * By default, GUI controls already indicate accessibility info, but one can override the info using this tag.\r\n     */\r\n    public set accessibilityTag(value: Nullable<IAccessibilityTag>) {\r\n        this._accessibilityTag = value;\r\n        this.onAccessibilityTagChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    public get accessibilityTag() {\r\n        return this._accessibilityTag;\r\n    }\r\n\r\n    protected _accessibilityTag: Nullable<IAccessibilityTag> = null;\r\n\r\n    /**\r\n     * Observable that fires whenever the accessibility event of the control has changed\r\n     */\r\n    public onAccessibilityTagChangedObservable = new Observable<Nullable<IAccessibilityTag>>();\r\n\r\n    /**\r\n     * An event triggered when pointer wheel is scrolled\r\n     */\r\n    public onWheelObservable = new Observable<Vector2>();\r\n    /**\r\n     * An event triggered when the pointer moves over the control.\r\n     */\r\n    public onPointerMoveObservable = new Observable<Vector2>();\r\n\r\n    /**\r\n     * An event triggered when the pointer moves out of the control.\r\n     */\r\n    public onPointerOutObservable = new Observable<Control>();\r\n\r\n    /**\r\n     * An event triggered when the pointer taps the control\r\n     */\r\n    public onPointerDownObservable = new Observable<Vector2WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when pointer up\r\n     */\r\n    public onPointerUpObservable = new Observable<Vector2WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when a control is clicked on\r\n     */\r\n    public onPointerClickObservable = new Observable<Vector2WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when a control receives an ENTER key down event\r\n     */\r\n    public onEnterPressedObservable = new Observable<Control>();\r\n\r\n    /**\r\n     * An event triggered when pointer enters the control\r\n     */\r\n    public onPointerEnterObservable = new Observable<Control>();\r\n\r\n    /**\r\n     * An event triggered when the control is marked as dirty\r\n     */\r\n    public onDirtyObservable = new Observable<Control>();\r\n\r\n    /**\r\n     * An event triggered before drawing the control\r\n     */\r\n    public onBeforeDrawObservable = new Observable<Control>();\r\n\r\n    /**\r\n     * An event triggered after the control was drawn\r\n     */\r\n    public onAfterDrawObservable = new Observable<Control>();\r\n\r\n    /**\r\n     * An event triggered when the control has been disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Control>();\r\n\r\n    /**\r\n     * An event triggered when the control isVisible is changed\r\n     */\r\n    public onIsVisibleChangedObservable = new Observable<boolean>();\r\n\r\n    /**\r\n     * Get the hosting AdvancedDynamicTexture\r\n     */\r\n    public get host(): AdvancedDynamicTexture {\r\n        return this._host;\r\n    }\r\n\r\n    /** Gets or set information about font offsets (used to render and align text) */\r\n    @serialize()\r\n    public get fontOffset(): { ascent: number; height: number; descent: number } {\r\n        return this._fontOffset;\r\n    }\r\n\r\n    public set fontOffset(offset: { ascent: number; height: number; descent: number }) {\r\n        this._fontOffset = offset;\r\n    }\r\n\r\n    /** Gets or sets alpha value for the control (1 means opaque and 0 means entirely transparent) */\r\n    @serialize()\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n        this._alphaSet = true;\r\n        this._alpha = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a number indicating size of stroke we want to highlight the control with (mostly for debugging purpose)\r\n     */\r\n    public get highlightLineWidth(): number {\r\n        return this._highlightLineWidth;\r\n    }\r\n\r\n    public set highlightLineWidth(value: number) {\r\n        if (this._highlightLineWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._highlightLineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that we want to highlight the control (mostly for debugging purpose)\r\n     */\r\n    public get isHighlighted(): boolean {\r\n        return this._isHighlighted;\r\n    }\r\n\r\n    public set isHighlighted(value: boolean) {\r\n        if (this._isHighlighted === value) {\r\n            return;\r\n        }\r\n\r\n        this._isHighlighted = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Indicates if the control should be serialized. Defaults to true.\r\n     */\r\n    @serialize()\r\n    public isSerializable: boolean = true;\r\n\r\n    /**\r\n     * Gets or sets a string defining the color to use for highlighting this control\r\n     */\r\n    public get highlightColor(): string {\r\n        return this._highlightColor;\r\n    }\r\n\r\n    public set highlightColor(value: string) {\r\n        if (this._highlightColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._highlightColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a value indicating the scale factor on X axis (1 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#rotation-and-scaling\r\n     */\r\n    @serialize()\r\n    public get scaleX(): number {\r\n        return this._scaleX;\r\n    }\r\n\r\n    public set scaleX(value: number) {\r\n        if (this._scaleX === value) {\r\n            return;\r\n        }\r\n\r\n        this._scaleX = value;\r\n        this._markAsDirty();\r\n        this._markMatrixAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a value indicating the scale factor on Y axis (1 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#rotation-and-scaling\r\n     */\r\n    @serialize()\r\n    public get scaleY(): number {\r\n        return this._scaleY;\r\n    }\r\n\r\n    public set scaleY(value: number) {\r\n        if (this._scaleY === value) {\r\n            return;\r\n        }\r\n\r\n        this._scaleY = value;\r\n        this._markAsDirty();\r\n        this._markMatrixAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the rotation angle (0 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#rotation-and-scaling\r\n     */\r\n    @serialize()\r\n    public get rotation(): number {\r\n        return this._rotation;\r\n    }\r\n\r\n    public set rotation(value: number) {\r\n        if (this._rotation === value) {\r\n            return;\r\n        }\r\n\r\n        this._rotation = value;\r\n        this._markAsDirty();\r\n        this._markMatrixAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the transformation center on Y axis (0 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#rotation-and-scaling\r\n     */\r\n    @serialize()\r\n    public get transformCenterY(): number {\r\n        return this._transformCenterY;\r\n    }\r\n\r\n    public set transformCenterY(value: number) {\r\n        if (this._transformCenterY === value) {\r\n            return;\r\n        }\r\n\r\n        this._transformCenterY = value;\r\n        this._markAsDirty();\r\n        this._markMatrixAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the transformation center on X axis (0 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#rotation-and-scaling\r\n     */\r\n    @serialize()\r\n    public get transformCenterX(): number {\r\n        return this._transformCenterX;\r\n    }\r\n\r\n    public set transformCenterX(value: number) {\r\n        if (this._transformCenterX === value) {\r\n            return;\r\n        }\r\n\r\n        this._transformCenterX = value;\r\n        this._markAsDirty();\r\n        this._markMatrixAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the horizontal alignment\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#alignments\r\n     */\r\n    @serialize()\r\n    public get horizontalAlignment(): number {\r\n        return this._horizontalAlignment;\r\n    }\r\n\r\n    public set horizontalAlignment(value: number) {\r\n        if (this._horizontalAlignment === value) {\r\n            return;\r\n        }\r\n\r\n        this._horizontalAlignment = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the vertical alignment\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#alignments\r\n     */\r\n    @serialize()\r\n    public get verticalAlignment(): number {\r\n        return this._verticalAlignment;\r\n    }\r\n\r\n    public set verticalAlignment(value: number) {\r\n        if (this._verticalAlignment === value) {\r\n            return;\r\n        }\r\n\r\n        this._verticalAlignment = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _fixedRatio = 0;\r\n    public set fixedRatio(value: number) {\r\n        if (this._fixedRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._fixedRatio = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a fixed ratio for this control.\r\n     * When different from 0, the ratio is used to compute the \"second\" dimension.\r\n     * The first dimension used in the computation is the last one set (by setting width / widthInPixels or height / heightInPixels), and the\r\n     * second dimension is computed as first dimension * fixedRatio\r\n     */\r\n    @serialize()\r\n    public get fixedRatio(): number {\r\n        return this._fixedRatio;\r\n    }\r\n\r\n    private _fixedRatioMasterIsWidth = true;\r\n    set fixedRatioMasterIsWidth(value: boolean) {\r\n        if (this._fixedRatioMasterIsWidth === value) {\r\n            return;\r\n        }\r\n        this._fixedRatioMasterIsWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the fixed ratio is set on the width instead of the height. True by default.\r\n     * When the height of a control is set, this property is changed to false.\r\n     */\r\n    @serialize()\r\n    get fixedRatioMasterIsWidth(): boolean {\r\n        return this._fixedRatioMasterIsWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets control width\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get width(): string | number {\r\n        return this._width.toString(this._host);\r\n    }\r\n\r\n    public set width(value: string | number) {\r\n        this._fixedRatioMasterIsWidth = true;\r\n\r\n        if (this._width.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._width.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the control width in pixel\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public get widthInPixels(): number {\r\n        return this._width.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set widthInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this._fixedRatioMasterIsWidth = true;\r\n        this.width = value + \"px\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets control height\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get height(): string | number {\r\n        return this._height.toString(this._host);\r\n    }\r\n\r\n    public set height(value: string | number) {\r\n        this._fixedRatioMasterIsWidth = false;\r\n\r\n        if (this._height.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._height.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets control height in pixel\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public get heightInPixels(): number {\r\n        return this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n    }\r\n\r\n    public set heightInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this._fixedRatioMasterIsWidth = false;\r\n        this.height = value + \"px\";\r\n    }\r\n\r\n    /** Gets or set font family */\r\n    public get fontFamily(): string {\r\n        return this._fontFamily;\r\n    }\r\n\r\n    public set fontFamily(value: string) {\r\n        if (this._fontFamily === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontFamily = value;\r\n        this._resetFontCache();\r\n    }\r\n\r\n    /** Gets or sets font style */\r\n    public get fontStyle(): string {\r\n        return this._fontStyle;\r\n    }\r\n\r\n    public set fontStyle(value: string) {\r\n        if (this._fontStyle === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontStyle = value;\r\n        this._resetFontCache();\r\n    }\r\n\r\n    /** Gets or sets font weight */\r\n    public get fontWeight(): string {\r\n        return this._fontWeight;\r\n    }\r\n\r\n    public set fontWeight(value: string) {\r\n        if (this._fontWeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontWeight = value;\r\n        this._resetFontCache();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets style\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#styles\r\n     */\r\n    @serialize()\r\n    public get style(): Nullable<Style> {\r\n        return this._style;\r\n    }\r\n\r\n    public set style(value: Nullable<Style>) {\r\n        if (this._style) {\r\n            this._style.onChangedObservable.remove(this._styleObserver);\r\n            this._styleObserver = null;\r\n        }\r\n\r\n        this._style = value;\r\n\r\n        if (this._style) {\r\n            this._styleObserver = this._style.onChangedObservable.add(() => {\r\n                this._markAsDirty();\r\n                this._resetFontCache();\r\n            });\r\n        }\r\n\r\n        this._markAsDirty();\r\n        this._resetFontCache();\r\n    }\r\n\r\n    /** @internal */\r\n    public get _isFontSizeInPercentage(): boolean {\r\n        return this._fontSize.isPercentage;\r\n    }\r\n\r\n    /** Gets or sets font size in pixels */\r\n    public get fontSizeInPixels(): number {\r\n        const fontSizeToUse = this._style ? this._style._fontSize : this._fontSize;\r\n\r\n        if (fontSizeToUse.isPixel) {\r\n            return fontSizeToUse.getValue(this._host);\r\n        }\r\n\r\n        return fontSizeToUse.getValueInPixel(this._host, this._tempParentMeasure.height || this._cachedParentMeasure.height);\r\n    }\r\n\r\n    public set fontSizeInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.fontSize = value + \"px\";\r\n    }\r\n\r\n    /** Gets or sets font size */\r\n    public get fontSize(): string | number {\r\n        return this._fontSize.toString(this._host);\r\n    }\r\n\r\n    public set fontSize(value: string | number) {\r\n        if (this._fontSize.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._fontSize.fromString(value)) {\r\n            this._markAsDirty();\r\n            this._resetFontCache();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets foreground color */\r\n    @serialize()\r\n    public get color(): string {\r\n        return this._color;\r\n    }\r\n\r\n    public set color(value: string) {\r\n        if (this._color === value) {\r\n            return;\r\n        }\r\n\r\n        this._color = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets gradient. Setting a gradient will override the color */\r\n    @serialize()\r\n    public get gradient(): Nullable<BaseGradient> {\r\n        return this._gradient;\r\n    }\r\n\r\n    public set gradient(value: Nullable<BaseGradient>) {\r\n        if (this._gradient === value) {\r\n            return;\r\n        }\r\n\r\n        this._gradient = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets z index which is used to reorder controls on the z axis */\r\n    @serialize()\r\n    public get zIndex(): number {\r\n        return this._zIndex;\r\n    }\r\n\r\n    public set zIndex(value: number) {\r\n        if (this.zIndex === value) {\r\n            return;\r\n        }\r\n\r\n        this._zIndex = value;\r\n\r\n        if (this.parent) {\r\n            this.parent._reOrderControl(this);\r\n        }\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the control can be rendered */\r\n    @serialize()\r\n    public get notRenderable(): boolean {\r\n        return this._doNotRender;\r\n    }\r\n\r\n    public set notRenderable(value: boolean) {\r\n        if (this._doNotRender === value) {\r\n            return;\r\n        }\r\n\r\n        this._doNotRender = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the control is visible */\r\n    @serialize()\r\n    public get isVisible(): boolean {\r\n        return this._isVisible;\r\n    }\r\n\r\n    public set isVisible(value: boolean) {\r\n        if (this._isVisible === value) {\r\n            return;\r\n        }\r\n\r\n        this._isVisible = value;\r\n        this._markAsDirty(true);\r\n\r\n        this.onIsVisibleChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /** Gets a boolean indicating that the control needs to update its rendering */\r\n    public get isDirty(): boolean {\r\n        return this._isDirty;\r\n    }\r\n\r\n    /**\r\n     * Gets the current linked mesh (or null if none)\r\n     */\r\n    public get linkedMesh(): Nullable<TransformNode> {\r\n        return this._linkedMesh;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding should work like in CSS.\r\n     * Basically, it will add the padding amount on each side of the parent control for its children.\r\n     */\r\n    @serialize()\r\n    public get descendantsOnlyPadding(): boolean {\r\n        return this._descendantsOnlyPadding;\r\n    }\r\n\r\n    public set descendantsOnlyPadding(value: boolean) {\r\n        if (this._descendantsOnlyPadding === value) {\r\n            return;\r\n        }\r\n\r\n        this._descendantsOnlyPadding = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding to use on the left of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get paddingLeft(): string | number {\r\n        return this._paddingLeft.toString(this._host);\r\n    }\r\n\r\n    public set paddingLeft(value: string | number) {\r\n        if (this._paddingLeft.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding in pixels to use on the left of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public get paddingLeftInPixels(): number {\r\n        return this._paddingLeft.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set paddingLeftInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.paddingLeft = value + \"px\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _paddingLeftInPixels(): number {\r\n        if (this._descendantsOnlyPadding) {\r\n            return 0;\r\n        }\r\n\r\n        return this.paddingLeftInPixels;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding to use on the right of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get paddingRight(): string | number {\r\n        return this._paddingRight.toString(this._host);\r\n    }\r\n\r\n    public set paddingRight(value: string | number) {\r\n        if (this._paddingRight.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding in pixels to use on the right of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public get paddingRightInPixels(): number {\r\n        return this._paddingRight.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set paddingRightInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.paddingRight = value + \"px\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _paddingRightInPixels(): number {\r\n        if (this._descendantsOnlyPadding) {\r\n            return 0;\r\n        }\r\n\r\n        return this.paddingRightInPixels;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding to use on the top of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get paddingTop(): string | number {\r\n        return this._paddingTop.toString(this._host);\r\n    }\r\n\r\n    public set paddingTop(value: string | number) {\r\n        if (this._paddingTop.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding in pixels to use on the top of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public get paddingTopInPixels(): number {\r\n        return this._paddingTop.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n    }\r\n\r\n    public set paddingTopInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.paddingTop = value + \"px\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _paddingTopInPixels(): number {\r\n        if (this._descendantsOnlyPadding) {\r\n            return 0;\r\n        }\r\n\r\n        return this.paddingTopInPixels;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding to use on the bottom of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get paddingBottom(): string | number {\r\n        return this._paddingBottom.toString(this._host);\r\n    }\r\n\r\n    public set paddingBottom(value: string | number) {\r\n        if (this._paddingBottom.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the padding in pixels to use on the bottom of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public get paddingBottomInPixels(): number {\r\n        return this._paddingBottom.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n    }\r\n\r\n    public set paddingBottomInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.paddingBottom = value + \"px\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _paddingBottomInPixels(): number {\r\n        if (this._descendantsOnlyPadding) {\r\n            return 0;\r\n        }\r\n\r\n        return this.paddingBottomInPixels;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the left coordinate of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get left(): string | number {\r\n        return this._left.toString(this._host);\r\n    }\r\n\r\n    public set left(value: string | number) {\r\n        if (this._left.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the left coordinate in pixels of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public get leftInPixels(): number {\r\n        return this._left.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set leftInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.left = value + \"px\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the top coordinate of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public get top(): string | number {\r\n        return this._top.toString(this._host);\r\n    }\r\n\r\n    public set top(value: string | number) {\r\n        if (this._top.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the top coordinate in pixels of the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public get topInPixels(): number {\r\n        return this._top.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n    }\r\n\r\n    public set topInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.top = value + \"px\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the offset on X axis to the linked mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#tracking-positions\r\n     */\r\n    @serialize()\r\n    public get linkOffsetX(): string | number {\r\n        return this._linkOffsetX.toString(this._host);\r\n    }\r\n\r\n    public set linkOffsetX(value: string | number) {\r\n        if (this._linkOffsetX.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the offset in pixels on X axis to the linked mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#tracking-positions\r\n     */\r\n    public get linkOffsetXInPixels(): number {\r\n        return this._linkOffsetX.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set linkOffsetXInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.linkOffsetX = value + \"px\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the offset on Y axis to the linked mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#tracking-positions\r\n     */\r\n    @serialize()\r\n    public get linkOffsetY(): string | number {\r\n        return this._linkOffsetY.toString(this._host);\r\n    }\r\n\r\n    public set linkOffsetY(value: string | number) {\r\n        if (this._linkOffsetY.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a value indicating the offset in pixels on Y axis to the linked mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#tracking-positions\r\n     */\r\n    public get linkOffsetYInPixels(): number {\r\n        return this._linkOffsetY.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n    }\r\n\r\n    public set linkOffsetYInPixels(value: number) {\r\n        if (isNaN(value)) {\r\n            return;\r\n        }\r\n        this.linkOffsetY = value + \"px\";\r\n    }\r\n\r\n    /** Gets the center coordinate on X axis */\r\n    public get centerX(): number {\r\n        return this._currentMeasure.left + this._currentMeasure.width / 2;\r\n    }\r\n\r\n    /** Gets the center coordinate on Y axis */\r\n    public get centerY(): number {\r\n        return this._currentMeasure.top + this._currentMeasure.height / 2;\r\n    }\r\n\r\n    /** Gets or sets if control is Enabled */\r\n    @serialize()\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        if (this._isEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._isEnabled = value;\r\n        this._markAsDirty();\r\n        // if this control or any of it's descendants are under a pointer, we need to fire a pointerOut event\r\n        const recursivelyFirePointerOut = (control: Control) => {\r\n            if (!control.host) {\r\n                return;\r\n            }\r\n            for (const pointer in control.host._lastControlOver) {\r\n                if (control === this.host._lastControlOver[pointer]) {\r\n                    control._onPointerOut(control, null, true);\r\n                    delete control.host._lastControlOver[pointer];\r\n                }\r\n            }\r\n            if ((control as Container).children !== undefined) {\r\n                (control as Container).children.forEach(recursivelyFirePointerOut);\r\n            }\r\n        };\r\n        recursivelyFirePointerOut(this);\r\n        this.onEnabledStateChangedObservable.notifyObservers(value);\r\n    }\r\n    /** Gets or sets background color of control if it's disabled. Only applies to Button class. */\r\n    @serialize()\r\n    public get disabledColor(): string {\r\n        return this._disabledColor;\r\n    }\r\n\r\n    public set disabledColor(value: string) {\r\n        if (this._disabledColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._disabledColor = value;\r\n        this._markAsDirty();\r\n    }\r\n    /** Gets or sets front color of control if it's disabled. Only applies to Checkbox class. */\r\n    @serialize()\r\n    public get disabledColorItem(): string {\r\n        return this._disabledColorItem;\r\n    }\r\n\r\n    public set disabledColorItem(value: string) {\r\n        if (this._disabledColorItem === value) {\r\n            return;\r\n        }\r\n\r\n        this._disabledColorItem = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets/sets the overlap group of the control.\r\n     * Controls with overlapGroup set to a number can be deoverlapped.\r\n     * Controls with overlapGroup set to undefined are not deoverlapped.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#deoverlapping\r\n     */\r\n    @serialize()\r\n    public overlapGroup?: number;\r\n    /**\r\n     * Gets/sets the deoverlap movement multiplier\r\n     */\r\n    @serialize()\r\n    public overlapDeltaMultiplier?: number;\r\n\r\n    /**\r\n     * Array of animations\r\n     */\r\n    animations: Nullable<Animation[]> = null;\r\n\r\n    // Focus functionality\r\n\r\n    protected _focusedColor: Nullable<string> = null;\r\n    /**\r\n     * Border color when control is focused\r\n     * When not defined the ADT color will be used. If no ADT color is defined, focused state won't have any border\r\n     */\r\n    public get focusedColor(): Nullable<string> {\r\n        return this._focusedColor;\r\n    }\r\n    public set focusedColor(value: Nullable<string>) {\r\n        this._focusedColor = value;\r\n    }\r\n    /**\r\n     * The tab index of this control. -1 indicates this control is not part of the tab navigation.\r\n     * A positive value indicates the order of the control in the tab navigation.\r\n     * A value of 0 indicated the control will be focused after all controls with a positive index.\r\n     * More than one control can have the same tab index and the navigation would then go through all controls with the same value in an order defined by the layout or the hierarchy.\r\n     * The value can be changed at any time.\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\r\n     */\r\n    public tabIndex: number = -1;\r\n    protected _isFocused = false;\r\n    protected _unfocusedColor: Nullable<string> = null;\r\n\r\n    /** Observable raised when the control gets the focus */\r\n    public onFocusObservable = new Observable<Control>();\r\n    /** Observable raised when the control loses the focus */\r\n    public onBlurObservable = new Observable<Control>();\r\n    /** Observable raised when a key event was processed */\r\n    public onKeyboardEventProcessedObservable = new Observable<IKeyboardEvent>();\r\n\r\n    /** @internal */\r\n    public onBlur(): void {\r\n        if (this._isFocused) {\r\n            this._isFocused = false;\r\n            if (this.focusedColor && this._unfocusedColor != null) {\r\n                // Set color back to saved unfocused color\r\n                this.color = this._unfocusedColor;\r\n            }\r\n            this.onBlurObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public onFocus(): void {\r\n        this._isFocused = true;\r\n\r\n        if (this.focusedColor) {\r\n            // Save the unfocused color\r\n            this._unfocusedColor = this.color;\r\n            this.color = this.focusedColor;\r\n        }\r\n        this.onFocusObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Function called to get the list of controls that should not steal the focus from this control\r\n     * @returns an array of controls\r\n     */\r\n    public keepsFocusWith(): Nullable<Control[]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Function to focus a button programmatically\r\n     */\r\n    public focus() {\r\n        this._host.moveFocusToControl(this);\r\n    }\r\n\r\n    /**\r\n     * Function to unfocus a button programmatically\r\n     */\r\n    public blur() {\r\n        this._host.focusedControl = null;\r\n    }\r\n\r\n    /**\r\n     * Handles the keyboard event\r\n     * @param evt Defines the KeyboardEvent\r\n     */\r\n    public processKeyboard(evt: IKeyboardEvent): void {\r\n        // if enter, trigger the new observable\r\n        if (evt.key === \"Enter\") {\r\n            this.onEnterPressedObservable.notifyObservers(this);\r\n        }\r\n        this.onKeyboardEventProcessedObservable.notifyObservers(evt, -1, this);\r\n    }\r\n\r\n    // Functions\r\n\r\n    /**\r\n     * Creates a new control\r\n     * @param name defines the name of the control\r\n     */\r\n    constructor(\r\n        /** defines the name of the control */\r\n        public name?: string\r\n    ) {}\r\n\r\n    /** @internal */\r\n    protected _getTypeName(): string {\r\n        return \"Control\";\r\n    }\r\n\r\n    /**\r\n     * Gets the first ascendant in the hierarchy of the given type\r\n     * @param className defines the required type\r\n     * @returns the ascendant or null if not found\r\n     */\r\n    public getAscendantOfClass(className: string): Nullable<Control> {\r\n        if (!this.parent) {\r\n            return null;\r\n        }\r\n\r\n        if (this.parent.getClassName() === className) {\r\n            return this.parent;\r\n        }\r\n\r\n        return this.parent.getAscendantOfClass(className);\r\n    }\r\n\r\n    /**\r\n     * Mark control element as dirty\r\n     * @param force force non visible elements to be marked too\r\n     */\r\n    public markAsDirty(force = false): void {\r\n        this._markAsDirty(force);\r\n    }\r\n\r\n    /**\r\n     * Mark the element and its children as dirty\r\n     */\r\n    public markAllAsDirty(): void {\r\n        this._markAllAsDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    public _resetFontCache(): void {\r\n        this._fontSet = true;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Determines if a container is an ascendant of the current control\r\n     * @param container defines the container to look for\r\n     * @returns true if the container is one of the ascendant of the control\r\n     */\r\n    public isAscendant(container: Control): boolean {\r\n        if (!this.parent) {\r\n            return false;\r\n        }\r\n\r\n        if (this.parent === container) {\r\n            return true;\r\n        }\r\n\r\n        return this.parent.isAscendant(container);\r\n    }\r\n\r\n    /**\r\n     * Gets coordinates in local control space\r\n     * @param globalCoordinates defines the coordinates to transform\r\n     * @returns the new coordinates in local space\r\n     */\r\n    public getLocalCoordinates(globalCoordinates: Vector2): Vector2 {\r\n        const result = Vector2.Zero();\r\n\r\n        this.getLocalCoordinatesToRef(globalCoordinates, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets coordinates in local control space\r\n     * @param globalCoordinates defines the coordinates to transform\r\n     * @param result defines the target vector2 where to store the result\r\n     * @returns the current control\r\n     */\r\n    public getLocalCoordinatesToRef(globalCoordinates: Vector2, result: Vector2): Control {\r\n        result.x = globalCoordinates.x - this._currentMeasure.left;\r\n        result.y = globalCoordinates.y - this._currentMeasure.top;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets coordinates in parent local control space\r\n     * @param globalCoordinates defines the coordinates to transform\r\n     * @returns the new coordinates in parent local space\r\n     */\r\n    public getParentLocalCoordinates(globalCoordinates: Vector2): Vector2 {\r\n        const result = Vector2.Zero();\r\n\r\n        result.x = globalCoordinates.x - this._cachedParentMeasure.left;\r\n        result.y = globalCoordinates.y - this._cachedParentMeasure.top;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Move the current control to a vector3 position projected onto the screen.\r\n     * @param position defines the target position\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public moveToVector3(position: Vector3, scene: Scene): void {\r\n        if (!this._host || this.parent !== this._host._rootContainer) {\r\n            Tools.Error(\"Cannot move a control to a vector3 if the control is not at root level\");\r\n            return;\r\n        }\r\n\r\n        this.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n\r\n        const globalViewport = this._host._getGlobalViewport();\r\n        const projectedPosition = Vector3.Project(position, Matrix.IdentityReadOnly, scene.getTransformMatrix(), globalViewport);\r\n\r\n        this._moveToProjectedPosition(projectedPosition);\r\n\r\n        if (projectedPosition.z < 0 || projectedPosition.z > 1) {\r\n            this.notRenderable = true;\r\n            return;\r\n        }\r\n        this.notRenderable = false;\r\n    }\r\n\r\n    /**\r\n     * Will store all controls that have this control as ascendant in a given array\r\n     * @param results defines the array where to store the descendants\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     */\r\n    public getDescendantsToRef(results: Control[], directDescendantsOnly: boolean = false, predicate?: (control: Control) => boolean): void {\r\n        // Do nothing by default\r\n    }\r\n\r\n    /**\r\n     * Will return all controls that have this control as ascendant\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns all child controls\r\n     */\r\n    public getDescendants(directDescendantsOnly?: boolean, predicate?: (control: Control) => boolean): Control[] {\r\n        const results: Control[] = [];\r\n\r\n        this.getDescendantsToRef(results, directDescendantsOnly, predicate);\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Link current control with a target mesh\r\n     * @param mesh defines the mesh to link with\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#tracking-positions\r\n     */\r\n    public linkWithMesh(mesh: Nullable<TransformNode>): void {\r\n        if (!this._host || (this.parent && this.parent !== this._host._rootContainer)) {\r\n            if (mesh) {\r\n                Tools.Error(\"Cannot link a control to a mesh if the control is not at root level\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const index = this._host._linkedControls.indexOf(this);\r\n        if (index !== -1) {\r\n            this._linkedMesh = mesh;\r\n            if (!mesh) {\r\n                this._host._linkedControls.splice(index, 1);\r\n            }\r\n            return;\r\n        } else if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        this.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this._linkedMesh = mesh;\r\n        this._host._linkedControls.push(this);\r\n    }\r\n\r\n    /**\r\n     * Shorthand function to set the top, right, bottom, and left padding values on the control.\r\n     * @param { string | number} paddingTop - The value of the top padding.\r\n     * @param { string | number} paddingRight - The value of the right padding. If omitted, top is used.\r\n     * @param { string | number} paddingBottom - The value of the bottom padding. If omitted, top is used.\r\n     * @param { string | number} paddingLeft - The value of the left padding. If omitted, right is used.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public setPadding(paddingTop: string | number, paddingRight?: string | number, paddingBottom?: string | number, paddingLeft?: string | number) {\r\n        const top = paddingTop;\r\n        const right = paddingRight ?? top;\r\n        const bottom = paddingBottom ?? top;\r\n        const left = paddingLeft ?? right;\r\n\r\n        this.paddingTop = top;\r\n        this.paddingRight = right;\r\n        this.paddingBottom = bottom;\r\n        this.paddingLeft = left;\r\n    }\r\n\r\n    /**\r\n     * Shorthand funtion to set the top, right, bottom, and left padding values in pixels on the control.\r\n     * @param { number} paddingTop - The value in pixels of the top padding.\r\n     * @param { number} paddingRight - The value in pixels of the right padding. If omitted, top is used.\r\n     * @param { number} paddingBottom - The value in pixels of the bottom padding. If omitted, top is used.\r\n     * @param { number} paddingLeft - The value in pixels of the left padding. If omitted, right is used.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    public setPaddingInPixels(paddingTop: number, paddingRight?: number, paddingBottom?: number, paddingLeft?: number) {\r\n        const top = paddingTop;\r\n        const right = paddingRight ?? top;\r\n        const bottom = paddingBottom ?? top;\r\n        const left = paddingLeft ?? right;\r\n\r\n        this.paddingTopInPixels = top;\r\n        this.paddingRightInPixels = right;\r\n        this.paddingBottomInPixels = bottom;\r\n        this.paddingLeftInPixels = left;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _moveToProjectedPosition(projectedPosition: Vector3): void {\r\n        const oldLeft = this._left.getValue(this._host);\r\n        const oldTop = this._top.getValue(this._host);\r\n\r\n        const parentMeasure = this.parent?._currentMeasure;\r\n        if (parentMeasure) {\r\n            this._processMeasures(parentMeasure, this._host.getContext());\r\n        }\r\n\r\n        let newLeft = projectedPosition.x + this._linkOffsetX.getValue(this._host) - this._currentMeasure.width / 2;\r\n        let newTop = projectedPosition.y + this._linkOffsetY.getValue(this._host) - this._currentMeasure.height / 2;\r\n\r\n        const leftAndTopIgnoreAdaptiveScaling = this._left.ignoreAdaptiveScaling && this._top.ignoreAdaptiveScaling;\r\n        if (leftAndTopIgnoreAdaptiveScaling) {\r\n            if (Math.abs(newLeft - oldLeft) < 0.5) {\r\n                newLeft = oldLeft;\r\n            }\r\n\r\n            if (Math.abs(newTop - oldTop) < 0.5) {\r\n                newTop = oldTop;\r\n            }\r\n        }\r\n\r\n        if (!leftAndTopIgnoreAdaptiveScaling && oldLeft === newLeft && oldTop === newTop) {\r\n            return;\r\n        }\r\n\r\n        this.left = newLeft + \"px\";\r\n        this.top = newTop + \"px\";\r\n\r\n        this._left.ignoreAdaptiveScaling = true;\r\n        this._top.ignoreAdaptiveScaling = true;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _offsetLeft(offset: number) {\r\n        this._isDirty = true;\r\n        this._currentMeasure.left += offset;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _offsetTop(offset: number) {\r\n        this._isDirty = true;\r\n        this._currentMeasure.top += offset;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markMatrixAsDirty(): void {\r\n        this._isMatrixDirty = true;\r\n        this._flagDescendantsAsMatrixDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    public _flagDescendantsAsMatrixDirty(): void {\r\n        // No child\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _intersectsRect(rect: Measure, context?: ICanvasRenderingContext) {\r\n        // make sure we are transformed correctly before checking intersections. no-op if nothing is dirty.\r\n        this._transform(context);\r\n        if (this._evaluatedMeasure.left >= rect.left + rect.width) {\r\n            return false;\r\n        }\r\n\r\n        if (this._evaluatedMeasure.top >= rect.top + rect.height) {\r\n            return false;\r\n        }\r\n\r\n        if (this._evaluatedMeasure.left + this._evaluatedMeasure.width <= rect.left) {\r\n            return false;\r\n        }\r\n\r\n        if (this._evaluatedMeasure.top + this._evaluatedMeasure.height <= rect.top) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _computeAdditionalOffsetX() {\r\n        return 0;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _computeAdditionalOffsetY() {\r\n        return 0;\r\n    }\r\n\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public invalidateRect() {\r\n        this._transform();\r\n        if (this.host && this.host.useInvalidateRectOptimization) {\r\n            // Rotate by transform to get the measure transformed to global space\r\n            this._currentMeasure.transformToRef(this._transformMatrix, this._tmpMeasureA);\r\n            // get the boudning box of the current measure and last frames measure in global space and invalidate it\r\n            // the previous measure is used to properly clear a control that is scaled down\r\n            Measure.CombineToRef(this._tmpMeasureA, this._prevCurrentMeasureTransformedIntoGlobalSpace, this._tmpMeasureA);\r\n\r\n            // Expand rect based on shadows\r\n            const shadowOffsetX = this.shadowOffsetX;\r\n            const shadowOffsetY = this.shadowOffsetY;\r\n            const shadowBlur = Math.max(this._previousShadowBlur, this.shadowBlur);\r\n\r\n            const leftShadowOffset = Math.min(Math.min(shadowOffsetX, 0) - shadowBlur * 2, 0);\r\n            const rightShadowOffset = Math.max(Math.max(shadowOffsetX, 0) + shadowBlur * 2, 0);\r\n            const topShadowOffset = Math.min(Math.min(shadowOffsetY, 0) - shadowBlur * 2, 0);\r\n            const bottomShadowOffset = Math.max(Math.max(shadowOffsetY, 0) + shadowBlur * 2, 0);\r\n\r\n            const offsetX = this._computeAdditionalOffsetX();\r\n            const offsetY = this._computeAdditionalOffsetY();\r\n\r\n            this.host.invalidateRect(\r\n                Math.floor(this._tmpMeasureA.left + leftShadowOffset - offsetX),\r\n                Math.floor(this._tmpMeasureA.top + topShadowOffset - offsetY),\r\n                Math.ceil(this._tmpMeasureA.left + this._tmpMeasureA.width + rightShadowOffset + offsetX),\r\n                Math.ceil(this._tmpMeasureA.top + this._tmpMeasureA.height + bottomShadowOffset + offsetY)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _markAsDirty(force = false): void {\r\n        if (!this._isVisible && !force) {\r\n            return;\r\n        }\r\n\r\n        this._isDirty = true;\r\n        this._markMatrixAsDirty();\r\n\r\n        // Redraw only this rectangle\r\n        if (this._host) {\r\n            this._host.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAllAsDirty(): void {\r\n        this._markAsDirty();\r\n\r\n        if (this._font) {\r\n            this._prepareFont();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _link(host: AdvancedDynamicTexture): void {\r\n        this._host = host;\r\n        if (this._host) {\r\n            this.uniqueId = this._host.getScene()!.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _transform(context?: ICanvasRenderingContext): void {\r\n        if (!this._isMatrixDirty && this._scaleX === 1 && this._scaleY === 1 && this._rotation === 0) {\r\n            return;\r\n        }\r\n\r\n        // postTranslate\r\n        const offsetX = this._currentMeasure.width * this._transformCenterX + this._currentMeasure.left;\r\n        const offsetY = this._currentMeasure.height * this._transformCenterY + this._currentMeasure.top;\r\n        if (context) {\r\n            context.translate(offsetX, offsetY);\r\n\r\n            // rotate\r\n            context.rotate(this._rotation);\r\n\r\n            // scale\r\n            context.scale(this._scaleX, this._scaleY);\r\n\r\n            // preTranslate\r\n            context.translate(-offsetX, -offsetY);\r\n        }\r\n        // Need to update matrices?\r\n        if (this._isMatrixDirty || this._cachedOffsetX !== offsetX || this._cachedOffsetY !== offsetY) {\r\n            this._cachedOffsetX = offsetX;\r\n            this._cachedOffsetY = offsetY;\r\n            this._isMatrixDirty = false;\r\n            this._flagDescendantsAsMatrixDirty();\r\n\r\n            Matrix2D.ComposeToRef(-offsetX, -offsetY, this._rotation, this._scaleX, this._scaleY, this.parent ? this.parent._transformMatrix : null, this._transformMatrix);\r\n\r\n            this._transformMatrix.invertToRef(this._invertTransformMatrix);\r\n            this._currentMeasure.transformToRef(this._transformMatrix, this._evaluatedMeasure);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _renderHighlight(context: ICanvasRenderingContext): void {\r\n        if (!this.isHighlighted) {\r\n            return;\r\n        }\r\n\r\n        context.save();\r\n        context.strokeStyle = this._highlightColor;\r\n        context.lineWidth = this._highlightLineWidth;\r\n\r\n        this._renderHighlightSpecific(context);\r\n        context.restore();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _renderHighlightSpecific(context: ICanvasRenderingContext): void {\r\n        context.strokeRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n    }\r\n\r\n    protected _getColor(context: ICanvasRenderingContext): string | ICanvasGradient {\r\n        return this.gradient ? this.gradient.getCanvasGradient(context) : this.color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _applyStates(context: ICanvasRenderingContext): void {\r\n        if (this._isFontSizeInPercentage) {\r\n            this._fontSet = true;\r\n        }\r\n\r\n        if (this._host && this._host.useSmallestIdeal && !this._font) {\r\n            this._fontSet = true;\r\n        }\r\n\r\n        if (this._fontSet) {\r\n            this._prepareFont();\r\n            this._fontSet = false;\r\n        }\r\n\r\n        if (this._font) {\r\n            context.font = this._font;\r\n        }\r\n\r\n        if (this._color || this.gradient) {\r\n            context.fillStyle = this._getColor(context);\r\n        }\r\n\r\n        if (Control.AllowAlphaInheritance) {\r\n            context.globalAlpha *= this._alpha;\r\n        } else if (this._alphaSet) {\r\n            context.globalAlpha = this.parent && !this.parent.renderToIntermediateTexture ? this.parent.alpha * this._alpha : this._alpha;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _layout(parentMeasure: Measure, context: ICanvasRenderingContext): boolean {\r\n        if (!this.isDirty && (!this.isVisible || this.notRenderable)) {\r\n            return false;\r\n        }\r\n\r\n        if (this._isDirty || !this._cachedParentMeasure.isEqualsTo(parentMeasure)) {\r\n            this.host._numLayoutCalls++;\r\n\r\n            this._currentMeasure.addAndTransformToRef(\r\n                this._transformMatrix,\r\n                -this._paddingLeftInPixels | 0,\r\n                -this._paddingTopInPixels | 0,\r\n                this._paddingRightInPixels | 0,\r\n                this._paddingBottomInPixels | 0,\r\n                this._prevCurrentMeasureTransformedIntoGlobalSpace\r\n            );\r\n\r\n            context.save();\r\n\r\n            this._applyStates(context);\r\n\r\n            let rebuildCount = 0;\r\n            do {\r\n                this._rebuildLayout = false;\r\n                this._processMeasures(parentMeasure, context);\r\n                rebuildCount++;\r\n            } while (this._rebuildLayout && rebuildCount < 3);\r\n\r\n            if (rebuildCount >= 3) {\r\n                Logger.Error(`Layout cycle detected in GUI (Control name=${this.name}, uniqueId=${this.uniqueId})`);\r\n            }\r\n\r\n            context.restore();\r\n            this.invalidateRect();\r\n            this._evaluateClippingState(parentMeasure);\r\n        }\r\n\r\n        this._wasDirty = this._isDirty;\r\n        this._isDirty = false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _processMeasures(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        this._tempPaddingMeasure.copyFrom(parentMeasure);\r\n\r\n        // Apply padding if in correct mode\r\n        if (this.parent && this.parent.descendantsOnlyPadding) {\r\n            this._tempPaddingMeasure.left += this.parent.paddingLeftInPixels;\r\n            this._tempPaddingMeasure.top += this.parent.paddingTopInPixels;\r\n            this._tempPaddingMeasure.width -= this.parent.paddingLeftInPixels + this.parent.paddingRightInPixels;\r\n            this._tempPaddingMeasure.height -= this.parent.paddingTopInPixels + this.parent.paddingBottomInPixels;\r\n        }\r\n\r\n        this._currentMeasure.copyFrom(this._tempPaddingMeasure);\r\n\r\n        // Let children take some pre-measurement actions\r\n        this._preMeasure(this._tempPaddingMeasure, context);\r\n\r\n        this._measure();\r\n\r\n        // Let children take some post-measurement actions\r\n        this._postMeasure(this._tempPaddingMeasure, context);\r\n\r\n        this._computeAlignment(this._tempPaddingMeasure, context);\r\n\r\n        // Convert to int values\r\n        this._currentMeasure.left = this._currentMeasure.left | 0;\r\n        this._currentMeasure.top = this._currentMeasure.top | 0;\r\n        this._currentMeasure.width = this._currentMeasure.width | 0;\r\n        this._currentMeasure.height = this._currentMeasure.height | 0;\r\n\r\n        // Let children add more features\r\n        this._additionalProcessing(this._tempPaddingMeasure, context);\r\n\r\n        this._cachedParentMeasure.copyFrom(this._tempPaddingMeasure);\r\n\r\n        this._currentMeasure.transformToRef(this._transformMatrix, this._evaluatedMeasure);\r\n        if (this.onDirtyObservable.hasObservers()) {\r\n            this.onDirtyObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    protected _evaluateClippingState(parentMeasure: Measure) {\r\n        // Since transformMatrix is used here, we need to have it freshly computed\r\n        this._transform();\r\n        this._currentMeasure.transformToRef(this._transformMatrix, this._evaluatedMeasure);\r\n        if (this.parent && this.parent.clipChildren) {\r\n            parentMeasure.transformToRef(this.parent._transformMatrix, this._evaluatedParentMeasure);\r\n            // Early clip\r\n            if (this._evaluatedMeasure.left > this._evaluatedParentMeasure.left + this._evaluatedParentMeasure.width) {\r\n                this._isClipped = true;\r\n                return;\r\n            }\r\n\r\n            if (this._evaluatedMeasure.left + this._evaluatedMeasure.width < this._evaluatedParentMeasure.left) {\r\n                this._isClipped = true;\r\n                return;\r\n            }\r\n\r\n            if (this._evaluatedMeasure.top > this._evaluatedParentMeasure.top + this._evaluatedParentMeasure.height) {\r\n                this._isClipped = true;\r\n                return;\r\n            }\r\n\r\n            if (this._evaluatedMeasure.top + this._evaluatedMeasure.height < this._evaluatedParentMeasure.top) {\r\n                this._isClipped = true;\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._isClipped = false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _measure(): void {\r\n        // Width / Height\r\n        if (this._width.isPixel) {\r\n            this._currentMeasure.width = this._width.getValue(this._host);\r\n        } else {\r\n            this._currentMeasure.width *= this._width.getValue(this._host);\r\n        }\r\n\r\n        if (this._height.isPixel) {\r\n            this._currentMeasure.height = this._height.getValue(this._host);\r\n        } else {\r\n            this._currentMeasure.height *= this._height.getValue(this._host);\r\n        }\r\n\r\n        if (this._fixedRatio !== 0) {\r\n            if (this._fixedRatioMasterIsWidth) {\r\n                this._currentMeasure.height = this._currentMeasure.width * this._fixedRatio;\r\n            } else {\r\n                this._currentMeasure.width = this._currentMeasure.height * this._fixedRatio;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _computeAlignment(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        const width = this._currentMeasure.width;\r\n        const height = this._currentMeasure.height;\r\n\r\n        const parentWidth = parentMeasure.width;\r\n        const parentHeight = parentMeasure.height;\r\n\r\n        // Left / top\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        switch (this.horizontalAlignment) {\r\n            case Control.HORIZONTAL_ALIGNMENT_LEFT:\r\n                x = 0;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_RIGHT:\r\n                x = parentWidth - width;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_CENTER:\r\n                x = (parentWidth - width) / 2;\r\n                break;\r\n        }\r\n\r\n        switch (this.verticalAlignment) {\r\n            case Control.VERTICAL_ALIGNMENT_TOP:\r\n                y = 0;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_BOTTOM:\r\n                y = parentHeight - height;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_CENTER:\r\n                y = (parentHeight - height) / 2;\r\n                break;\r\n        }\r\n\r\n        if (!this.descendantsOnlyPadding) {\r\n            if (this._paddingLeft.isPixel) {\r\n                this._currentMeasure.left += this._paddingLeft.getValue(this._host);\r\n                this._currentMeasure.width -= this._paddingLeft.getValue(this._host);\r\n            } else {\r\n                this._currentMeasure.left += parentWidth * this._paddingLeft.getValue(this._host);\r\n                this._currentMeasure.width -= parentWidth * this._paddingLeft.getValue(this._host);\r\n            }\r\n\r\n            if (this._paddingRight.isPixel) {\r\n                this._currentMeasure.width -= this._paddingRight.getValue(this._host);\r\n            } else {\r\n                this._currentMeasure.width -= parentWidth * this._paddingRight.getValue(this._host);\r\n            }\r\n\r\n            if (this._paddingTop.isPixel) {\r\n                this._currentMeasure.top += this._paddingTop.getValue(this._host);\r\n                this._currentMeasure.height -= this._paddingTop.getValue(this._host);\r\n            } else {\r\n                this._currentMeasure.top += parentHeight * this._paddingTop.getValue(this._host);\r\n                this._currentMeasure.height -= parentHeight * this._paddingTop.getValue(this._host);\r\n            }\r\n\r\n            if (this._paddingBottom.isPixel) {\r\n                this._currentMeasure.height -= this._paddingBottom.getValue(this._host);\r\n            } else {\r\n                this._currentMeasure.height -= parentHeight * this._paddingBottom.getValue(this._host);\r\n            }\r\n        }\r\n\r\n        if (this._left.isPixel) {\r\n            this._currentMeasure.left += this._left.getValue(this._host);\r\n        } else {\r\n            this._currentMeasure.left += parentWidth * this._left.getValue(this._host);\r\n        }\r\n\r\n        if (this._top.isPixel) {\r\n            this._currentMeasure.top += this._top.getValue(this._host);\r\n        } else {\r\n            this._currentMeasure.top += parentHeight * this._top.getValue(this._host);\r\n        }\r\n\r\n        this._currentMeasure.left += x;\r\n        this._currentMeasure.top += y;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _preMeasure(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _postMeasure(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _clipForChildren(context: ICanvasRenderingContext): void {\r\n        // DO nothing\r\n    }\r\n\r\n    private static _ClipMeasure = new Measure(0, 0, 0, 0);\r\n    private _tmpMeasureA = new Measure(0, 0, 0, 0);\r\n    private _clip(context: ICanvasRenderingContext, invalidatedRectangle?: Nullable<Measure>) {\r\n        context.beginPath();\r\n        Control._ClipMeasure.copyFrom(this._currentMeasure);\r\n        if (invalidatedRectangle) {\r\n            // Rotate the invalidated rect into the control's space\r\n            invalidatedRectangle.transformToRef(this._invertTransformMatrix, this._tmpMeasureA);\r\n\r\n            // Get the intersection of the rect in context space and the current context\r\n            const intersection = new Measure(0, 0, 0, 0);\r\n            intersection.left = Math.max(this._tmpMeasureA.left, this._currentMeasure.left);\r\n            intersection.top = Math.max(this._tmpMeasureA.top, this._currentMeasure.top);\r\n            intersection.width = Math.min(this._tmpMeasureA.left + this._tmpMeasureA.width, this._currentMeasure.left + this._currentMeasure.width) - intersection.left;\r\n            intersection.height = Math.min(this._tmpMeasureA.top + this._tmpMeasureA.height, this._currentMeasure.top + this._currentMeasure.height) - intersection.top;\r\n            Control._ClipMeasure.copyFrom(intersection);\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            const shadowOffsetX = this.shadowOffsetX;\r\n            const shadowOffsetY = this.shadowOffsetY;\r\n            const shadowBlur = this.shadowBlur;\r\n\r\n            const leftShadowOffset = Math.min(Math.min(shadowOffsetX, 0) - shadowBlur * 2, 0);\r\n            const rightShadowOffset = Math.max(Math.max(shadowOffsetX, 0) + shadowBlur * 2, 0);\r\n            const topShadowOffset = Math.min(Math.min(shadowOffsetY, 0) - shadowBlur * 2, 0);\r\n            const bottomShadowOffset = Math.max(Math.max(shadowOffsetY, 0) + shadowBlur * 2, 0);\r\n\r\n            context.rect(\r\n                Control._ClipMeasure.left + leftShadowOffset,\r\n                Control._ClipMeasure.top + topShadowOffset,\r\n                Control._ClipMeasure.width + rightShadowOffset - leftShadowOffset,\r\n                Control._ClipMeasure.height + bottomShadowOffset - topShadowOffset\r\n            );\r\n        } else {\r\n            context.rect(Control._ClipMeasure.left, Control._ClipMeasure.top, Control._ClipMeasure.width, Control._ClipMeasure.height);\r\n        }\r\n\r\n        context.clip();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _render(context: ICanvasRenderingContext, invalidatedRectangle?: Nullable<Measure>): boolean {\r\n        if (!this.isVisible || this.notRenderable || this._isClipped) {\r\n            this._isDirty = false;\r\n            return false;\r\n        }\r\n\r\n        this.host._numRenderCalls++;\r\n\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        // Transform\r\n        this._transform(context);\r\n\r\n        // Clip\r\n        if (this.clipContent) {\r\n            this._clip(context, invalidatedRectangle);\r\n        }\r\n\r\n        if (this.onBeforeDrawObservable.hasObservers()) {\r\n            this.onBeforeDrawObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.useBitmapCache && !this._wasDirty && this._cacheData) {\r\n            context.putImageData(this._cacheData, this._currentMeasure.left, this._currentMeasure.top);\r\n        } else {\r\n            this._draw(context, invalidatedRectangle);\r\n        }\r\n\r\n        if (this.useBitmapCache && this._wasDirty) {\r\n            this._cacheData = context.getImageData(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n        }\r\n\r\n        this._renderHighlight(context);\r\n\r\n        if (this.onAfterDrawObservable.hasObservers()) {\r\n            this.onAfterDrawObservable.notifyObservers(this);\r\n        }\r\n\r\n        context.restore();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(context: ICanvasRenderingContext, invalidatedRectangle?: Nullable<Measure>): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Tests if a given coordinates belong to the current control\r\n     * @param x defines x coordinate to test\r\n     * @param y defines y coordinate to test\r\n     * @returns true if the coordinates are inside the control\r\n     */\r\n    public contains(x: number, y: number): boolean {\r\n        // Invert transform\r\n        this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);\r\n\r\n        x = this._transformedPosition.x;\r\n        y = this._transformedPosition.y;\r\n\r\n        // Check\r\n        if (x < this._currentMeasure.left) {\r\n            return false;\r\n        }\r\n\r\n        if (x > this._currentMeasure.left + this._currentMeasure.width) {\r\n            return false;\r\n        }\r\n\r\n        if (y < this._currentMeasure.top) {\r\n            return false;\r\n        }\r\n\r\n        if (y > this._currentMeasure.top + this._currentMeasure.height) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isPointerBlocker) {\r\n            this._host._shouldBlockPointer = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _processPicking(x: number, y: number, pi: Nullable<PointerInfoBase>, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): boolean {\r\n        if (!this._isEnabled) {\r\n            return false;\r\n        }\r\n        if (!this.isHitTestVisible || !this.isVisible || this._doNotRender) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.contains(x, y)) {\r\n            return false;\r\n        }\r\n\r\n        this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: Nullable<PointerInfoBase>): void {\r\n        const canNotify: boolean = this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this, pi);\r\n\r\n        if (canNotify && this.parent != null && !this.isPointerBlocker) {\r\n            this.parent._onPointerMove(target, coordinates, pointerId, pi);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerEnter(target: Control, pi: Nullable<PointerInfoBase>): boolean {\r\n        if (!this._isEnabled) {\r\n            return false;\r\n        }\r\n        if (this._enterCount > 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this._enterCount === -1) {\r\n            // -1 is for touch input, we are now sure we are with a mouse or pencil\r\n            this._enterCount = 0;\r\n        }\r\n        this._enterCount++;\r\n\r\n        const canNotify: boolean = this.onPointerEnterObservable.notifyObservers(this, -1, target, this, pi);\r\n\r\n        if (canNotify && this.parent != null && !this.isPointerBlocker) {\r\n            this.parent._onPointerEnter(target, pi);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerOut(target: Control, pi: Nullable<PointerInfoBase>, force = false): void {\r\n        if (!force && !this._isEnabled) {\r\n            return;\r\n        }\r\n        this._enterCount = 0;\r\n\r\n        let canNotify: boolean = true;\r\n\r\n        if (!target.isAscendant(this)) {\r\n            canNotify = this.onPointerOutObservable.notifyObservers(this, -1, target, this, pi);\r\n        }\r\n\r\n        if (canNotify && this.parent != null && !this.isPointerBlocker) {\r\n            this.parent._onPointerOut(target, pi, force);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: Nullable<PointerInfoBase>): boolean {\r\n        // Prevent pointerout to lose control context.\r\n        // Event redundancy is checked inside the function.\r\n        this._onPointerEnter(this, pi);\r\n\r\n        if (this.tabIndex !== -1) {\r\n            this.host.focusedControl = this;\r\n        }\r\n\r\n        if (this._downCount !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._downCount++;\r\n\r\n        this._downPointerIds[pointerId] = true;\r\n\r\n        const canNotify: boolean = this.onPointerDownObservable.notifyObservers(new Vector2WithInfo(coordinates, buttonIndex), -1, target, this, pi);\r\n\r\n        if (canNotify && this.parent != null && !this.isPointerBlocker) {\r\n            this.parent._onPointerDown(target, coordinates, pointerId, buttonIndex, pi);\r\n        }\r\n\r\n        if (pi && this.uniqueId !== this._host.rootContainer.uniqueId) {\r\n            this._host._capturedPointerIds.add((pi.event as IPointerEvent).pointerId);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean, pi?: Nullable<PointerInfoBase>): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n        this._downCount = 0;\r\n\r\n        delete this._downPointerIds[pointerId];\r\n\r\n        let canNotifyClick: boolean = notifyClick;\r\n        if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {\r\n            if (!this._host.usePointerTapForClickEvent) {\r\n                canNotifyClick = this.onPointerClickObservable.notifyObservers(new Vector2WithInfo(coordinates, buttonIndex), -1, target, this, pi);\r\n            }\r\n        }\r\n        const canNotify: boolean = this.onPointerUpObservable.notifyObservers(new Vector2WithInfo(coordinates, buttonIndex), -1, target, this, pi);\r\n\r\n        if (canNotify && this.parent != null && !this.isPointerBlocker) {\r\n            this.parent._onPointerUp(target, coordinates, pointerId, buttonIndex, canNotifyClick, pi);\r\n        }\r\n\r\n        if (pi && this.uniqueId !== this._host.rootContainer.uniqueId) {\r\n            this._host._capturedPointerIds.delete((pi.event as IPointerEvent).pointerId);\r\n        }\r\n\r\n        if (this._host.usePointerTapForClickEvent && this.isPointerBlocker) {\r\n            this._host._shouldBlockPointer = false;\r\n        }\r\n    }\r\n\r\n    public _onPointerPick(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean, pi: Nullable<PointerInfoBase>): boolean {\r\n        if (!this._host.usePointerTapForClickEvent) {\r\n            return false;\r\n        }\r\n\r\n        let canNotifyClick: boolean = notifyClick;\r\n        if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {\r\n            canNotifyClick = this.onPointerClickObservable.notifyObservers(new Vector2WithInfo(coordinates, buttonIndex), -1, target, this, pi);\r\n        }\r\n        const canNotify: boolean = this.onPointerUpObservable.notifyObservers(new Vector2WithInfo(coordinates, buttonIndex), -1, target, this, pi);\r\n\r\n        if (canNotify && this.parent != null && !this.isPointerBlocker) {\r\n            this.parent._onPointerPick(target, coordinates, pointerId, buttonIndex, canNotifyClick, pi);\r\n        }\r\n\r\n        if (this._host.usePointerTapForClickEvent && this.isPointerBlocker) {\r\n            this._host._shouldBlockPointer = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _forcePointerUp(pointerId: Nullable<number> = null) {\r\n        if (pointerId !== null) {\r\n            this._onPointerUp(this, Vector2.Zero(), pointerId, 0, true);\r\n        } else {\r\n            for (const key in this._downPointerIds) {\r\n                this._onPointerUp(this, Vector2.Zero(), +key as number, 0, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onWheelScroll(deltaX?: number, deltaY?: number): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n        const canNotify: boolean = this.onWheelObservable.notifyObservers(new Vector2(deltaX, deltaY));\r\n\r\n        if (canNotify && this.parent != null) {\r\n            this.parent._onWheelScroll(deltaX, deltaY);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _onCanvasBlur(): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _processObservables(\r\n        type: number,\r\n        x: number,\r\n        y: number,\r\n        pi: Nullable<PointerInfoBase>,\r\n        pointerId: number,\r\n        buttonIndex: number,\r\n        deltaX?: number,\r\n        deltaY?: number\r\n    ): boolean {\r\n        if (!this._isEnabled) {\r\n            return false;\r\n        }\r\n        this._dummyVector2.copyFromFloats(x, y);\r\n        if (type === PointerEventTypes.POINTERMOVE) {\r\n            this._onPointerMove(this, this._dummyVector2, pointerId, pi);\r\n\r\n            const previousControlOver = this._host._lastControlOver[pointerId];\r\n            if (previousControlOver && previousControlOver !== this) {\r\n                previousControlOver._onPointerOut(this, pi);\r\n            }\r\n\r\n            if (previousControlOver !== this) {\r\n                this._onPointerEnter(this, pi);\r\n            }\r\n\r\n            this._host._lastControlOver[pointerId] = this;\r\n            return true;\r\n        } else if (type === PointerEventTypes.POINTERDOWN) {\r\n            this._onPointerDown(this, this._dummyVector2, pointerId, buttonIndex, pi);\r\n            this._host._registerLastControlDown(this, pointerId);\r\n            this._host._lastPickedControl = this;\r\n            return true;\r\n        } else if (type === PointerEventTypes.POINTERUP) {\r\n            if (this._host._lastControlDown[pointerId]) {\r\n                this._host._lastControlDown[pointerId]._onPointerUp(this, this._dummyVector2, pointerId, buttonIndex, true, pi);\r\n            }\r\n            if (!this._host.usePointerTapForClickEvent) {\r\n                delete this._host._lastControlDown[pointerId];\r\n            }\r\n            return true;\r\n        } else if (type === PointerEventTypes.POINTERWHEEL) {\r\n            if (this._host._lastControlOver[pointerId]) {\r\n                this._host._lastControlOver[pointerId]._onWheelScroll(deltaX, deltaY);\r\n                return true;\r\n            }\r\n        } else if (type === PointerEventTypes.POINTERTAP) {\r\n            if (this._host._lastControlDown[pointerId]) {\r\n                this._host._lastControlDown[pointerId]._onPointerPick(this, this._dummyVector2, pointerId, buttonIndex, true, pi);\r\n            }\r\n            delete this._host._lastControlDown[pointerId];\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _getStyleProperty(propName: \"fontStyle\" | \"fontWeight\" | \"fontFamily\", defaultValue: string): string {\r\n        const prop = (this._style && this._style[propName]) ?? this[propName];\r\n        if (!prop && this.parent) {\r\n            return this.parent._getStyleProperty(propName, defaultValue);\r\n        } else if (!this.parent) {\r\n            return defaultValue;\r\n        } else {\r\n            return prop;\r\n        }\r\n    }\r\n\r\n    private _prepareFont() {\r\n        if (!this._font && !this._fontSet) {\r\n            return;\r\n        }\r\n\r\n        this._font =\r\n            this._getStyleProperty(\"fontStyle\", \"\") +\r\n            \" \" +\r\n            this._getStyleProperty(\"fontWeight\", \"\") +\r\n            \" \" +\r\n            this.fontSizeInPixels +\r\n            \"px \" +\r\n            this._getStyleProperty(\"fontFamily\", \"Arial\");\r\n\r\n        this._fontOffset = Control._GetFontOffset(this._font, this._host?.getScene()?.getEngine());\r\n\r\n        //children need to be refreshed\r\n        this.getDescendants().forEach((child) => child._markAllAsDirty());\r\n    }\r\n\r\n    /**\r\n     * A control has a dimension fully defined if that dimension doesn't depend on the parent's dimension.\r\n     * As an example, a control that has dimensions in pixels is fully defined, while in percentage is not fully defined.\r\n     * @param dim the dimension to check (width or height)\r\n     * @returns if the dimension is fully defined\r\n     */\r\n    public isDimensionFullyDefined(dim: \"width\" | \"height\"): boolean {\r\n        return this.getDimension(dim).isPixel;\r\n    }\r\n\r\n    /**\r\n     * Gets the dimension of the control along a specified axis\r\n     * @param dim the dimension to retrieve (width or height)\r\n     * @returns the dimension value along the specified axis\r\n     */\r\n    public getDimension(dim: \"width\" | \"height\"): ValueAndUnit {\r\n        if (dim === \"width\") {\r\n            return this._width;\r\n        } else {\r\n            return this._height;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones a control and its descendants\r\n     * @param host the texture where the control will be instantiated. Can be empty, in which case the control will be created on the same texture\r\n     * @returns the cloned control\r\n     */\r\n    public clone(host?: AdvancedDynamicTexture): Control {\r\n        const serialization: any = {};\r\n        this.serialize(serialization, true);\r\n        const controlType = Tools.Instantiate(\"BABYLON.GUI.\" + serialization.className);\r\n        const cloned = new controlType();\r\n        cloned.parse(serialization, host);\r\n\r\n        return cloned;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized object into this control\r\n     * @param serializedObject the object with the serialized properties\r\n     * @param host the texture where the control will be instantiated. Can be empty, in which case the control will be created on the same texture\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns this control\r\n     */\r\n    public parse(serializedObject: any, host?: AdvancedDynamicTexture, urlRewriter?: (url: string) => string): Control {\r\n        this._urlRewriter = urlRewriter;\r\n        SerializationHelper.Parse(() => this, serializedObject, null);\r\n\r\n        this.name = serializedObject.name;\r\n\r\n        this._parseFromContent(serializedObject, host ?? this._host);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current control\r\n     * @param serializationObject defined the JSON serialized object\r\n     * @param force if the control should be serialized even if the isSerializable flag is set to false (default false)\r\n     * @param allowCanvas defines if the control is allowed to use a Canvas2D object to serialize (true by default)\r\n     */\r\n    public serialize(serializationObject: any, force: boolean = false, allowCanvas: boolean = true) {\r\n        if (!this.isSerializable && !force) {\r\n            return;\r\n        }\r\n        let idealWidth = 0;\r\n        let idealHeight = 0;\r\n        // the host's ideal width and height are influencing the serialization, as they are used in getValue() of ValueAndUnit.\r\n        // for a proper serialization, we need to temporarily set them to 0 and re-set them back afterwards.\r\n        if (this.host) {\r\n            idealHeight = this.host.idealHeight;\r\n            idealWidth = this.host.idealWidth;\r\n            this.host.idealWidth = 0;\r\n            this.host.idealHeight = 0;\r\n        }\r\n        SerializationHelper.Serialize(this, serializationObject);\r\n        serializationObject.name = this.name;\r\n        serializationObject.className = this.getClassName();\r\n\r\n        // Call prepareFont to guarantee the font is properly set before serializing\r\n        if (allowCanvas) {\r\n            this._prepareFont();\r\n        }\r\n        if (this._fontFamily) {\r\n            serializationObject.fontFamily = this._fontFamily;\r\n        }\r\n        if (this.fontSize) {\r\n            serializationObject.fontSize = this.fontSize;\r\n        }\r\n        if (this.fontWeight) {\r\n            serializationObject.fontWeight = this.fontWeight;\r\n        }\r\n        if (this.fontStyle) {\r\n            serializationObject.fontStyle = this.fontStyle;\r\n        }\r\n\r\n        if (this._gradient) {\r\n            serializationObject.gradient = {};\r\n            this._gradient.serialize(serializationObject.gradient);\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        // re-set the ideal width and height\r\n        if (this.host) {\r\n            this.host.idealWidth = idealWidth;\r\n            this.host.idealHeight = idealHeight;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture, urlRewriter?: (url: string) => string) {\r\n        if (serializedObject.fontFamily) {\r\n            this.fontFamily = serializedObject.fontFamily;\r\n        }\r\n\r\n        if (serializedObject.fontSize) {\r\n            this.fontSize = serializedObject.fontSize;\r\n        }\r\n\r\n        if (serializedObject.fontWeight) {\r\n            this.fontWeight = serializedObject.fontWeight;\r\n        }\r\n\r\n        if (serializedObject.fontStyle) {\r\n            this.fontStyle = serializedObject.fontStyle;\r\n        }\r\n\r\n        // Gradient\r\n        if (serializedObject.gradient) {\r\n            const className = Tools.Instantiate(\"BABYLON.GUI.\" + serializedObject.gradient.className);\r\n            this._gradient = new className();\r\n            this._gradient?.parse(serializedObject.gradient);\r\n        }\r\n\r\n        // Animations\r\n        if (serializedObject.animations) {\r\n            this.animations = [];\r\n            for (let animationIndex = 0; animationIndex < serializedObject.animations.length; animationIndex++) {\r\n                const parsedAnimation = serializedObject.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    this.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n\r\n            if (serializedObject.autoAnimate && this._host && this._host.getScene()) {\r\n                this._host\r\n                    .getScene()!\r\n                    .beginAnimation(\r\n                        this,\r\n                        serializedObject.autoAnimateFrom,\r\n                        serializedObject.autoAnimateTo,\r\n                        serializedObject.autoAnimateLoop,\r\n                        serializedObject.autoAnimateSpeed || 1.0\r\n                    );\r\n            }\r\n        }\r\n\r\n        this.fixedRatioMasterIsWidth = serializedObject.fixedRatioMasterIsWidth ?? this.fixedRatioMasterIsWidth;\r\n    }\r\n\r\n    /** Releases associated resources */\r\n    public dispose() {\r\n        this.onDirtyObservable.clear();\r\n        this.onBeforeDrawObservable.clear();\r\n        this.onAfterDrawObservable.clear();\r\n        this.onPointerDownObservable.clear();\r\n        this.onPointerEnterObservable.clear();\r\n        this.onPointerMoveObservable.clear();\r\n        this.onPointerOutObservable.clear();\r\n        this.onPointerUpObservable.clear();\r\n        this.onPointerClickObservable.clear();\r\n        this.onWheelObservable.clear();\r\n\r\n        // focus\r\n        this.onBlurObservable.clear();\r\n        this.onFocusObservable.clear();\r\n        this.onKeyboardEventProcessedObservable.clear();\r\n\r\n        if (this._styleObserver && this._style) {\r\n            this._style.onChangedObservable.remove(this._styleObserver);\r\n            this._styleObserver = null;\r\n        }\r\n\r\n        if (this.parent) {\r\n            this.parent.removeControl(this);\r\n            this.parent = null;\r\n        }\r\n\r\n        if (this._host) {\r\n            const index = this._host._linkedControls.indexOf(this);\r\n            if (index > -1) {\r\n                this.linkWithMesh(null);\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    // Statics\r\n    private static _HORIZONTAL_ALIGNMENT_LEFT = 0;\r\n    private static _HORIZONTAL_ALIGNMENT_RIGHT = 1;\r\n    private static _HORIZONTAL_ALIGNMENT_CENTER = 2;\r\n\r\n    private static _VERTICAL_ALIGNMENT_TOP = 0;\r\n    private static _VERTICAL_ALIGNMENT_BOTTOM = 1;\r\n    private static _VERTICAL_ALIGNMENT_CENTER = 2;\r\n\r\n    /** HORIZONTAL_ALIGNMENT_LEFT */\r\n    public static get HORIZONTAL_ALIGNMENT_LEFT(): number {\r\n        return Control._HORIZONTAL_ALIGNMENT_LEFT;\r\n    }\r\n\r\n    /** HORIZONTAL_ALIGNMENT_RIGHT */\r\n    public static get HORIZONTAL_ALIGNMENT_RIGHT(): number {\r\n        return Control._HORIZONTAL_ALIGNMENT_RIGHT;\r\n    }\r\n\r\n    /** HORIZONTAL_ALIGNMENT_CENTER */\r\n    public static get HORIZONTAL_ALIGNMENT_CENTER(): number {\r\n        return Control._HORIZONTAL_ALIGNMENT_CENTER;\r\n    }\r\n\r\n    /** VERTICAL_ALIGNMENT_TOP */\r\n    public static get VERTICAL_ALIGNMENT_TOP(): number {\r\n        return Control._VERTICAL_ALIGNMENT_TOP;\r\n    }\r\n\r\n    /** VERTICAL_ALIGNMENT_BOTTOM */\r\n    public static get VERTICAL_ALIGNMENT_BOTTOM(): number {\r\n        return Control._VERTICAL_ALIGNMENT_BOTTOM;\r\n    }\r\n\r\n    /** VERTICAL_ALIGNMENT_CENTER */\r\n    public static get VERTICAL_ALIGNMENT_CENTER(): number {\r\n        return Control._VERTICAL_ALIGNMENT_CENTER;\r\n    }\r\n\r\n    private static _FontHeightSizes: { [key: string]: { ascent: number; height: number; descent: number } } = {};\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetFontOffset(font: string, engineToUse?: AbstractEngine): { ascent: number; height: number; descent: number } {\r\n        if (Control._FontHeightSizes[font]) {\r\n            return Control._FontHeightSizes[font];\r\n        }\r\n\r\n        const engine = engineToUse || EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n        }\r\n\r\n        const result = engine.getFontOffset(font);\r\n        Control._FontHeightSizes[font] = result;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a Control from parsed data\r\n     * @param serializedObject defines parsed data\r\n     * @param host defines the hosting AdvancedDynamicTexture\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a new Control\r\n     */\r\n    public static Parse(serializedObject: any, host: AdvancedDynamicTexture, urlRewriter?: (url: string) => string): Control {\r\n        const controlType = Tools.Instantiate(\"BABYLON.GUI.\" + serializedObject.className);\r\n        const control = SerializationHelper.Parse(\r\n            () => {\r\n                const newControl = new controlType() as Control;\r\n                newControl._urlRewriter = urlRewriter;\r\n                return newControl;\r\n            },\r\n            serializedObject,\r\n            null\r\n        );\r\n\r\n        control.name = serializedObject.name;\r\n\r\n        control._parseFromContent(serializedObject, host, urlRewriter);\r\n\r\n        return control;\r\n    }\r\n\r\n    public static AddHeader: (control: Control, text: string, size: string | number, options: { isHorizontal: boolean; controlFirst: boolean }) => any = () => {};\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected static drawEllipse(x: number, y: number, width: number, height: number, arc: number, context: ICanvasRenderingContext): void {\r\n        context.translate(x, y);\r\n        context.scale(width, height);\r\n\r\n        context.beginPath();\r\n        context.arc(0, 0, 1, 0, 2 * Math.PI * arc, arc < 0);\r\n\r\n        if (arc >= 1) {\r\n            context.closePath();\r\n        }\r\n\r\n        context.scale(1 / width, 1 / height);\r\n        context.translate(-x, -y);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the control is ready to be used\r\n     * @returns\r\n     */\r\n    public isReady(): boolean {\r\n        // Most controls are ready by default, so the default implementation is to return true\r\n        return true;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Control\", Control);\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { Measure } from \"../measure\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { BaseGradient } from \"./gradient/BaseGradient\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Matrix2D } from \"../math2D\";\r\n\r\n/**\r\n * Root class for 2D containers\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#containers\r\n */\r\nexport class Container extends Control {\r\n    /** @internal */\r\n    public _children = new Array<Control>();\r\n    /** @internal */\r\n    protected _measureForChildren = Measure.Empty();\r\n    /** @internal */\r\n    protected _background = \"\";\r\n    /** @internal */\r\n    protected _backgroundGradient: Nullable<BaseGradient> = null;\r\n    /** @internal */\r\n    protected _adaptWidthToChildren = false;\r\n    /** @internal */\r\n    protected _adaptHeightToChildren = false;\r\n    /** @internal */\r\n    protected _renderToIntermediateTexture: boolean = false;\r\n    /** @internal */\r\n    protected _intermediateTexture: Nullable<DynamicTexture> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the container will let internal controls handle picking instead of doing it directly using its bounding info\r\n     */\r\n    @serialize()\r\n    public delegatePickingToChildren = false;\r\n\r\n    /** Gets or sets boolean indicating if children should be rendered to an intermediate texture rather than directly to host, useful for alpha blending */\r\n    @serialize()\r\n    public get renderToIntermediateTexture(): boolean {\r\n        return this._renderToIntermediateTexture;\r\n    }\r\n    public set renderToIntermediateTexture(value: boolean) {\r\n        if (this._renderToIntermediateTexture === value) {\r\n            return;\r\n        }\r\n        this._renderToIntermediateTexture = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that layout cycle errors should be displayed on the console\r\n     */\r\n    public logLayoutCycleErrors = false;\r\n\r\n    /**\r\n     * Gets or sets the number of layout cycles (a change involved by a control while evaluating the layout) allowed\r\n     */\r\n    @serialize()\r\n    public maxLayoutCycle = 3;\r\n\r\n    /** Gets or sets a boolean indicating if the container should try to adapt to its children height */\r\n    @serialize()\r\n    public get adaptHeightToChildren(): boolean {\r\n        return this._adaptHeightToChildren;\r\n    }\r\n\r\n    public set adaptHeightToChildren(value: boolean) {\r\n        if (this._adaptHeightToChildren === value) {\r\n            return;\r\n        }\r\n\r\n        this._adaptHeightToChildren = value;\r\n\r\n        if (value) {\r\n            this.height = \"100%\";\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the container should try to adapt to its children width */\r\n    @serialize()\r\n    public get adaptWidthToChildren(): boolean {\r\n        return this._adaptWidthToChildren;\r\n    }\r\n\r\n    public set adaptWidthToChildren(value: boolean) {\r\n        if (this._adaptWidthToChildren === value) {\r\n            return;\r\n        }\r\n\r\n        this._adaptWidthToChildren = value;\r\n\r\n        if (value) {\r\n            this.width = \"100%\";\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background gradient color. Takes precedence over background */\r\n    @serialize()\r\n    public get backgroundGradient() {\r\n        return this._backgroundGradient;\r\n    }\r\n\r\n    public set backgroundGradient(value: Nullable<BaseGradient>) {\r\n        if (this._backgroundGradient === value) {\r\n            return;\r\n        }\r\n        this._backgroundGradient = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets the list of children */\r\n    public get children(): Control[] {\r\n        return this._children;\r\n    }\r\n\r\n    public override get isReadOnly() {\r\n        return this._isReadOnly;\r\n    }\r\n\r\n    public override set isReadOnly(value: boolean) {\r\n        this._isReadOnly = value;\r\n\r\n        for (const child of this._children) {\r\n            child.isReadOnly = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new Container\r\n     * @param name defines the name of the container\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Container\";\r\n    }\r\n\r\n    public override _flagDescendantsAsMatrixDirty(): void {\r\n        for (const child of this.children) {\r\n            child._isClipped = false;\r\n            child._markMatrixAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a child using its name\r\n     * @param name defines the child name to look for\r\n     * @returns the child control if found\r\n     */\r\n    public getChildByName(name: string): Nullable<Control> {\r\n        for (const child of this.children) {\r\n            if (child.name === name) {\r\n                return child;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a child using its type and its name\r\n     * @param name defines the child name to look for\r\n     * @param type defines the child type to look for\r\n     * @returns the child control if found\r\n     */\r\n    public getChildByType(name: string, type: string): Nullable<Control> {\r\n        for (const child of this.children) {\r\n            if (child.typeName === type) {\r\n                return child;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Search for a specific control in children\r\n     * @param control defines the control to look for\r\n     * @returns true if the control is in child list\r\n     */\r\n    public containsControl(control: Control): boolean {\r\n        return this.children.indexOf(control) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Adds a new control to the current container\r\n     * @param control defines the control to add\r\n     * @returns the current container\r\n     */\r\n    public addControl(control: Nullable<Control>): Container {\r\n        if (!control) {\r\n            return this;\r\n        }\r\n\r\n        const index = this._children.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            return this;\r\n        }\r\n        control._link(this._host);\r\n\r\n        control._markAllAsDirty();\r\n\r\n        this._reOrderControl(control);\r\n\r\n        this._markAsDirty();\r\n\r\n        this.onControlAddedObservable.notifyObservers(control);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes all controls from the current container\r\n     * @returns the current container\r\n     */\r\n    public clearControls(): Container {\r\n        const children = this.children.slice();\r\n\r\n        for (const child of children) {\r\n            this.removeControl(child);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a control from the current container\r\n     * @param control defines the control to remove\r\n     * @returns the current container\r\n     */\r\n    public removeControl(control: Control): Container {\r\n        const index = this._children.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            this._children.splice(index, 1);\r\n\r\n            control.parent = null;\r\n        }\r\n\r\n        control.linkWithMesh(null);\r\n\r\n        if (this._host) {\r\n            this._host._cleanControlAfterRemoval(control);\r\n        }\r\n\r\n        this._markAsDirty();\r\n\r\n        this.onControlRemovedObservable.notifyObservers(control);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when any control is added to this container.\r\n     */\r\n    public onControlAddedObservable = new Observable<Nullable<Control>>();\r\n\r\n    /**\r\n     * An event triggered when any control is removed from this container.\r\n     */\r\n    public onControlRemovedObservable = new Observable<Nullable<Control>>();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _reOrderControl(control: Control): void {\r\n        const linkedMesh = control.linkedMesh;\r\n\r\n        this.removeControl(control);\r\n\r\n        let wasAdded = false;\r\n        for (let index = 0; index < this._children.length; index++) {\r\n            if (this._children[index].zIndex > control.zIndex) {\r\n                this._children.splice(index, 0, control);\r\n                wasAdded = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!wasAdded) {\r\n            this._children.push(control);\r\n        }\r\n\r\n        control.parent = this;\r\n\r\n        if (linkedMesh) {\r\n            control.linkWithMesh(linkedMesh);\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _offsetLeft(offset: number) {\r\n        super._offsetLeft(offset);\r\n\r\n        for (const child of this._children) {\r\n            child._offsetLeft(offset);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _offsetTop(offset: number) {\r\n        super._offsetTop(offset);\r\n\r\n        for (const child of this._children) {\r\n            child._offsetTop(offset);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _markAllAsDirty(): void {\r\n        super._markAllAsDirty();\r\n\r\n        for (let index = 0; index < this._children.length; index++) {\r\n            this._children[index]._markAllAsDirty();\r\n        }\r\n    }\r\n\r\n    protected _getBackgroundColor(context: ICanvasRenderingContext) {\r\n        return this._backgroundGradient ? this._backgroundGradient.getCanvasGradient(context) : this._background;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _localDraw(context: ICanvasRenderingContext): void {\r\n        if (this._background || this._backgroundGradient) {\r\n            context.save();\r\n            if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n                context.shadowColor = this.shadowColor;\r\n                context.shadowBlur = this.shadowBlur;\r\n                context.shadowOffsetX = this.shadowOffsetX;\r\n                context.shadowOffsetY = this.shadowOffsetY;\r\n            }\r\n\r\n            context.fillStyle = this._getBackgroundColor(context);\r\n\r\n            context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            context.restore();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _link(host: AdvancedDynamicTexture): void {\r\n        super._link(host);\r\n\r\n        for (const child of this._children) {\r\n            child._link(host);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    protected _beforeLayout() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _processMeasures(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        if (this._isDirty || !this._cachedParentMeasure.isEqualsTo(parentMeasure)) {\r\n            super._processMeasures(parentMeasure, context);\r\n            this._evaluateClippingState(parentMeasure);\r\n            if (this._renderToIntermediateTexture) {\r\n                if (this._intermediateTexture && this._host.getScene() != this._intermediateTexture.getScene()) {\r\n                    this._intermediateTexture.dispose();\r\n                    this._intermediateTexture = null;\r\n                }\r\n                if (!this._intermediateTexture) {\r\n                    this._intermediateTexture = new DynamicTexture(\r\n                        \"\",\r\n                        { width: this._currentMeasure.width, height: this._currentMeasure.height },\r\n                        this._host.getScene(),\r\n                        false,\r\n                        Texture.NEAREST_SAMPLINGMODE,\r\n                        Constants.TEXTUREFORMAT_RGBA,\r\n                        false\r\n                    );\r\n                    this._intermediateTexture.hasAlpha = true;\r\n                } else {\r\n                    this._intermediateTexture.scaleTo(this._currentMeasure.width, this._currentMeasure.height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _layout(parentMeasure: Measure, context: ICanvasRenderingContext): boolean {\r\n        if (!this.isDirty && (!this.isVisible || this.notRenderable)) {\r\n            return false;\r\n        }\r\n\r\n        this.host._numLayoutCalls++;\r\n\r\n        if (this._isDirty) {\r\n            this._currentMeasure.transformToRef(this._transformMatrix, this._prevCurrentMeasureTransformedIntoGlobalSpace);\r\n        }\r\n\r\n        let rebuildCount = 0;\r\n\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        this._beforeLayout();\r\n\r\n        do {\r\n            let computedWidth = -1;\r\n            let computedHeight = -1;\r\n            this._rebuildLayout = false;\r\n            this._processMeasures(parentMeasure, context);\r\n\r\n            if (!this._isClipped) {\r\n                for (const child of this._children) {\r\n                    child._tempParentMeasure.copyFrom(this._measureForChildren);\r\n\r\n                    if (child._layout(this._measureForChildren, context)) {\r\n                        if (child.isVisible && !child.notRenderable) {\r\n                            if (this.adaptWidthToChildren && child._width.isPixel) {\r\n                                computedWidth = Math.max(computedWidth, child._currentMeasure.width + child._paddingLeftInPixels + child._paddingRightInPixels);\r\n                            }\r\n                            if (this.adaptHeightToChildren && child._height.isPixel) {\r\n                                computedHeight = Math.max(computedHeight, child._currentMeasure.height + child._paddingTopInPixels + child._paddingBottomInPixels);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.adaptWidthToChildren && computedWidth >= 0) {\r\n                    computedWidth += this.paddingLeftInPixels + this.paddingRightInPixels;\r\n                    const width = computedWidth + \"px\";\r\n                    if (this.width !== width) {\r\n                        this.parent?._markAsDirty();\r\n                        this.width = width;\r\n                        this._width.ignoreAdaptiveScaling = true;\r\n                        this._rebuildLayout = true;\r\n                    }\r\n                }\r\n                if (this.adaptHeightToChildren && computedHeight >= 0) {\r\n                    computedHeight += this.paddingTopInPixels + this.paddingBottomInPixels;\r\n                    const height = computedHeight + \"px\";\r\n                    if (this.height !== height) {\r\n                        this.parent?._markAsDirty();\r\n                        this.height = height;\r\n                        this._height.ignoreAdaptiveScaling = true;\r\n                        this._rebuildLayout = true;\r\n                    }\r\n                }\r\n\r\n                this._postMeasure();\r\n            }\r\n            rebuildCount++;\r\n        } while (this._rebuildLayout && rebuildCount < this.maxLayoutCycle);\r\n\r\n        if (rebuildCount >= 3 && this.logLayoutCycleErrors) {\r\n            Logger.Error(`Layout cycle detected in GUI (Container name=${this.name}, uniqueId=${this.uniqueId})`);\r\n        }\r\n\r\n        context.restore();\r\n\r\n        if (this._isDirty) {\r\n            this.invalidateRect();\r\n\r\n            this._isDirty = false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    protected override _postMeasure() {\r\n        // Do nothing by default\r\n    }\r\n\r\n    private _inverseTransformMatrix = Matrix2D.Identity();\r\n    private _inverseMeasure = new Measure(0, 0, 0, 0);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(context: ICanvasRenderingContext, invalidatedRectangle?: Measure): void {\r\n        const renderToIntermediateTextureThisDraw = this._renderToIntermediateTexture && this._intermediateTexture;\r\n        const contextToDrawTo = renderToIntermediateTextureThisDraw ? (<DynamicTexture>this._intermediateTexture).getContext() : context;\r\n\r\n        if (renderToIntermediateTextureThisDraw) {\r\n            contextToDrawTo.save();\r\n            contextToDrawTo.translate(-this._currentMeasure.left, -this._currentMeasure.top);\r\n            if (invalidatedRectangle) {\r\n                this._transformMatrix.invertToRef(this._inverseTransformMatrix);\r\n                invalidatedRectangle.transformToRef(this._inverseTransformMatrix, this._inverseMeasure);\r\n                contextToDrawTo.clearRect(this._inverseMeasure.left, this._inverseMeasure.top, this._inverseMeasure.width, this._inverseMeasure.height);\r\n            } else {\r\n                contextToDrawTo.clearRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            }\r\n        }\r\n\r\n        this._localDraw(contextToDrawTo);\r\n\r\n        context.save();\r\n\r\n        if (this.clipChildren) {\r\n            this._clipForChildren(contextToDrawTo);\r\n        }\r\n\r\n        for (const child of this._children) {\r\n            // Only redraw parts of the screen that are invalidated\r\n            if (invalidatedRectangle) {\r\n                if (!child._intersectsRect(invalidatedRectangle)) {\r\n                    continue;\r\n                }\r\n            }\r\n            child._render(contextToDrawTo, invalidatedRectangle);\r\n        }\r\n\r\n        if (renderToIntermediateTextureThisDraw) {\r\n            contextToDrawTo.restore();\r\n            context.save();\r\n            context.globalAlpha = this.alpha;\r\n            context.drawImage(contextToDrawTo.canvas, this._currentMeasure.left, this._currentMeasure.top);\r\n            context.restore();\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    public override getDescendantsToRef(results: Control[], directDescendantsOnly: boolean = false, predicate?: (control: Control) => boolean): void {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            const item = this.children[index];\r\n\r\n            if (!predicate || predicate(item)) {\r\n                results.push(item);\r\n            }\r\n\r\n            if (!directDescendantsOnly) {\r\n                item.getDescendantsToRef(results, false, predicate);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _processPicking(\r\n        x: number,\r\n        y: number,\r\n        pi: Nullable<PointerInfoBase>,\r\n        type: number,\r\n        pointerId: number,\r\n        buttonIndex: number,\r\n        deltaX?: number,\r\n        deltaY?: number\r\n    ): boolean {\r\n        if (!this._isEnabled || !this.isVisible || this.notRenderable) {\r\n            return false;\r\n        }\r\n\r\n        // checks if the picking position is within the container\r\n        const contains = super.contains(x, y);\r\n\r\n        // if clipChildren is off, we should still pass picking events to children even if we don't contain the pointer\r\n        if (!contains && this.clipChildren) {\r\n            return false;\r\n        }\r\n\r\n        if (this.delegatePickingToChildren) {\r\n            let contains = false;\r\n            for (let index = this._children.length - 1; index >= 0; index--) {\r\n                const child = this._children[index];\r\n                if (child.isEnabled && child.isHitTestVisible && child.isVisible && !child.notRenderable && child.contains(x, y)) {\r\n                    contains = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!contains) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Checking backwards to pick closest first\r\n        for (let index = this._children.length - 1; index >= 0; index--) {\r\n            const child = this._children[index];\r\n            if (child._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\r\n                if (child.hoverCursor) {\r\n                    this._host._changeCursor(child.hoverCursor);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!contains) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.isHitTestVisible) {\r\n            return false;\r\n        }\r\n\r\n        return this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._additionalProcessing(parentMeasure, context);\r\n\r\n        this._measureForChildren.copyFrom(this._currentMeasure);\r\n    }\r\n\r\n    protected _getAdaptDimTo(dim: \"width\" | \"height\"): boolean {\r\n        if (dim === \"width\") {\r\n            return this.adaptWidthToChildren;\r\n        } else {\r\n            return this.adaptHeightToChildren;\r\n        }\r\n    }\r\n\r\n    public override isDimensionFullyDefined(dim: \"width\" | \"height\"): boolean {\r\n        if (this._getAdaptDimTo(dim)) {\r\n            for (const child of this.children) {\r\n                if (!child.isDimensionFullyDefined(dim)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return super.isDimensionFullyDefined(dim);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current control\r\n     * @param serializationObject defined the JSON serialized object\r\n     * @param force force serialization even if isSerializable === false\r\n     * @param allowCanvas defines if the control is allowed to use a Canvas2D object to serialize (true by default)\r\n     */\r\n    public override serialize(serializationObject: any, force: boolean = false, allowCanvas: boolean = true) {\r\n        super.serialize(serializationObject, force, allowCanvas);\r\n        if (!this.isSerializable && !force) {\r\n            return;\r\n        }\r\n\r\n        if (this.backgroundGradient) {\r\n            serializationObject.backgroundGradient = {};\r\n            this.backgroundGradient.serialize(serializationObject.backgroundGradient);\r\n        }\r\n\r\n        if (!this.children.length) {\r\n            return;\r\n        }\r\n\r\n        serializationObject.children = [];\r\n\r\n        for (const child of this.children) {\r\n            if (child.isSerializable || force) {\r\n                const childSerializationObject = {};\r\n                child.serialize(childSerializationObject, force, allowCanvas);\r\n                serializationObject.children.push(childSerializationObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Releases associated resources */\r\n    public override dispose() {\r\n        super.dispose();\r\n\r\n        for (let index = this.children.length - 1; index >= 0; index--) {\r\n            this.children[index].dispose();\r\n        }\r\n        this._intermediateTexture?.dispose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture, urlRewriter?: (url: string) => string) {\r\n        super._parseFromContent(serializedObject, host, urlRewriter);\r\n        this._link(host);\r\n\r\n        // Gradient\r\n        if (serializedObject.backgroundGradient) {\r\n            const className = Tools.Instantiate(\"BABYLON.GUI.\" + serializedObject.backgroundGradient.className);\r\n            this._backgroundGradient = new className();\r\n            this._backgroundGradient?.parse(serializedObject.backgroundGradient);\r\n        }\r\n\r\n        if (!serializedObject.children) {\r\n            return;\r\n        }\r\n\r\n        for (const childData of serializedObject.children) {\r\n            this.addControl(Control.Parse(childData, host, urlRewriter));\r\n        }\r\n    }\r\n\r\n    public override isReady(): boolean {\r\n        for (const child of this.children) {\r\n            if (!child.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Container\", Container);\r\n", "import { Container } from \"./container\";\r\nimport type { Measure } from \"../measure\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/** Class used to create rectangle container */\r\nexport class Rectangle extends Container {\r\n    private _thickness = 1;\r\n    private _cornerRadius = [0, 0, 0, 0];\r\n    private _cachedRadius = [0, 0, 0, 0];\r\n\r\n    /** Gets or sets border thickness */\r\n    @serialize()\r\n    public get thickness(): number {\r\n        return this._thickness;\r\n    }\r\n\r\n    public set thickness(value: number) {\r\n        if (this._thickness === value) {\r\n            return;\r\n        }\r\n\r\n        this._thickness = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the corner radius of all angles */\r\n    @serialize()\r\n    public get cornerRadius(): number {\r\n        return this._cornerRadius[0];\r\n    }\r\n\r\n    public set cornerRadius(value: number) {\r\n        if (value < 0) {\r\n            value = 0;\r\n        }\r\n\r\n        if (this._cornerRadius[0] === value && this._cornerRadius[1] === value && this._cornerRadius[2] === value && this._cornerRadius[3] === value) {\r\n            return;\r\n        }\r\n\r\n        this._cornerRadius[0] = this._cornerRadius[1] = this._cornerRadius[2] = this._cornerRadius[3] = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the corner radius top left angle */\r\n    @serialize()\r\n    public get cornerRadiusX(): number {\r\n        return this._cornerRadius[0];\r\n    }\r\n\r\n    public set cornerRadiusX(value: number) {\r\n        if (this._cornerRadius[0] === value) {\r\n            return;\r\n        }\r\n        this._cornerRadius[0] = value;\r\n    }\r\n\r\n    /** Gets or sets the corner radius top right angle */\r\n    @serialize()\r\n    public get cornerRadiusY(): number {\r\n        return this._cornerRadius[1];\r\n    }\r\n\r\n    public set cornerRadiusY(value: number) {\r\n        if (this._cornerRadius[1] === value) {\r\n            return;\r\n        }\r\n        this._cornerRadius[1] = value;\r\n    }\r\n\r\n    /** Gets or sets the corner radius bottom left angle */\r\n    @serialize()\r\n    public get cornerRadiusZ(): number {\r\n        return this._cornerRadius[2];\r\n    }\r\n\r\n    public set cornerRadiusZ(value: number) {\r\n        if (this._cornerRadius[2] === value) {\r\n            return;\r\n        }\r\n        this._cornerRadius[2] = value;\r\n    }\r\n\r\n    /** Gets or sets the corner radius bottom right angle */\r\n    @serialize()\r\n    public get cornerRadiusW(): number {\r\n        return this._cornerRadius[3];\r\n    }\r\n\r\n    public set cornerRadiusW(value: number) {\r\n        if (this._cornerRadius[3] === value) {\r\n            return;\r\n        }\r\n        this._cornerRadius[3] = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Rectangle\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Rectangle\";\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _computeAdditionalOffsetX() {\r\n        let additionalWidth = 0;\r\n        if (this._cornerRadius[0] !== 0 || this._cornerRadius[1] !== 0 || this._cornerRadius[2] !== 0 || this._cornerRadius[3] !== 0) {\r\n            // Take in account the aliasing\r\n            additionalWidth += 1;\r\n        }\r\n        if (this.thickness) {\r\n            additionalWidth += this.thickness / 2;\r\n        }\r\n        return additionalWidth;\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _computeAdditionalOffsetY() {\r\n        let additionalHeight = 0;\r\n        if (this._cornerRadius[0] !== 0 || this._cornerRadius[1] !== 0 || this._cornerRadius[2] !== 0 || this._cornerRadius[3] !== 0) {\r\n            // Take in account the aliasing\r\n            additionalHeight += 1;\r\n        }\r\n        if (this.thickness) {\r\n            additionalHeight += this.thickness / 2;\r\n        }\r\n        return additionalHeight;\r\n    }\r\n\r\n    protected _getRectangleFill(context: ICanvasRenderingContext) {\r\n        return this._getBackgroundColor(context);\r\n    }\r\n\r\n    protected override _localDraw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        if (this._background || this._backgroundGradient) {\r\n            context.fillStyle = this._getRectangleFill(context);\r\n\r\n            if (this._cornerRadius[0] !== 0 || this._cornerRadius[1] !== 0 || this._cornerRadius[2] !== 0 || this._cornerRadius[3] !== 0) {\r\n                this._drawRoundedRect(context, this._thickness / 2);\r\n                context.fill();\r\n            } else {\r\n                context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            }\r\n        }\r\n\r\n        if (this._thickness) {\r\n            if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n                context.shadowBlur = 0;\r\n                context.shadowOffsetX = 0;\r\n                context.shadowOffsetY = 0;\r\n            }\r\n\r\n            if (this.color || this.gradient) {\r\n                context.strokeStyle = this.gradient ? this.gradient.getCanvasGradient(context) : this.color;\r\n            }\r\n            context.lineWidth = this._thickness;\r\n\r\n            if (this._cornerRadius[0] !== 0 || this._cornerRadius[1] !== 0 || this._cornerRadius[2] !== 0 || this._cornerRadius[3] !== 0) {\r\n                this._drawRoundedRect(context, this._thickness / 2);\r\n                context.stroke();\r\n            } else {\r\n                context.strokeRect(\r\n                    this._currentMeasure.left + this._thickness / 2,\r\n                    this._currentMeasure.top + this._thickness / 2,\r\n                    this._currentMeasure.width - this._thickness,\r\n                    this._currentMeasure.height - this._thickness\r\n                );\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    protected override _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._additionalProcessing(parentMeasure, context);\r\n\r\n        this._measureForChildren.width -= 2 * this._thickness;\r\n        this._measureForChildren.height -= 2 * this._thickness;\r\n        this._measureForChildren.left += this._thickness;\r\n        this._measureForChildren.top += this._thickness;\r\n    }\r\n\r\n    private _drawRoundedRect(context: ICanvasRenderingContext, offset: number = 0): void {\r\n        const x = this._currentMeasure.left + offset;\r\n        const y = this._currentMeasure.top + offset;\r\n        const width = this._currentMeasure.width - offset * 2;\r\n        const height = this._currentMeasure.height - offset * 2;\r\n\r\n        for (let index = 0; index < this._cornerRadius.length; index++) {\r\n            this._cachedRadius[index] = Math.abs(Math.min(height / 2, Math.min(width / 2, this._cornerRadius[index])));\r\n        }\r\n\r\n        context.beginPath();\r\n        context.moveTo(x + this._cachedRadius[0], y);\r\n        context.lineTo(x + width - this._cachedRadius[1], y);\r\n        context.arc(x + width - this._cachedRadius[1], y + this._cachedRadius[1], this._cachedRadius[1], (3 * Math.PI) / 2, Math.PI * 2);\r\n        context.lineTo(x + width, y + height - this._cachedRadius[2]);\r\n        context.arc(x + width - this._cachedRadius[2], y + height - this._cachedRadius[2], this._cachedRadius[2], 0, Math.PI / 2);\r\n        context.lineTo(x + this._cachedRadius[3], y + height);\r\n        context.arc(x + this._cachedRadius[3], y + height - this._cachedRadius[3], this._cachedRadius[3], Math.PI / 2, Math.PI);\r\n        context.lineTo(x, y + this._cachedRadius[0]);\r\n        context.arc(x + this._cachedRadius[0], y + this._cachedRadius[0], this._cachedRadius[0], Math.PI, (3 * Math.PI) / 2);\r\n        context.closePath();\r\n    }\r\n\r\n    protected override _clipForChildren(context: ICanvasRenderingContext) {\r\n        if (this._cornerRadius[0] !== 0 || this._cornerRadius[1] !== 0 || this._cornerRadius[2] !== 0 || this._cornerRadius[3] !== 0) {\r\n            this._drawRoundedRect(context, this._thickness);\r\n            context.clip();\r\n        }\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Rectangle\", Rectangle);\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Measure } from \"../measure\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport { Control } from \"./control\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext, ITextMetrics } from \"core/Engines/ICanvas\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\n/**\r\n * Enum that determines the text-wrapping mode to use.\r\n */\r\nexport const enum TextWrapping {\r\n    /**\r\n     * Clip the text when it's larger than Control.width; this is the default mode.\r\n     */\r\n    Clip = 0,\r\n\r\n    /**\r\n     * Wrap the text word-wise, i.e. try to add line-breaks at word boundary to fit within Control.width.\r\n     */\r\n    WordWrap = 1,\r\n\r\n    /**\r\n     * Ellipsize the text, i.e. shrink with trailing … when text is larger than Control.width.\r\n     */\r\n    Ellipsis = 2,\r\n\r\n    /**\r\n     * Wrap the text word-wise and clip the text when the text's height is larger than the Control.height, and shrink the last line with trailing … .\r\n     */\r\n    WordWrapEllipsis = 3,\r\n\r\n    /**\r\n     * Use HTML to wrap the text. This is the only mode that supports east-asian languages.\r\n     */\r\n    HTML = 4,\r\n}\r\n\r\n/**\r\n * Class used to create text block control\r\n */\r\nexport class TextBlock extends Control {\r\n    private _text = \"\";\r\n    private _textWrapping = TextWrapping.Clip;\r\n    private _textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    private _textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n\r\n    private _lines: any[];\r\n    private _resizeToFit: boolean = false;\r\n    private _lineSpacing: ValueAndUnit = new ValueAndUnit(0);\r\n    private _outlineWidth: number = 0;\r\n    private _outlineColor: string = \"white\";\r\n    private _underline: boolean = false;\r\n    private _lineThrough: boolean = false;\r\n    private _wordDivider: string = \" \";\r\n    private _forceResizeWidth: boolean = false;\r\n    private _applyOutlineToUnderline: boolean = false;\r\n\r\n    /**\r\n     * An event triggered after the text is changed\r\n     */\r\n    public onTextChangedObservable = new Observable<TextBlock>();\r\n\r\n    /**\r\n     * An event triggered after the text was broken up into lines\r\n     */\r\n    public onLinesReadyObservable = new Observable<TextBlock>();\r\n\r\n    /**\r\n     * Function used to split a string into words. By default, a string is split at each space character found\r\n     */\r\n    public wordSplittingFunction: Nullable<(line: string) => string[]>;\r\n\r\n    /**\r\n     * This function will be called when a new HTML element is generated to be used for word wrapping.\r\n     * This is only used when wrapping mode HTML is selected.\r\n     * Using this function you can adjust word-break, overflow-wrap, hyphens, or any other CSS properties of the HTML element, language-dependent.\r\n     */\r\n    public adjustWordWrappingHTMLElement: Nullable<(element: HTMLElement) => void>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the HTML element generated for word wrapping should be reused or removed after each wrapping.\r\n     */\r\n    public reuseHTMLForWordWrapping: boolean = false;\r\n\r\n    /**\r\n     * Return the line list (you may need to use the onLinesReadyObservable to make sure the list is ready)\r\n     */\r\n    public get lines(): any[] {\r\n        return this._lines;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the TextBlock will be resized to fit its content\r\n\r\n     */\r\n    @serialize()\r\n    public get resizeToFit(): boolean {\r\n        return this._resizeToFit;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the TextBlock will be resized to fit its content\r\n\r\n     */\r\n    public set resizeToFit(value: boolean) {\r\n        if (this._resizeToFit === value) {\r\n            return;\r\n        }\r\n        this._resizeToFit = value;\r\n\r\n        if (this._resizeToFit) {\r\n            this._width.ignoreAdaptiveScaling = true;\r\n            this._height.ignoreAdaptiveScaling = true;\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if text must be wrapped\r\n     */\r\n    @serialize()\r\n    public get textWrapping(): TextWrapping | boolean {\r\n        return this._textWrapping;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if text must be wrapped\r\n     */\r\n    public set textWrapping(value: TextWrapping | boolean) {\r\n        if (this._textWrapping === value) {\r\n            return;\r\n        }\r\n        this._textWrapping = +value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text to display\r\n     */\r\n    @serialize()\r\n    public get text(): string {\r\n        return this._text;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text to display\r\n     */\r\n    public set text(value: string) {\r\n        if (this._text === value) {\r\n            return;\r\n        }\r\n        this._text = value + \"\"; // Making sure it is a text\r\n        this._markAsDirty();\r\n\r\n        this.onTextChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text horizontal alignment (BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    @serialize()\r\n    public get textHorizontalAlignment(): number {\r\n        return this._textHorizontalAlignment;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text horizontal alignment (BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    public set textHorizontalAlignment(value: number) {\r\n        if (this._textHorizontalAlignment === value) {\r\n            return;\r\n        }\r\n\r\n        this._textHorizontalAlignment = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text vertical alignment (BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    @serialize()\r\n    public get textVerticalAlignment(): number {\r\n        return this._textVerticalAlignment;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text vertical alignment (BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    public set textVerticalAlignment(value: number) {\r\n        if (this._textVerticalAlignment === value) {\r\n            return;\r\n        }\r\n\r\n        this._textVerticalAlignment = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets line spacing value\r\n     */\r\n    @serialize()\r\n    public set lineSpacing(value: string | number) {\r\n        if (this._lineSpacing.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets line spacing value\r\n     */\r\n    public get lineSpacing(): string | number {\r\n        return this._lineSpacing.toString(this._host);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    @serialize()\r\n    public get outlineWidth(): number {\r\n        return this._outlineWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    public set outlineWidth(value: number) {\r\n        if (this._outlineWidth === value) {\r\n            return;\r\n        }\r\n        this._outlineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that text must have underline\r\n     */\r\n    @serialize()\r\n    public get underline(): boolean {\r\n        return this._underline;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that text must have underline\r\n     */\r\n    public set underline(value: boolean) {\r\n        if (this._underline === value) {\r\n            return;\r\n        }\r\n        this._underline = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an boolean indicating that text must be crossed out\r\n     */\r\n    @serialize()\r\n    public get lineThrough(): boolean {\r\n        return this._lineThrough;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an boolean indicating that text must be crossed out\r\n     */\r\n    public set lineThrough(value: boolean) {\r\n        if (this._lineThrough === value) {\r\n            return;\r\n        }\r\n        this._lineThrough = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * If the outline should be applied to the underline/strike-through too. Has different behavior in Edge/Chrome vs Firefox.\r\n     */\r\n    @serialize()\r\n    public get applyOutlineToUnderline(): boolean {\r\n        return this._applyOutlineToUnderline;\r\n    }\r\n\r\n    public set applyOutlineToUnderline(value: boolean) {\r\n        if (this._applyOutlineToUnderline === value) {\r\n            return;\r\n        }\r\n        this._applyOutlineToUnderline = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    @serialize()\r\n    public get outlineColor(): string {\r\n        return this._outlineColor;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    public set outlineColor(value: string) {\r\n        if (this._outlineColor === value) {\r\n            return;\r\n        }\r\n        this._outlineColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets word divider\r\n     */\r\n    @serialize()\r\n    public get wordDivider(): string {\r\n        return this._wordDivider;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets word divider\r\n     */\r\n    public set wordDivider(value: string) {\r\n        if (this._wordDivider === value) {\r\n            return;\r\n        }\r\n        this._wordDivider = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * By default, if a text block has text wrapping other than Clip, its width\r\n     * is not resized even if resizeToFit = true. This parameter forces the width\r\n     * to be resized.\r\n     */\r\n    @serialize()\r\n    public get forceResizeWidth(): boolean {\r\n        return this._forceResizeWidth;\r\n    }\r\n\r\n    public set forceResizeWidth(value: boolean) {\r\n        if (this._forceResizeWidth === value) {\r\n            return;\r\n        }\r\n        this._forceResizeWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextBlock object\r\n     * @param name defines the name of the control\r\n     * @param text defines the text to display (empty string by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the control\r\n         */\r\n        public override name?: string,\r\n        text: string = \"\"\r\n    ) {\r\n        super(name);\r\n\r\n        this.text = text;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"TextBlock\";\r\n    }\r\n\r\n    protected override _processMeasures(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        if (!this._fontOffset || this.isDirty) {\r\n            this._fontOffset = Control._GetFontOffset(context.font, this._host.getScene()?.getEngine());\r\n        }\r\n        super._processMeasures(parentMeasure, context);\r\n\r\n        // Prepare lines\r\n        this._lines = this._breakLines(this._currentMeasure.width, this._currentMeasure.height, context);\r\n        this.onLinesReadyObservable.notifyObservers(this);\r\n\r\n        let maxLineWidth: number = 0;\r\n\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n\r\n            if (line.width > maxLineWidth) {\r\n                maxLineWidth = line.width;\r\n            }\r\n        }\r\n\r\n        if (this._resizeToFit) {\r\n            if (this._textWrapping === TextWrapping.Clip || this._forceResizeWidth) {\r\n                const newWidth = Math.ceil(this._paddingLeftInPixels) + Math.ceil(this._paddingRightInPixels) + Math.ceil(maxLineWidth);\r\n                if (newWidth !== this._width.getValueInPixel(this._host, this._tempParentMeasure.width)) {\r\n                    this._width.updateInPlace(newWidth, ValueAndUnit.UNITMODE_PIXEL);\r\n                    this._rebuildLayout = true;\r\n                }\r\n            }\r\n            let newHeight = (this._paddingTopInPixels + this._paddingBottomInPixels + this._fontOffset.height * this._lines.length) | 0;\r\n\r\n            if (this._lines.length > 0 && this._lineSpacing.internalValue !== 0) {\r\n                let lineSpacing = 0;\r\n                if (this._lineSpacing.isPixel) {\r\n                    lineSpacing = this._lineSpacing.getValue(this._host);\r\n                } else {\r\n                    lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n                }\r\n\r\n                newHeight += (this._lines.length - 1) * lineSpacing;\r\n            }\r\n\r\n            if (newHeight !== this._height.internalValue) {\r\n                this._height.updateInPlace(newHeight, ValueAndUnit.UNITMODE_PIXEL);\r\n                this._rebuildLayout = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _drawText(text: string, textWidth: number, y: number, context: ICanvasRenderingContext): void {\r\n        const width = this._currentMeasure.width;\r\n        let x = 0;\r\n        switch (this._textHorizontalAlignment) {\r\n            case Control.HORIZONTAL_ALIGNMENT_LEFT:\r\n                x = 0;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_RIGHT:\r\n                x = width - textWidth;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_CENTER:\r\n                x = (width - textWidth) / 2;\r\n                break;\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        if (this.outlineWidth) {\r\n            context.strokeText(text, this._currentMeasure.left + x, y);\r\n        }\r\n        context.fillText(text, this._currentMeasure.left + x, y);\r\n\r\n        if (this._underline) {\r\n            this._drawLine(this._currentMeasure.left + x, y + 3, this._currentMeasure.left + x + textWidth, y + 3, context);\r\n        }\r\n\r\n        if (this._lineThrough) {\r\n            this._drawLine(this._currentMeasure.left + x, y - this.fontSizeInPixels / 3, this._currentMeasure.left + x + textWidth, y - this.fontSizeInPixels / 3, context);\r\n        }\r\n    }\r\n\r\n    private _drawLine(xFrom: number, yFrom: number, xTo: number, yTo: number, context: ICanvasRenderingContext): void {\r\n        context.beginPath();\r\n        context.lineWidth = Math.round(this.fontSizeInPixels * 0.05);\r\n        context.moveTo(xFrom, yFrom);\r\n        context.lineTo(xTo, yTo);\r\n        if (this.outlineWidth && this.applyOutlineToUnderline) {\r\n            context.stroke();\r\n            context.fill();\r\n        } else {\r\n            const currentStroke = context.strokeStyle;\r\n            context.strokeStyle = context.fillStyle;\r\n            context.stroke();\r\n            context.strokeStyle = currentStroke;\r\n        }\r\n        context.closePath();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        // Render lines\r\n        this._renderLines(context);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    protected override _applyStates(context: ICanvasRenderingContext): void {\r\n        super._applyStates(context);\r\n        if (this.outlineWidth) {\r\n            context.lineWidth = this.outlineWidth;\r\n            context.strokeStyle = this.outlineColor;\r\n            context.lineJoin = \"miter\";\r\n            context.miterLimit = 2;\r\n        }\r\n    }\r\n\r\n    private _linesTemp: object[] = [];\r\n\r\n    protected _breakLines(refWidth: number, refHeight: number, context: ICanvasRenderingContext): object[] {\r\n        this._linesTemp.length = 0;\r\n        const _lines = this._textWrapping === TextWrapping.HTML ? this._parseHTMLText(refWidth, refHeight, context) : this.text.split(\"\\n\");\r\n\r\n        switch (this._textWrapping) {\r\n            case TextWrapping.WordWrap:\r\n                for (const _line of _lines) {\r\n                    this._linesTemp.push(...this._parseLineWordWrap(_line, refWidth, context));\r\n                }\r\n                break;\r\n            case TextWrapping.Ellipsis:\r\n                for (const _line of _lines) {\r\n                    this._linesTemp.push(this._parseLineEllipsis(_line, refWidth, context));\r\n                }\r\n                break;\r\n            case TextWrapping.WordWrapEllipsis:\r\n                for (const _line of _lines) {\r\n                    this._linesTemp.push(...this._parseLineWordWrapEllipsis(_line, refWidth, refHeight, context));\r\n                }\r\n                break;\r\n            case TextWrapping.HTML:\r\n            default:\r\n                for (const _line of _lines) {\r\n                    this._linesTemp.push(this._parseLine(_line, context));\r\n                }\r\n                break;\r\n        }\r\n\r\n        return this._linesTemp;\r\n    }\r\n\r\n    private _htmlElement: Nullable<HTMLElement> = null;\r\n\r\n    protected _parseHTMLText(refWidth: number, refHeight: number, context: ICanvasRenderingContext): string[] {\r\n        const lines = [] as string[];\r\n        if (!this._htmlElement) {\r\n            this._htmlElement = document.createElement(\"div\");\r\n            document.body.appendChild(this._htmlElement);\r\n        }\r\n        const htmlElement = this._htmlElement;\r\n        htmlElement.textContent = this.text;\r\n        htmlElement.style.font = context.font;\r\n        htmlElement.style.position = \"absolute\";\r\n        htmlElement.style.visibility = \"hidden\";\r\n        htmlElement.style.top = \"-1000px\";\r\n        htmlElement.style.left = \"-1000px\";\r\n        this.adjustWordWrappingHTMLElement?.(htmlElement);\r\n        htmlElement.style.width = refWidth + \"px\";\r\n        htmlElement.style.height = refHeight + \"px\";\r\n        const textContent = htmlElement.textContent;\r\n        if (!textContent) {\r\n            return lines;\r\n        }\r\n        // get the text node\r\n        const textNode = htmlElement.childNodes[0];\r\n        const range = document.createRange();\r\n        let idx = 0;\r\n        for (const c of textContent) {\r\n            range.setStart(textNode, 0);\r\n            range.setEnd(textNode, idx + 1);\r\n            // \"select\" text from beginning to this position to determine the line\r\n            const lineIndex = range.getClientRects().length - 1;\r\n            lines[lineIndex] = (lines[lineIndex] || \"\") + c;\r\n            idx++;\r\n        }\r\n\r\n        if (!this.reuseHTMLForWordWrapping) {\r\n            htmlElement.remove();\r\n            this._htmlElement = null;\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _parseLine(line: string = \"\", context: ICanvasRenderingContext): object {\r\n        return { text: line, width: this._getTextMetricsWidth(context.measureText(line)) };\r\n    }\r\n\r\n    //Calculate how many characters approximately we need to remove\r\n    private _getCharsToRemove(lineWidth: number, width: number, lineLength: number) {\r\n        const diff = lineWidth > width ? lineWidth - width : 0;\r\n        // This isn't exact unless the font is monospaced\r\n        const charWidth = lineWidth / lineLength;\r\n        const removeChars = Math.max(Math.floor(diff / charWidth), 1);\r\n        return removeChars;\r\n    }\r\n\r\n    protected _parseLineEllipsis(line: string = \"\", width: number, context: ICanvasRenderingContext): object {\r\n        let lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n        let removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n\r\n        // unicode support. split('') does not work with unicode!\r\n        // make sure Array.from is available\r\n        const characters = Array.from && Array.from(line);\r\n        if (!characters) {\r\n            // no array.from, use the old method\r\n            while (line.length > 2 && lineWidth > width) {\r\n                line = line.slice(0, -removeChars);\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line + \"…\"));\r\n\r\n                removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n            }\r\n            // Add on the end\r\n            line += \"…\";\r\n        } else {\r\n            while (characters.length && lineWidth > width) {\r\n                characters.splice(characters.length - removeChars, removeChars);\r\n                line = `${characters.join(\"\")}…`;\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n                removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n            }\r\n        }\r\n\r\n        return { text: line, width: lineWidth };\r\n    }\r\n\r\n    private _getTextMetricsWidth(textMetrics: ITextMetrics) {\r\n        if (textMetrics.actualBoundingBoxLeft !== undefined) {\r\n            return Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight);\r\n        }\r\n        return textMetrics.width;\r\n    }\r\n\r\n    protected _parseLineWordWrap(line: string = \"\", width: number, context: ICanvasRenderingContext): object[] {\r\n        const lines = [];\r\n        const words = this.wordSplittingFunction ? this.wordSplittingFunction(line) : line.split(this._wordDivider);\r\n        let lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n        for (let n = 0; n < words.length; n++) {\r\n            const testLine = n > 0 ? line + this._wordDivider + words[n] : words[0];\r\n            const testWidth = this._getTextMetricsWidth(context.measureText(testLine));\r\n            if (testWidth > width && n > 0) {\r\n                lines.push({ text: line, width: lineWidth });\r\n                line = words[n];\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n            } else {\r\n                lineWidth = testWidth;\r\n                line = testLine;\r\n            }\r\n        }\r\n        lines.push({ text: line, width: lineWidth });\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _parseLineWordWrapEllipsis(line: string = \"\", width: number, height: number, context: ICanvasRenderingContext): object[] {\r\n        const lines = this._parseLineWordWrap(line, width, context);\r\n        for (let n = 1; n <= lines.length; n++) {\r\n            const currentHeight = this._computeHeightForLinesOf(n);\r\n            if (currentHeight > height && n > 1) {\r\n                const lastLine = lines[n - 2] as { text: string; width: number };\r\n                const currentLine = lines[n - 1] as { text: string; width: number };\r\n                lines[n - 2] = this._parseLineEllipsis(lastLine.text + this._wordDivider + currentLine.text, width, context);\r\n                const linesToRemove = lines.length - n + 1;\r\n                for (let i = 0; i < linesToRemove; i++) {\r\n                    lines.pop();\r\n                }\r\n                return lines;\r\n            }\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _renderLines(context: ICanvasRenderingContext): void {\r\n        if (!this._fontOffset || !this._lines) {\r\n            return;\r\n        }\r\n        const height = this._currentMeasure.height;\r\n        let rootY = 0;\r\n        switch (this._textVerticalAlignment) {\r\n            case Control.VERTICAL_ALIGNMENT_TOP:\r\n                rootY = this._fontOffset.ascent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_BOTTOM:\r\n                rootY = height - this._fontOffset.height * (this._lines.length - 1) - this._fontOffset.descent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_CENTER:\r\n                rootY = this._fontOffset.ascent + (height - this._fontOffset.height * this._lines.length) / 2;\r\n                break;\r\n        }\r\n\r\n        rootY += this._currentMeasure.top;\r\n\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n\r\n            if (i !== 0 && this._lineSpacing.internalValue !== 0) {\r\n                if (this._lineSpacing.isPixel) {\r\n                    rootY += this._lineSpacing.getValue(this._host);\r\n                } else {\r\n                    rootY = rootY + this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n                }\r\n            }\r\n\r\n            this._drawText(line.text, line.width, rootY, context);\r\n            rootY += this._fontOffset.height;\r\n        }\r\n    }\r\n\r\n    private _computeHeightForLinesOf(lineCount: number): number {\r\n        let newHeight = this._paddingTopInPixels + this._paddingBottomInPixels + this._fontOffset.height * lineCount;\r\n\r\n        if (lineCount > 0 && this._lineSpacing.internalValue !== 0) {\r\n            let lineSpacing = 0;\r\n            if (this._lineSpacing.isPixel) {\r\n                lineSpacing = this._lineSpacing.getValue(this._host);\r\n            } else {\r\n                lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n            }\r\n\r\n            newHeight += (lineCount - 1) * lineSpacing;\r\n        }\r\n\r\n        return newHeight;\r\n    }\r\n\r\n    public override isDimensionFullyDefined(dim: \"width\" | \"height\"): boolean {\r\n        if (this.resizeToFit) {\r\n            return true;\r\n        }\r\n        return super.isDimensionFullyDefined(dim);\r\n    }\r\n\r\n    /**\r\n     * Given a width constraint applied on the text block, find the expected height\r\n     * @returns expected height\r\n     */\r\n    public computeExpectedHeight(): number {\r\n        if (this.text && this.widthInPixels) {\r\n            // Should abstract platform instead of using LastCreatedEngine\r\n            const context = EngineStore.LastCreatedEngine?.createCanvas(0, 0).getContext(\"2d\");\r\n            if (context) {\r\n                this._applyStates(context);\r\n                if (!this._fontOffset) {\r\n                    this._fontOffset = Control._GetFontOffset(context.font, this._host.getScene()?.getEngine());\r\n                }\r\n                const lines = this._lines\r\n                    ? this._lines\r\n                    : this._breakLines(\r\n                          this.widthInPixels - this._paddingLeftInPixels - this._paddingRightInPixels,\r\n                          this.heightInPixels - this._paddingTopInPixels - this._paddingBottomInPixels,\r\n                          context\r\n                      );\r\n                return this._computeHeightForLinesOf(lines.length);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    override dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onTextChangedObservable.clear();\r\n        this._htmlElement?.remove();\r\n        this._htmlElement = null;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.TextBlock\", TextBlock);\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\nimport { Control } from \"./control\";\r\nimport type { Measure } from \"../measure\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvas, ICanvasRenderingContext, IImage } from \"core/Engines/ICanvas\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\n/**\r\n * Class used to create 2D images\r\n */\r\nexport class Image extends Control {\r\n    /**\r\n     *  Specifies an alternate text for the image, if the image for some reason cannot be displayed.\r\n     */\r\n    public alt?: string;\r\n\r\n    private _workingCanvas: Nullable<ICanvas> = null;\r\n\r\n    private _domImage: IImage;\r\n    private _imageWidth: number;\r\n    private _imageHeight: number;\r\n    private _loaded = false;\r\n    private _stretch = Image.STRETCH_FILL;\r\n    private _source: Nullable<string> = null;\r\n    private _autoScale = false;\r\n\r\n    private _sourceLeft = 0;\r\n    private _sourceTop = 0;\r\n    private _sourceWidth = 0;\r\n    private _sourceHeight = 0;\r\n    private _svgAttributesComputationCompleted: boolean = false;\r\n    private _isSVG: boolean = false;\r\n\r\n    private _cellWidth: number = 0;\r\n    private _cellHeight: number = 0;\r\n    private _cellId: number = -1;\r\n\r\n    private _sliceLeft: number;\r\n    private _sliceRight: number;\r\n    private _sliceTop: number;\r\n    private _sliceBottom: number;\r\n\r\n    private _populateNinePatchSlicesFromImage = false;\r\n\r\n    private _detectPointerOnOpaqueOnly: boolean;\r\n\r\n    private _imageDataCache: {\r\n        data: Uint8ClampedArray | null;\r\n        key: string;\r\n    } = { data: null, key: \"\" };\r\n\r\n    /**\r\n     * Cache of images to avoid loading the same image multiple times\r\n     */\r\n    public static SourceImgCache = new Map<string, { img: IImage; timesUsed: number; loaded: boolean; waitingForLoadCallback: Array<() => void> }>();\r\n\r\n    /**\r\n     * Observable notified when the content is loaded\r\n     */\r\n    public onImageLoadedObservable = new Observable<Image>();\r\n\r\n    /**\r\n     * Observable notified when _sourceLeft, _sourceTop, _sourceWidth and _sourceHeight are computed\r\n     */\r\n    public onSVGAttributesComputedObservable = new Observable<Image>();\r\n\r\n    /**\r\n     * Gets or sets the referrer policy to apply on the img element load request.\r\n     * You should set referrerPolicy before set the source of the image if you want to ensure the header will be present on the xhr loading request\r\n     */\r\n    public referrerPolicy: Nullable<ReferrerPolicy>;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the content is loaded\r\n     */\r\n    public get isLoaded(): boolean {\r\n        return this._loaded;\r\n    }\r\n\r\n    public override isReady(): boolean {\r\n        return this.isLoaded;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if pointers should only be validated on pixels with alpha > 0.\r\n     * Beware using this as this will consume more memory as the image has to be stored twice\r\n     */\r\n    @serialize()\r\n    public get detectPointerOnOpaqueOnly(): boolean {\r\n        return this._detectPointerOnOpaqueOnly;\r\n    }\r\n\r\n    public set detectPointerOnOpaqueOnly(value: boolean) {\r\n        if (this._detectPointerOnOpaqueOnly === value) {\r\n            return;\r\n        }\r\n\r\n        this._detectPointerOnOpaqueOnly = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the left value for slicing (9-patch)\r\n     */\r\n    @serialize()\r\n    public get sliceLeft(): number {\r\n        return this._sliceLeft;\r\n    }\r\n\r\n    public set sliceLeft(value: number) {\r\n        if (this._sliceLeft === value) {\r\n            return;\r\n        }\r\n\r\n        this._sliceLeft = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the right value for slicing (9-patch)\r\n     */\r\n    @serialize()\r\n    public get sliceRight(): number {\r\n        return this._sliceRight;\r\n    }\r\n\r\n    public set sliceRight(value: number) {\r\n        if (this._sliceRight === value) {\r\n            return;\r\n        }\r\n\r\n        this._sliceRight = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the top value for slicing (9-patch)\r\n     */\r\n    @serialize()\r\n    public get sliceTop(): number {\r\n        return this._sliceTop;\r\n    }\r\n\r\n    public set sliceTop(value: number) {\r\n        if (this._sliceTop === value) {\r\n            return;\r\n        }\r\n\r\n        this._sliceTop = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the bottom value for slicing (9-patch)\r\n     */\r\n    @serialize()\r\n    public get sliceBottom(): number {\r\n        return this._sliceBottom;\r\n    }\r\n\r\n    public set sliceBottom(value: number) {\r\n        if (this._sliceBottom === value) {\r\n            return;\r\n        }\r\n\r\n        this._sliceBottom = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the left coordinate in the source image\r\n     */\r\n    @serialize()\r\n    public get sourceLeft(): number {\r\n        return this._sourceLeft;\r\n    }\r\n\r\n    public set sourceLeft(value: number) {\r\n        if (this._sourceLeft === value) {\r\n            return;\r\n        }\r\n\r\n        this._sourceLeft = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the top coordinate in the source image\r\n     */\r\n    @serialize()\r\n    public get sourceTop(): number {\r\n        return this._sourceTop;\r\n    }\r\n\r\n    public set sourceTop(value: number) {\r\n        if (this._sourceTop === value) {\r\n            return;\r\n        }\r\n\r\n        this._sourceTop = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the width to capture in the source image\r\n     */\r\n    @serialize()\r\n    public get sourceWidth(): number {\r\n        return this._sourceWidth;\r\n    }\r\n\r\n    public set sourceWidth(value: number) {\r\n        if (this._sourceWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._sourceWidth = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the height to capture in the source image\r\n     */\r\n    @serialize()\r\n    public get sourceHeight(): number {\r\n        return this._sourceHeight;\r\n    }\r\n\r\n    public set sourceHeight(value: number) {\r\n        if (this._sourceHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._sourceHeight = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the image width\r\n     */\r\n    public get imageWidth(): number {\r\n        return this._imageWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets the image height\r\n     */\r\n    public get imageHeight(): number {\r\n        return this._imageHeight;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if nine patch slices (left, top, right, bottom) should be read from image data\r\n     */\r\n    @serialize()\r\n    public get populateNinePatchSlicesFromImage(): boolean {\r\n        return this._populateNinePatchSlicesFromImage;\r\n    }\r\n\r\n    public set populateNinePatchSlicesFromImage(value: boolean) {\r\n        if (this._populateNinePatchSlicesFromImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._populateNinePatchSlicesFromImage = value;\r\n\r\n        if (this._populateNinePatchSlicesFromImage && this._loaded) {\r\n            this._extractNinePatchSliceDataFromImage();\r\n        }\r\n    }\r\n\r\n    /** Indicates if the format of the image is SVG */\r\n    public get isSVG(): boolean {\r\n        return this._isSVG;\r\n    }\r\n\r\n    /** Gets the status of the SVG attributes computation (sourceLeft, sourceTop, sourceWidth, sourceHeight) */\r\n    public get svgAttributesComputationCompleted(): boolean {\r\n        return this._svgAttributesComputationCompleted;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the image can force its container to adapt its size\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\r\n     */\r\n    @serialize()\r\n    public get autoScale(): boolean {\r\n        return this._autoScale;\r\n    }\r\n\r\n    public set autoScale(value: boolean) {\r\n        if (this._autoScale === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoScale = value;\r\n\r\n        if (value && this._loaded) {\r\n            this.synchronizeSizeWithContent();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the stretching mode used by the image */\r\n    @serialize()\r\n    public get stretch(): number {\r\n        return this._stretch;\r\n    }\r\n\r\n    public set stretch(value: number) {\r\n        if (this._stretch === value) {\r\n            return;\r\n        }\r\n\r\n        this._stretch = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _rotate90(n: number, preserveProperties: boolean = false): Image {\r\n        const width = this._domImage.width;\r\n        const height = this._domImage.height;\r\n\r\n        // Should abstract platform instead of using LastCreatedEngine\r\n        const engine = this._host?.getScene()?.getEngine() || EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n        }\r\n        const canvas = engine.createCanvas(height, width);\r\n\r\n        const context = canvas.getContext(\"2d\")!;\r\n\r\n        context.translate(canvas.width / 2, canvas.height / 2);\r\n        context.rotate((n * Math.PI) / 2);\r\n\r\n        context.drawImage(this._domImage, 0, 0, width, height, -width / 2, -height / 2, width, height);\r\n\r\n        const dataUrl: string = canvas.toDataURL(\"image/jpg\");\r\n        const rotatedImage = new Image(this.name + \"rotated\", dataUrl);\r\n\r\n        if (preserveProperties) {\r\n            rotatedImage._stretch = this._stretch;\r\n            rotatedImage._autoScale = this._autoScale;\r\n            rotatedImage._cellId = this._cellId;\r\n            rotatedImage._cellWidth = n % 1 ? this._cellHeight : this._cellWidth;\r\n            rotatedImage._cellHeight = n % 1 ? this._cellWidth : this._cellHeight;\r\n        }\r\n\r\n        this._handleRotationForSVGImage(this, rotatedImage, n);\r\n\r\n        this._imageDataCache.data = null;\r\n\r\n        return rotatedImage;\r\n    }\r\n\r\n    private _handleRotationForSVGImage(srcImage: Image, dstImage: Image, n: number): void {\r\n        if (!srcImage._isSVG) {\r\n            return;\r\n        }\r\n\r\n        if (srcImage._svgAttributesComputationCompleted) {\r\n            this._rotate90SourceProperties(srcImage, dstImage, n);\r\n            this._markAsDirty();\r\n        } else {\r\n            srcImage.onSVGAttributesComputedObservable.addOnce(() => {\r\n                this._rotate90SourceProperties(srcImage, dstImage, n);\r\n                this._markAsDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _rotate90SourceProperties(srcImage: Image, dstImage: Image, n: number): void {\r\n        let srcLeft = srcImage.sourceLeft,\r\n            srcTop = srcImage.sourceTop,\r\n            srcWidth = srcImage.domImage.width,\r\n            srcHeight = srcImage.domImage.height;\r\n\r\n        let dstLeft = srcLeft,\r\n            dstTop = srcTop,\r\n            dstWidth = srcImage.sourceWidth,\r\n            dstHeight = srcImage.sourceHeight;\r\n\r\n        if (n != 0) {\r\n            const mult = n < 0 ? -1 : 1;\r\n            n = n % 4;\r\n            for (let i = 0; i < Math.abs(n); ++i) {\r\n                dstLeft = -(srcTop - srcHeight / 2) * mult + srcHeight / 2;\r\n                dstTop = (srcLeft - srcWidth / 2) * mult + srcWidth / 2;\r\n                [dstWidth, dstHeight] = [dstHeight, dstWidth];\r\n                if (n < 0) {\r\n                    dstTop -= dstHeight;\r\n                } else {\r\n                    dstLeft -= dstWidth;\r\n                }\r\n                srcLeft = dstLeft;\r\n                srcTop = dstTop;\r\n                [srcWidth, srcHeight] = [srcHeight, srcWidth];\r\n            }\r\n        }\r\n\r\n        dstImage.sourceLeft = dstLeft;\r\n        dstImage.sourceTop = dstTop;\r\n        dstImage.sourceWidth = dstWidth;\r\n        dstImage.sourceHeight = dstHeight;\r\n    }\r\n\r\n    private _extractNinePatchSliceDataFromImage() {\r\n        const width = this._domImage.width;\r\n        const height = this._domImage.height;\r\n\r\n        if (!this._workingCanvas) {\r\n            const engine = this._host?.getScene()?.getEngine() || EngineStore.LastCreatedEngine;\r\n            if (!engine) {\r\n                throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n            }\r\n            this._workingCanvas = engine.createCanvas(width, height);\r\n        }\r\n        const canvas = this._workingCanvas;\r\n        const context = canvas.getContext(\"2d\")!;\r\n\r\n        context.drawImage(this._domImage, 0, 0, width, height);\r\n        const imageData = context.getImageData(0, 0, width, height);\r\n\r\n        // Left and right\r\n        this._sliceLeft = -1;\r\n        this._sliceRight = -1;\r\n        for (let x = 0; x < width; x++) {\r\n            const alpha = imageData.data[x * 4 + 3];\r\n\r\n            if (alpha > 127 && this._sliceLeft === -1) {\r\n                this._sliceLeft = x;\r\n                continue;\r\n            }\r\n\r\n            if (alpha < 127 && this._sliceLeft > -1) {\r\n                this._sliceRight = x;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // top and bottom\r\n        this._sliceTop = -1;\r\n        this._sliceBottom = -1;\r\n        for (let y = 0; y < height; y++) {\r\n            const alpha = imageData.data[y * width * 4 + 3];\r\n\r\n            if (alpha > 127 && this._sliceTop === -1) {\r\n                this._sliceTop = y;\r\n                continue;\r\n            }\r\n\r\n            if (alpha < 127 && this._sliceTop > -1) {\r\n                this._sliceBottom = y;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the internal DOM image used to render the control\r\n     */\r\n    public set domImage(value: IImage) {\r\n        this._domImage = value;\r\n        this._loaded = false;\r\n        this._imageDataCache.data = null;\r\n\r\n        if (this._domImage.width) {\r\n            this._onImageLoaded();\r\n        } else {\r\n            this._domImage.onload = () => {\r\n                this._onImageLoaded();\r\n            };\r\n        }\r\n    }\r\n\r\n    public get domImage(): IImage {\r\n        return this._domImage;\r\n    }\r\n\r\n    private _onImageLoaded(): void {\r\n        this._imageDataCache.data = null;\r\n        this._imageWidth = this._domImage.width;\r\n        this._imageHeight = this._domImage.height;\r\n        this._loaded = true;\r\n\r\n        if (this._populateNinePatchSlicesFromImage) {\r\n            this._extractNinePatchSliceDataFromImage();\r\n        }\r\n\r\n        if (this._autoScale) {\r\n            this.synchronizeSizeWithContent();\r\n        }\r\n\r\n        this.onImageLoadedObservable.notifyObservers(this);\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the image source url\r\n     */\r\n    @serialize()\r\n    public get source() {\r\n        return this._source;\r\n    }\r\n\r\n    /**\r\n     * Resets the internal Image Element cache. Can reduce memory usage.\r\n     */\r\n    public static ResetImageCache() {\r\n        Image.SourceImgCache.clear();\r\n    }\r\n\r\n    private _removeCacheUsage(source: Nullable<string>) {\r\n        const value = source && Image.SourceImgCache.get(source);\r\n        if (value) {\r\n            value.timesUsed -= 1;\r\n\r\n            // Remove from DOM\r\n            const htmlElement = value.img as HTMLImageElement;\r\n            if (htmlElement.parentNode) {\r\n                htmlElement.parentNode.removeChild(htmlElement);\r\n            }\r\n\r\n            // Since the image isn't being used anymore, we can clean it from the cache\r\n            if (value.timesUsed === 0) {\r\n                Image.SourceImgCache.delete(source);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets image source url\r\n     */\r\n    public set source(value: Nullable<string>) {\r\n        if (this._urlRewriter && value) {\r\n            value = this._urlRewriter(value);\r\n        }\r\n\r\n        if (this._source === value) {\r\n            return;\r\n        }\r\n\r\n        this._removeCacheUsage(this._source);\r\n\r\n        this._loaded = false;\r\n        this._source = value;\r\n        this._imageDataCache.data = null;\r\n\r\n        if (value) {\r\n            value = this._svgCheck(value);\r\n        }\r\n\r\n        // Should abstract platform instead of using LastCreatedEngine\r\n        const engine = this._host?.getScene()?.getEngine() || EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n        }\r\n        if (value && Image.SourceImgCache.has(value)) {\r\n            const cachedData = Image.SourceImgCache.get(value)!;\r\n            this._domImage = cachedData.img;\r\n            cachedData.timesUsed += 1;\r\n            if (cachedData.loaded) {\r\n                this._onImageLoaded();\r\n            } else {\r\n                cachedData.waitingForLoadCallback.push(this._onImageLoaded.bind(this));\r\n            }\r\n            return;\r\n        }\r\n        this._domImage = engine.createCanvasImage();\r\n        // need to add to enforce rendering\r\n        const imgElement = this._domImage as HTMLImageElement;\r\n        let addedToDom = false;\r\n        if (imgElement.style && this._source?.endsWith(\".svg\")) {\r\n            imgElement.style.visibility = \"hidden\";\r\n            imgElement.style.position = \"absolute\";\r\n            imgElement.style.top = \"0\";\r\n            engine.getRenderingCanvas()?.parentNode?.appendChild(imgElement);\r\n            addedToDom = true;\r\n        }\r\n\r\n        if (value) {\r\n            Image.SourceImgCache.set(value, { img: this._domImage, timesUsed: 1, loaded: false, waitingForLoadCallback: [this._onImageLoaded.bind(this)] });\r\n        }\r\n\r\n        this._domImage.onload = () => {\r\n            if (value) {\r\n                const cachedData = Image.SourceImgCache.get(value);\r\n                if (cachedData) {\r\n                    cachedData.loaded = true;\r\n                    for (const waitingCallback of cachedData.waitingForLoadCallback) {\r\n                        waitingCallback();\r\n                    }\r\n                    cachedData.waitingForLoadCallback.length = 0;\r\n                    addedToDom && imgElement.remove();\r\n                    return;\r\n                }\r\n            }\r\n            this._onImageLoaded();\r\n            addedToDom && imgElement.remove();\r\n        };\r\n        if (value) {\r\n            Tools.SetCorsBehavior(value, this._domImage);\r\n            Tools.SetReferrerPolicyBehavior(this.referrerPolicy, this._domImage);\r\n            this._domImage.src = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks for svg document with icon id present\r\n     * @param value the source svg\r\n     * @returns the svg\r\n     */\r\n    private _svgCheck(value: string): string {\r\n        if (window.SVGSVGElement && value.search(/(\\.svg|\\.svg?[?|#].*)$/gi) !== -1 && value.indexOf(\"#\") === value.lastIndexOf(\"#\")) {\r\n            this._isSVG = true;\r\n            const svgsrc = value.split(\"#\")[0];\r\n            const elemid = value.split(\"#\")[1];\r\n            // check if object alr exist in document\r\n            const svgExist = <HTMLObjectElement>document.body.querySelector('object[data=\"' + svgsrc + '\"]');\r\n            if (svgExist) {\r\n                const svgDoc = svgExist.contentDocument;\r\n                // get viewbox width and height, get svg document width and height in px\r\n                if (svgDoc && svgDoc.documentElement) {\r\n                    const vb = svgDoc.documentElement.getAttribute(\"viewBox\");\r\n                    const docwidth = Number(svgDoc.documentElement.getAttribute(\"width\"));\r\n                    const docheight = Number(svgDoc.documentElement.getAttribute(\"height\"));\r\n                    const elem = <SVGGraphicsElement>(<unknown>svgDoc.getElementById(elemid));\r\n                    if (elem && vb && docwidth && docheight) {\r\n                        this._getSVGAttribs(svgExist, elemid);\r\n                        return value;\r\n                    }\r\n                }\r\n\r\n                // wait for object to load\r\n                svgExist.addEventListener(\"load\", () => {\r\n                    this._getSVGAttribs(svgExist, elemid);\r\n                });\r\n            } else {\r\n                // create document object\r\n                const svgImage = document.createElement(\"object\");\r\n                svgImage.data = svgsrc;\r\n                svgImage.type = \"image/svg+xml\";\r\n                svgImage.width = \"0%\";\r\n                svgImage.height = \"0%\";\r\n                document.body.appendChild(svgImage);\r\n                // when the object has loaded, get the element attribs\r\n                svgImage.onload = () => {\r\n                    const svgobj = <HTMLObjectElement>document.body.querySelector('object[data=\"' + svgsrc + '\"]');\r\n                    if (svgobj) {\r\n                        this._getSVGAttribs(svgobj, elemid);\r\n                    }\r\n                };\r\n            }\r\n            return svgsrc;\r\n        } else {\r\n            return value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets sourceLeft, sourceTop, sourceWidth, sourceHeight automatically\r\n     * given external svg file and icon id\r\n     * @param svgsrc\r\n     * @param elemid\r\n     */\r\n    private _getSVGAttribs(svgsrc: HTMLObjectElement, elemid: string) {\r\n        const svgDoc = svgsrc.contentDocument;\r\n        // get viewbox width and height, get svg document width and height in px\r\n        if (svgDoc && svgDoc.documentElement) {\r\n            const vb = svgDoc.documentElement.getAttribute(\"viewBox\");\r\n            const docwidth = Number(svgDoc.documentElement.getAttribute(\"width\"));\r\n            const docheight = Number(svgDoc.documentElement.getAttribute(\"height\"));\r\n            // get element bbox and matrix transform\r\n            const elem = svgDoc.getElementById(elemid) as Nullable<SVGGraphicsElement>;\r\n            if (vb && docwidth && docheight && elem) {\r\n                const vb_width = Number(vb.split(\" \")[2]);\r\n                const vb_height = Number(vb.split(\" \")[3]);\r\n                const elem_bbox = elem.getBBox();\r\n                let elem_matrix_a = 1;\r\n                let elem_matrix_d = 1;\r\n                let elem_matrix_e = 0;\r\n                let elem_matrix_f = 0;\r\n                const mainMatrix = elem.transform.baseVal.consolidate()!.matrix;\r\n                if (elem.transform && elem.transform.baseVal.consolidate()) {\r\n                    elem_matrix_a = mainMatrix.a;\r\n                    elem_matrix_d = mainMatrix.d;\r\n                    elem_matrix_e = mainMatrix.e;\r\n                    elem_matrix_f = mainMatrix.f;\r\n                }\r\n\r\n                // compute source coordinates and dimensions\r\n                this.sourceLeft = ((elem_matrix_a * elem_bbox.x + elem_matrix_e) * docwidth) / vb_width;\r\n                this.sourceTop = ((elem_matrix_d * elem_bbox.y + elem_matrix_f) * docheight) / vb_height;\r\n                this.sourceWidth = elem_bbox.width * elem_matrix_a * (docwidth / vb_width);\r\n                this.sourceHeight = elem_bbox.height * elem_matrix_d * (docheight / vb_height);\r\n                this._svgAttributesComputationCompleted = true;\r\n                this.onSVGAttributesComputedObservable.notifyObservers(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the cell width to use when animation sheet is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\r\n     */\r\n    @serialize()\r\n    get cellWidth(): number {\r\n        return this._cellWidth;\r\n    }\r\n    set cellWidth(value: number) {\r\n        if (this._cellWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._cellWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the cell height to use when animation sheet is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\r\n     */\r\n    @serialize()\r\n    get cellHeight(): number {\r\n        return this._cellHeight;\r\n    }\r\n    set cellHeight(value: number) {\r\n        if (this._cellHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._cellHeight = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the cell id to use (this will turn on the animation sheet mode)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#image\r\n     */\r\n    @serialize()\r\n    get cellId(): number {\r\n        return this._cellId;\r\n    }\r\n    set cellId(value: number) {\r\n        if (this._cellId === value) {\r\n            return;\r\n        }\r\n\r\n        this._cellId = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new Image\r\n     * @param name defines the control name\r\n     * @param url defines the image url\r\n     */\r\n    constructor(\r\n        public override name?: string,\r\n        url: Nullable<string> = null\r\n    ) {\r\n        super(name);\r\n        this.source = url;\r\n    }\r\n\r\n    /**\r\n     * Tests if a given coordinates belong to the current control\r\n     * @param x defines x coordinate to test\r\n     * @param y defines y coordinate to test\r\n     * @returns true if the coordinates are inside the control\r\n     */\r\n    public override contains(x: number, y: number): boolean {\r\n        if (!super.contains(x, y)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._detectPointerOnOpaqueOnly || !this._workingCanvas) {\r\n            return true;\r\n        }\r\n\r\n        const width = this._currentMeasure.width | 0;\r\n        const height = this._currentMeasure.height | 0;\r\n        const key = width + \"_\" + height;\r\n\r\n        let imageData = this._imageDataCache.data;\r\n\r\n        if (!imageData || this._imageDataCache.key !== key) {\r\n            const canvas = this._workingCanvas;\r\n            const context = canvas.getContext(\"2d\")!;\r\n\r\n            this._imageDataCache.data = imageData = context.getImageData(0, 0, width, height).data;\r\n            this._imageDataCache.key = key;\r\n        }\r\n\r\n        x = (x - this._currentMeasure.left) | 0;\r\n        y = (y - this._currentMeasure.top) | 0;\r\n\r\n        const pickedPixel = imageData[(x + y * width) * 4 + 3];\r\n\r\n        return pickedPixel > 0;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Image\";\r\n    }\r\n\r\n    /** Force the control to synchronize with its content */\r\n    public synchronizeSizeWithContent() {\r\n        if (!this._loaded) {\r\n            return;\r\n        }\r\n\r\n        this.width = this._domImage.width + \"px\";\r\n        this.height = this._domImage.height + \"px\";\r\n    }\r\n\r\n    protected override _processMeasures(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        if (this._loaded) {\r\n            switch (this._stretch) {\r\n                case Image.STRETCH_NONE:\r\n                    break;\r\n                case Image.STRETCH_FILL:\r\n                    break;\r\n                case Image.STRETCH_UNIFORM:\r\n                    break;\r\n                case Image.STRETCH_NINE_PATCH:\r\n                    break;\r\n                case Image.STRETCH_EXTEND:\r\n                    if (this._autoScale) {\r\n                        this.synchronizeSizeWithContent();\r\n                    }\r\n                    if (this.parent && this.parent.parent) {\r\n                        // Will update root size if root is not the top root\r\n                        this.parent.adaptWidthToChildren = true;\r\n                        this.parent.adaptHeightToChildren = true;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        super._processMeasures(parentMeasure, context);\r\n    }\r\n\r\n    private _prepareWorkingCanvasForOpaqueDetection() {\r\n        if (!this._detectPointerOnOpaqueOnly) {\r\n            return;\r\n        }\r\n\r\n        const width = this._currentMeasure.width;\r\n        const height = this._currentMeasure.height;\r\n\r\n        if (!this._workingCanvas) {\r\n            const engine = this._host?.getScene()?.getEngine() || EngineStore.LastCreatedEngine;\r\n            if (!engine) {\r\n                throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n            }\r\n            this._workingCanvas = engine.createCanvas(width, height);\r\n        }\r\n        const canvas = this._workingCanvas;\r\n\r\n        const context = canvas.getContext(\"2d\")!;\r\n\r\n        context.clearRect(0, 0, width, height);\r\n    }\r\n\r\n    private _drawImage(context: ICanvasRenderingContext, sx: number, sy: number, sw: number, sh: number, tx: number, ty: number, tw: number, th: number) {\r\n        context.drawImage(this._domImage, sx, sy, sw, sh, tx, ty, tw, th);\r\n\r\n        if (!this._detectPointerOnOpaqueOnly) {\r\n            return;\r\n        }\r\n\r\n        const transform = context.getTransform();\r\n\r\n        const canvas = this._workingCanvas!;\r\n        const workingCanvasContext = canvas.getContext(\"2d\")!;\r\n        workingCanvasContext.save();\r\n        const ttx = tx - this._currentMeasure.left;\r\n        const tty = ty - this._currentMeasure.top;\r\n        workingCanvasContext.setTransform(transform.a, transform.b, transform.c, transform.d, (ttx + tw) / 2, (tty + th) / 2);\r\n        workingCanvasContext.translate(-(ttx + tw) / 2, -(tty + th) / 2);\r\n\r\n        workingCanvasContext.drawImage(this._domImage, sx, sy, sw, sh, ttx, tty, tw, th);\r\n        workingCanvasContext.restore();\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        let x, y, width, height;\r\n        if (this.cellId == -1) {\r\n            x = this._sourceLeft;\r\n            y = this._sourceTop;\r\n\r\n            width = this._sourceWidth ? this._sourceWidth : this._imageWidth;\r\n            height = this._sourceHeight ? this._sourceHeight : this._imageHeight;\r\n        } else {\r\n            const rowCount = this._domImage.naturalWidth / this.cellWidth;\r\n            const column = (this.cellId / rowCount) >> 0;\r\n            const row = this.cellId % rowCount;\r\n\r\n            x = this.cellWidth * row;\r\n            y = this.cellHeight * column;\r\n            width = this.cellWidth;\r\n            height = this.cellHeight;\r\n        }\r\n\r\n        this._prepareWorkingCanvasForOpaqueDetection();\r\n\r\n        this._applyStates(context);\r\n        if (this._loaded) {\r\n            switch (this._stretch) {\r\n                case Image.STRETCH_NONE:\r\n                    this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n                    break;\r\n                case Image.STRETCH_FILL:\r\n                    this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n                    break;\r\n                case Image.STRETCH_UNIFORM: {\r\n                    const hRatio = this._currentMeasure.width / width;\r\n                    const vRatio = this._currentMeasure.height / height;\r\n                    const ratio = Math.min(hRatio, vRatio);\r\n                    const centerX = (this._currentMeasure.width - width * ratio) / 2;\r\n                    const centerY = (this._currentMeasure.height - height * ratio) / 2;\r\n\r\n                    this._drawImage(context, x, y, width, height, this._currentMeasure.left + centerX, this._currentMeasure.top + centerY, width * ratio, height * ratio);\r\n                    break;\r\n                }\r\n                case Image.STRETCH_EXTEND:\r\n                    this._drawImage(context, x, y, width, height, this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n                    break;\r\n                case Image.STRETCH_NINE_PATCH:\r\n                    this._renderNinePatch(context, x, y, width, height);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    private _renderNinePatch(context: ICanvasRenderingContext, sx: number, sy: number, sw: number, sh: number): void {\r\n        const idealRatio = this.host.idealWidth\r\n            ? this._width.getValue(this.host) / this.host.idealWidth\r\n            : this.host.idealHeight\r\n              ? this._height.getValue(this.host) / this.host.idealHeight\r\n              : 1;\r\n        const leftWidth = this._sliceLeft;\r\n        const topHeight = this._sliceTop;\r\n        const bottomHeight = sh - this._sliceBottom;\r\n        const rightWidth = sw - this._sliceRight;\r\n        const centerWidth = this._sliceRight - this._sliceLeft;\r\n        const centerHeight = this._sliceBottom - this._sliceTop;\r\n        const leftWidthAdjusted = Math.round(leftWidth * idealRatio);\r\n        const topHeightAdjusted = Math.round(topHeight * idealRatio);\r\n        const bottomHeightAdjusted = Math.round(bottomHeight * idealRatio);\r\n        const rightWidthAdjusted = Math.round(rightWidth * idealRatio);\r\n        const targetCenterWidth = Math.round(this._currentMeasure.width) - rightWidthAdjusted - leftWidthAdjusted + 2;\r\n        const targetCenterHeight = Math.round(this._currentMeasure.height) - bottomHeightAdjusted - topHeightAdjusted + 2;\r\n        const centerLeftOffset = Math.round(this._currentMeasure.left) + leftWidthAdjusted - 1;\r\n        const centerTopOffset = Math.round(this._currentMeasure.top) + topHeightAdjusted - 1;\r\n        const rightOffset = Math.round(this._currentMeasure.left + this._currentMeasure.width) - rightWidthAdjusted;\r\n        const bottomOffset = Math.round(this._currentMeasure.top + this._currentMeasure.height) - bottomHeightAdjusted;\r\n\r\n        //Top Left\r\n        this._drawImage(context, sx, sy, leftWidth, topHeight, this._currentMeasure.left, this._currentMeasure.top, leftWidthAdjusted, topHeightAdjusted);\r\n        //Top\r\n        this._drawImage(context, sx + this._sliceLeft, sy, centerWidth, topHeight, centerLeftOffset + 1, this._currentMeasure.top, targetCenterWidth - 2, topHeightAdjusted);\r\n        //Top Right\r\n        this._drawImage(context, sx + this._sliceRight, sy, rightWidth, topHeight, rightOffset, this._currentMeasure.top, rightWidthAdjusted, topHeightAdjusted);\r\n        //Left\r\n        this._drawImage(context, sx, sy + this._sliceTop, leftWidth, centerHeight, this._currentMeasure.left, centerTopOffset + 1, leftWidthAdjusted, targetCenterHeight - 2);\r\n        // Center\r\n        this._drawImage(\r\n            context,\r\n            sx + this._sliceLeft,\r\n            sy + this._sliceTop,\r\n            centerWidth,\r\n            centerHeight,\r\n            centerLeftOffset + 1,\r\n            centerTopOffset + 1,\r\n            targetCenterWidth - 2,\r\n            targetCenterHeight - 2\r\n        );\r\n        //Right\r\n        this._drawImage(\r\n            context,\r\n            sx + this._sliceRight,\r\n            sy + this._sliceTop,\r\n            rightWidth,\r\n            centerHeight,\r\n            rightOffset,\r\n            centerTopOffset + 1,\r\n            rightWidthAdjusted,\r\n            targetCenterHeight - 2\r\n        );\r\n        //Bottom Left\r\n        this._drawImage(context, sx, sy + this._sliceBottom, leftWidth, bottomHeight, this._currentMeasure.left, bottomOffset, leftWidthAdjusted, bottomHeightAdjusted);\r\n        //Bottom\r\n        this._drawImage(\r\n            context,\r\n            sx + this.sliceLeft,\r\n            sy + this._sliceBottom,\r\n            centerWidth,\r\n            bottomHeight,\r\n            centerLeftOffset + 1,\r\n            bottomOffset,\r\n            targetCenterWidth - 2,\r\n            bottomHeightAdjusted\r\n        );\r\n        //Bottom Right\r\n        this._drawImage(context, sx + this._sliceRight, sy + this._sliceBottom, rightWidth, bottomHeight, rightOffset, bottomOffset, rightWidthAdjusted, bottomHeightAdjusted);\r\n    }\r\n\r\n    public override dispose() {\r\n        super.dispose();\r\n        this.onImageLoadedObservable.clear();\r\n        this.onSVGAttributesComputedObservable.clear();\r\n        this._removeCacheUsage(this._source);\r\n    }\r\n\r\n    // Static\r\n    /** STRETCH_NONE */\r\n    public static readonly STRETCH_NONE = 0;\r\n    /** STRETCH_FILL */\r\n    public static readonly STRETCH_FILL = 1;\r\n    /** STRETCH_UNIFORM */\r\n    public static readonly STRETCH_UNIFORM = 2;\r\n    /** STRETCH_EXTEND */\r\n    public static readonly STRETCH_EXTEND = 3;\r\n    /** NINE_PATCH */\r\n    public static readonly STRETCH_NINE_PATCH = 4;\r\n}\r\nRegisterClass(\"BABYLON.GUI.Image\", Image);\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Rectangle } from \"./rectangle\";\r\nimport { Control } from \"./control\";\r\nimport { TextBlock } from \"./textBlock\";\r\nimport { Image } from \"./image\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to create 2D buttons\r\n */\r\nexport class Button extends Rectangle {\r\n    /**\r\n     * Function called to generate a pointer enter animation\r\n     */\r\n    public pointerEnterAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer out animation\r\n     */\r\n    public pointerOutAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer down animation\r\n     */\r\n    public pointerDownAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer up animation\r\n     */\r\n    public pointerUpAnimation: () => void;\r\n\r\n    private _image: Nullable<Image>;\r\n    /**\r\n     * Returns the image part of the button (if any)\r\n     */\r\n    public get image(): Nullable<Image> {\r\n        return this._image;\r\n    }\r\n\r\n    private _textBlock: Nullable<TextBlock>;\r\n    /**\r\n     * Returns the TextBlock part of the button (if any)\r\n     */\r\n    public get textBlock(): Nullable<TextBlock> {\r\n        return this._textBlock;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Button\r\n     * @param name defines the name of the button\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n\r\n        this.thickness = 1;\r\n        this.isPointerBlocker = true;\r\n\r\n        let alphaStore: Nullable<number> = null;\r\n\r\n        this.pointerEnterAnimation = () => {\r\n            alphaStore = this.alpha;\r\n            this.alpha -= 0.1;\r\n        };\r\n\r\n        this.pointerOutAnimation = () => {\r\n            if (alphaStore !== null) {\r\n                this.alpha = alphaStore;\r\n            }\r\n        };\r\n\r\n        this.pointerDownAnimation = () => {\r\n            this.scaleX -= 0.05;\r\n            this.scaleY -= 0.05;\r\n        };\r\n\r\n        this.pointerUpAnimation = () => {\r\n            this.scaleX += 0.05;\r\n            this.scaleY += 0.05;\r\n        };\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Button\";\r\n    }\r\n\r\n    // While being a container, the button behaves like a control.\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _processPicking(x: number, y: number, pi: PointerInfoBase, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): boolean {\r\n        if (!this._isEnabled || !this.isHitTestVisible || !this.isVisible || this.notRenderable) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.contains(x, y)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.delegatePickingToChildren) {\r\n            let contains = false;\r\n            for (let index = this._children.length - 1; index >= 0; index--) {\r\n                const child = this._children[index];\r\n                if (child.isEnabled && child.isHitTestVisible && child.isVisible && !child.notRenderable && child.contains(x, y)) {\r\n                    contains = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!contains) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerEnter(target: Control, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerEnter(target, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.isReadOnly && this.pointerEnterAnimation) {\r\n            this.pointerEnterAnimation();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerOut(target: Control, pi: PointerInfoBase, force = false): void {\r\n        if (!this.isReadOnly && this.pointerOutAnimation) {\r\n            this.pointerOutAnimation();\r\n        }\r\n\r\n        super._onPointerOut(target, pi, force);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.isReadOnly && this.pointerDownAnimation) {\r\n            this.pointerDownAnimation();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    protected override _getRectangleFill(context: ICanvasRenderingContext) {\r\n        if (this.isEnabled) {\r\n            return this._getBackgroundColor(context);\r\n        } else {\r\n            return this._disabledColor;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean, pi: PointerInfoBase): void {\r\n        if (!this.isReadOnly && this.pointerUpAnimation) {\r\n            this.pointerUpAnimation();\r\n        }\r\n\r\n        super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick, pi);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current button\r\n     * @param serializationObject defines the JSON serialized object\r\n     * @param force force serialization even if isSerializable === false\r\n     */\r\n    public override serialize(serializationObject: any, force: boolean) {\r\n        super.serialize(serializationObject, force);\r\n        if (!this.isSerializable && !force) {\r\n            return;\r\n        }\r\n\r\n        if (this._textBlock) {\r\n            serializationObject.textBlockName = this._textBlock.name;\r\n        }\r\n        if (this._image) {\r\n            serializationObject.imageName = this._image.name;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture) {\r\n        super._parseFromContent(serializedObject, host);\r\n\r\n        if (serializedObject.textBlockName) {\r\n            this._textBlock = this.getChildByName(serializedObject.textBlockName) as Nullable<TextBlock>;\r\n        }\r\n\r\n        if (serializedObject.imageName) {\r\n            this._image = this.getChildByName(serializedObject.imageName) as Nullable<Image>;\r\n        }\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new button made with an image and a text\r\n     * @param name defines the name of the button\r\n     * @param text defines the text of the button\r\n     * @param imageUrl defines the url of the image\r\n     * @returns a new Button\r\n     */\r\n    public static CreateImageButton(name: string, text: string, imageUrl: string): Button {\r\n        const result = new this(name);\r\n\r\n        // Adding text\r\n        const textBlock = new TextBlock(name + \"_button\", text);\r\n        textBlock.textWrapping = true;\r\n        textBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n        textBlock.paddingLeft = \"20%\";\r\n        result.addControl(textBlock);\r\n\r\n        // Adding image\r\n        const iconImage = new Image(name + \"_icon\", imageUrl);\r\n        iconImage.width = \"20%\";\r\n        iconImage.stretch = Image.STRETCH_UNIFORM;\r\n        iconImage.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        result.addControl(iconImage);\r\n\r\n        // Store\r\n        result._image = iconImage;\r\n        result._textBlock = textBlock;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new button made with an image\r\n     * @param name defines the name of the button\r\n     * @param imageUrl defines the url of the image\r\n     * @returns a new Button\r\n     */\r\n    public static CreateImageOnlyButton(name: string, imageUrl: string): Button {\r\n        const result = new this(name);\r\n\r\n        // Adding image\r\n        const iconImage = new Image(name + \"_icon\", imageUrl);\r\n        iconImage.stretch = Image.STRETCH_FILL;\r\n        iconImage.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        result.addControl(iconImage);\r\n\r\n        // Store\r\n        result._image = iconImage;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new button made with a text\r\n     * @param name defines the name of the button\r\n     * @param text defines the text of the button\r\n     * @returns a new Button\r\n     */\r\n    public static CreateSimpleButton(name: string, text: string): Button {\r\n        const result = new this(name);\r\n\r\n        // Adding text\r\n        const textBlock = new TextBlock(name + \"_button\", text);\r\n        textBlock.textWrapping = true;\r\n        textBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n        result.addControl(textBlock);\r\n\r\n        // Store\r\n        result._textBlock = textBlock;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new button made with an image and a centered text\r\n     * @param name defines the name of the button\r\n     * @param text defines the text of the button\r\n     * @param imageUrl defines the url of the image\r\n     * @returns a new Button\r\n     */\r\n    public static CreateImageWithCenterTextButton(name: string, text: string, imageUrl: string): Button {\r\n        const result = new this(name);\r\n\r\n        // Adding image\r\n        const iconImage = new Image(name + \"_icon\", imageUrl);\r\n        iconImage.stretch = Image.STRETCH_FILL;\r\n        result.addControl(iconImage);\r\n\r\n        // Adding text\r\n        const textBlock = new TextBlock(name + \"_button\", text);\r\n        textBlock.textWrapping = true;\r\n        textBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n        result.addControl(textBlock);\r\n\r\n        // Store\r\n        result._image = iconImage;\r\n        result._textBlock = textBlock;\r\n\r\n        return result;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Button\", Button);\r\n", "import { Container } from \"./container\";\r\nimport type { Measure } from \"../measure\";\r\nimport { Control } from \"./control\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Class used to create a 2D stack panel container\r\n */\r\nexport class StackPanel extends Container {\r\n    private _isVertical = true;\r\n    private _manualWidth = false;\r\n    private _manualHeight = false;\r\n    private _doNotTrackManualChanges = false;\r\n    private _spacing = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that layout warnings should be ignored\r\n     */\r\n    @serialize()\r\n    public ignoreLayoutWarnings = false;\r\n\r\n    /** Gets or sets a boolean indicating if the stack panel is vertical or horizontal*/\r\n    @serialize()\r\n    public get isVertical(): boolean {\r\n        return this._isVertical;\r\n    }\r\n\r\n    public set isVertical(value: boolean) {\r\n        if (this._isVertical === value) {\r\n            return;\r\n        }\r\n\r\n        this._isVertical = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the spacing (in pixels) between each child.\r\n     */\r\n    @serialize()\r\n    public get spacing(): number {\r\n        return this._spacing;\r\n    }\r\n\r\n    public set spacing(value: number) {\r\n        if (this._spacing === value) {\r\n            return;\r\n        }\r\n\r\n        this._spacing = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets panel width.\r\n     * This value should not be set when in horizontal mode as it will be computed automatically\r\n     */\r\n    @serialize()\r\n    public override set width(value: string | number) {\r\n        if (!this._doNotTrackManualChanges) {\r\n            this._manualWidth = true;\r\n        }\r\n\r\n        if (this._width.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._width.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    public override get width(): string | number {\r\n        return this._width.toString(this._host);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets panel height.\r\n     * This value should not be set when in vertical mode as it will be computed automatically\r\n     */\r\n    @serialize()\r\n    public override set height(value: string | number) {\r\n        if (!this._doNotTrackManualChanges) {\r\n            this._manualHeight = true;\r\n        }\r\n\r\n        if (this._height.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._height.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    public override get height(): string | number {\r\n        return this._height.toString(this._host);\r\n    }\r\n\r\n    /**\r\n     * Creates a new StackPanel\r\n     * @param name defines control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"StackPanel\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _preMeasure(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        for (const child of this._children) {\r\n            if (this._isVertical) {\r\n                child.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n            } else {\r\n                child.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n            }\r\n        }\r\n\r\n        super._preMeasure(parentMeasure, context);\r\n    }\r\n\r\n    protected override _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._additionalProcessing(parentMeasure, context);\r\n\r\n        this._measureForChildren.copyFrom(parentMeasure);\r\n\r\n        this._measureForChildren.left = this._currentMeasure.left;\r\n        this._measureForChildren.top = this._currentMeasure.top;\r\n\r\n        if (!this.isVertical || this._manualWidth) {\r\n            this._measureForChildren.width = this._currentMeasure.width;\r\n        }\r\n\r\n        if (this.isVertical || this._manualHeight) {\r\n            this._measureForChildren.height = this._currentMeasure.height;\r\n        }\r\n    }\r\n\r\n    protected override _postMeasure(): void {\r\n        let stackWidth = 0;\r\n        let stackHeight = 0;\r\n        const childrenCount = this._children.length;\r\n        for (let index = 0; index < childrenCount; index++) {\r\n            const child = this._children[index];\r\n            if (!child.isVisible || child.notRenderable) {\r\n                continue;\r\n            }\r\n\r\n            if (this._isVertical) {\r\n                const top = stackHeight + \"px\";\r\n                if (child.top !== top) {\r\n                    child.top = top;\r\n                    this._rebuildLayout = true;\r\n                    child._top.ignoreAdaptiveScaling = true;\r\n                }\r\n\r\n                if (!this.ignoreLayoutWarnings && !child.isDimensionFullyDefined(\"height\")) {\r\n                    Logger.Warn(`Control (Name:${child.name}, UniqueId:${child.uniqueId}) is using height in percentage mode inside a vertical StackPanel`, 1);\r\n                } else {\r\n                    stackHeight += child._currentMeasure.height + child._paddingTopInPixels + child._paddingBottomInPixels + (index < childrenCount - 1 ? this._spacing : 0);\r\n                }\r\n            } else {\r\n                const left = stackWidth + \"px\";\r\n                if (child.left !== left) {\r\n                    child.left = left;\r\n                    this._rebuildLayout = true;\r\n                    child._left.ignoreAdaptiveScaling = true;\r\n                }\r\n\r\n                if (!this.ignoreLayoutWarnings && !child.isDimensionFullyDefined(\"width\")) {\r\n                    Logger.Warn(`Control (Name:${child.name}, UniqueId:${child.uniqueId}) is using width in percentage mode inside a horizontal StackPanel`, 1);\r\n                } else {\r\n                    stackWidth += child._currentMeasure.width + child._paddingLeftInPixels + child._paddingRightInPixels + (index < childrenCount - 1 ? this._spacing : 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        stackWidth += this._paddingLeftInPixels + this._paddingRightInPixels;\r\n        stackHeight += this._paddingTopInPixels + this._paddingBottomInPixels;\r\n\r\n        this._doNotTrackManualChanges = true;\r\n\r\n        // Let stack panel width or height default to stackHeight and stackWidth if dimensions are not specified.\r\n        // User can now define their own height and width for stack panel.\r\n\r\n        let panelWidthChanged = false;\r\n        let panelHeightChanged = false;\r\n\r\n        if ((!this._manualHeight || this.adaptHeightToChildren) && this._isVertical) {\r\n            // do not specify height if strictly defined by user\r\n            const previousHeight = this.height;\r\n            this.height = stackHeight + \"px\";\r\n            panelHeightChanged = previousHeight !== this.height || !this._height.ignoreAdaptiveScaling;\r\n        }\r\n        if ((!this._manualWidth || this.adaptWidthToChildren) && !this._isVertical) {\r\n            // do not specify width if strictly defined by user\r\n            const previousWidth = this.width;\r\n            this.width = stackWidth + \"px\";\r\n            panelWidthChanged = previousWidth !== this.width || !this._width.ignoreAdaptiveScaling;\r\n        }\r\n\r\n        if (panelHeightChanged) {\r\n            this._height.ignoreAdaptiveScaling = true;\r\n        }\r\n\r\n        if (panelWidthChanged) {\r\n            this._width.ignoreAdaptiveScaling = true;\r\n        }\r\n\r\n        this._doNotTrackManualChanges = false;\r\n\r\n        if (panelWidthChanged || panelHeightChanged) {\r\n            this._rebuildLayout = true;\r\n        }\r\n\r\n        super._postMeasure();\r\n    }\r\n\r\n    private _getManualDim(dim: \"width\" | \"height\") {\r\n        if (dim === \"width\") {\r\n            return this._manualWidth;\r\n        } else {\r\n            return this._manualHeight;\r\n        }\r\n    }\r\n\r\n    public override isDimensionFullyDefined(dim: \"width\" | \"height\"): boolean {\r\n        if (dim === \"height\" ? this.isVertical : !this.isVertical && !this._getManualDim(dim)) {\r\n            for (const child of this._children) {\r\n                if (!child.isDimensionFullyDefined(dim)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return this.getDimension(dim).isPixel || this._getAdaptDimTo(dim);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current control\r\n     * @param serializationObject defined the JSON serialized object\r\n     * @param force force serialization even if isSerializable === false\r\n     */\r\n    public override serialize(serializationObject: any, force: boolean) {\r\n        super.serialize(serializationObject, force);\r\n        if (!this.isSerializable && !force) {\r\n            return;\r\n        }\r\n        serializationObject.manualWidth = this._manualWidth;\r\n        serializationObject.manualHeight = this._manualHeight;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture) {\r\n        this._manualWidth = serializedObject.manualWidth;\r\n        this._manualHeight = serializedObject.manualHeight;\r\n\r\n        super._parseFromContent(serializedObject, host);\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.StackPanel\", StackPanel);\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { StackPanel } from \"./stackPanel\";\r\nimport { TextBlock } from \"./textBlock\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to represent a 2D checkbox\r\n */\r\nexport class Checkbox extends Control {\r\n    private _isChecked = false;\r\n    private _background = \"black\";\r\n    private _checkSizeRatio = 0.8;\r\n    private _thickness = 1;\r\n\r\n    /** Gets or sets border thickness  */\r\n    @serialize()\r\n    public get thickness(): number {\r\n        return this._thickness;\r\n    }\r\n\r\n    public set thickness(value: number) {\r\n        if (this._thickness === value) {\r\n            return;\r\n        }\r\n\r\n        this._thickness = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Observable raised when isChecked property changes\r\n     */\r\n    public onIsCheckedChangedObservable = new Observable<boolean>();\r\n\r\n    /** Gets or sets a value indicating the ratio between overall size and check size */\r\n    @serialize()\r\n    public get checkSizeRatio(): number {\r\n        return this._checkSizeRatio;\r\n    }\r\n\r\n    public set checkSizeRatio(value: number) {\r\n        value = Math.max(Math.min(1, value), 0);\r\n\r\n        if (this._checkSizeRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._checkSizeRatio = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the checkbox is checked or not */\r\n    @serialize()\r\n    public get isChecked(): boolean {\r\n        return this._isChecked;\r\n    }\r\n\r\n    public set isChecked(value: boolean) {\r\n        if (this._isChecked === value) {\r\n            return;\r\n        }\r\n\r\n        this._isChecked = value;\r\n        this._markAsDirty();\r\n\r\n        this.onIsCheckedChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Creates a new CheckBox\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n        this.isPointerBlocker = true;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Checkbox\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        const actualWidth = this._currentMeasure.width - this._thickness;\r\n        const actualHeight = this._currentMeasure.height - this._thickness;\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\r\n        context.fillRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, actualWidth, actualHeight);\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        if (this._isChecked) {\r\n            // Color is white if not set\r\n            context.fillStyle = this._isEnabled ? (this.color ? this.color : \"#ffffff\") : this._disabledColorItem;\r\n            const offsetWidth = actualWidth * this._checkSizeRatio;\r\n            const offsetHeight = actualHeight * this._checkSizeRatio;\r\n\r\n            context.fillRect(\r\n                this._currentMeasure.left + this._thickness / 2 + (actualWidth - offsetWidth) / 2,\r\n                this._currentMeasure.top + this._thickness / 2 + (actualHeight - offsetHeight) / 2,\r\n                offsetWidth,\r\n                offsetHeight\r\n            );\r\n        }\r\n\r\n        context.strokeStyle = this.color;\r\n        context.lineWidth = this._thickness;\r\n\r\n        context.strokeRect(this._currentMeasure.left + this._thickness / 2, this._currentMeasure.top + this._thickness / 2, actualWidth, actualHeight);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.isReadOnly) {\r\n            this.isChecked = !this.isChecked;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Utility function to easily create a checkbox with a header\r\n     * @param title defines the label to use for the header\r\n     * @param onValueChanged defines the callback to call when value changes\r\n     * @returns a StackPanel containing the checkbox and a textBlock\r\n     */\r\n    public static AddCheckBoxWithHeader(title: string, onValueChanged: (value: boolean) => void): StackPanel {\r\n        const panel = new StackPanel();\r\n        panel.isVertical = false;\r\n        panel.height = \"30px\";\r\n\r\n        const checkbox = new Checkbox();\r\n        checkbox.width = \"20px\";\r\n        checkbox.height = \"20px\";\r\n        checkbox.isChecked = true;\r\n        checkbox.color = \"green\";\r\n        checkbox.onIsCheckedChangedObservable.add(onValueChanged);\r\n        panel.addControl(checkbox);\r\n\r\n        const header = new TextBlock();\r\n        header.text = title;\r\n        header.width = \"180px\";\r\n        header.paddingLeft = \"5px\";\r\n        header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        header.color = \"white\";\r\n        panel.addControl(header);\r\n\r\n        return panel;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Checkbox\", Checkbox);\r\n", "/** @internal */\r\nexport class TextWrapper {\r\n    private _text: string;\r\n    private _characters: string[] | undefined;\r\n\r\n    public get text(): string {\r\n        return this._characters ? this._characters.join(\"\") : this._text;\r\n    }\r\n\r\n    public set text(txt: string) {\r\n        this._text = txt;\r\n        this._characters = Array.from && Array.from(txt);\r\n    }\r\n\r\n    public get length(): number {\r\n        return this._characters ? this._characters.length : this._text.length;\r\n    }\r\n\r\n    public removePart(idxStart: number, idxEnd: number, insertTxt?: string): void {\r\n        this._text = this._text.slice(0, idxStart) + (insertTxt ? insertTxt : \"\") + this._text.slice(idxEnd);\r\n        if (this._characters) {\r\n            const newCharacters = insertTxt ? Array.from(insertTxt) : [];\r\n            this._characters.splice(idxStart, idxEnd - idxStart, ...newCharacters);\r\n        }\r\n    }\r\n\r\n    public charAt(idx: number): string {\r\n        return this._characters ? this._characters[idx] : this._text.charAt(idx);\r\n    }\r\n\r\n    public substr(from: number, length?: number): string {\r\n        if (this._characters) {\r\n            if (isNaN(from)) {\r\n                from = 0;\r\n            } else if (from >= 0) {\r\n                from = Math.min(from, this._characters.length);\r\n            } else {\r\n                from = this._characters.length + Math.max(from, -this._characters.length);\r\n            }\r\n            if (length === undefined) {\r\n                length = this._characters.length - from;\r\n            } else if (isNaN(length)) {\r\n                length = 0;\r\n            } else if (length < 0) {\r\n                length = 0;\r\n            }\r\n            const temp = [];\r\n            while (--length >= 0) {\r\n                temp[length] = this._characters[from + length];\r\n            }\r\n            return temp.join(\"\");\r\n        }\r\n\r\n        return this._text.substring(from, length ? length + from : undefined);\r\n    }\r\n\r\n    public substring(from: number, to?: number): string {\r\n        if (this._characters) {\r\n            if (isNaN(from)) {\r\n                from = 0;\r\n            } else if (from > this._characters.length) {\r\n                from = this._characters.length;\r\n            } else if (from < 0) {\r\n                from = 0;\r\n            }\r\n            if (to === undefined) {\r\n                to = this._characters.length;\r\n            } else if (isNaN(to)) {\r\n                to = 0;\r\n            } else if (to > this._characters.length) {\r\n                to = this._characters.length;\r\n            } else if (to < 0) {\r\n                to = 0;\r\n            }\r\n            const temp = [];\r\n            let idx = 0;\r\n            while (from < to) {\r\n                temp[idx++] = this._characters[from++];\r\n            }\r\n            return temp.join(\"\");\r\n        }\r\n\r\n        return this._text.substring(from, to);\r\n    }\r\n\r\n    public isWord(index: number): boolean {\r\n        const rWord = /\\w/g;\r\n        return this._characters ? this._characters[index].search(rWord) !== -1 : this._text.search(rWord) !== -1;\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\nimport type { ClipboardInfo } from \"core/Events/clipboardEvents\";\r\nimport { ClipboardEventTypes } from \"core/Events/clipboardEvents\";\r\nimport type { PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport type { VirtualKeyboard } from \"./virtualKeyboard\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { TextWrapper } from \"./textWrapper\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { IKeyboardEvent, IPointerEvent } from \"core/Events/deviceInputEvents\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to create input text control\r\n */\r\nexport class InputText extends Control {\r\n    protected _textWrapper: TextWrapper;\r\n    protected _placeholderText = \"\";\r\n    protected _background = \"#222222\";\r\n    protected _focusedBackground = \"#000000\";\r\n    protected _placeholderColor = \"gray\";\r\n    protected _thickness = 1;\r\n    protected _margin = new ValueAndUnit(10, ValueAndUnit.UNITMODE_PIXEL);\r\n    protected _autoStretchWidth = true;\r\n    protected _maxWidth = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);\r\n    /** the type of device that most recently focused the input: \"mouse\", \"touch\" or \"pen\" */\r\n    protected _focusedBy: string;\r\n    protected _blinkTimeout: number;\r\n    protected _blinkIsEven = false;\r\n    private _cursorOffset = 0;\r\n    protected _scrollLeft: Nullable<number>;\r\n    protected _textWidth: number;\r\n    protected _clickedCoordinate: Nullable<number>;\r\n    protected _deadKey = false;\r\n    protected _addKey = true;\r\n    protected _currentKey = \"\";\r\n    protected _isTextHighlightOn = false;\r\n    protected _textHighlightColor = \"#d5e0ff\";\r\n    protected _highligherOpacity = 0.4;\r\n    protected _highlightedText = \"\";\r\n    private _startHighlightIndex = 0;\r\n    private _endHighlightIndex = 0;\r\n    private _cursorIndex = -1;\r\n    private _outlineWidth: number = 0;\r\n    private _outlineColor: string = \"white\";\r\n    protected _onFocusSelectAll = false;\r\n    protected _isPointerDown = false;\r\n    protected _onClipboardObserver: Nullable<Observer<ClipboardInfo>>;\r\n    protected _onPointerDblTapObserver: Nullable<Observer<PointerInfo>>;\r\n\r\n    /** @internal */\r\n    public _connectedVirtualKeyboard: Nullable<VirtualKeyboard>;\r\n\r\n    /** Gets or sets a string representing the message displayed on mobile when the control gets the focus */\r\n    @serialize()\r\n    public promptMessage = \"Please enter text:\";\r\n    /** Force disable prompt on mobile device */\r\n    @serialize()\r\n    public disableMobilePrompt = false;\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    public get outlineWidth(): number {\r\n        return this._outlineWidth;\r\n    }\r\n\r\n    public set outlineWidth(value: number) {\r\n        if (this._outlineWidth === value) {\r\n            return;\r\n        }\r\n        this._outlineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    public get outlineColor(): string {\r\n        return this._outlineColor;\r\n    }\r\n\r\n    public set outlineColor(value: string) {\r\n        if (this._outlineColor === value) {\r\n            return;\r\n        }\r\n        this._outlineColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Observable raised when the text changes */\r\n    public onTextChangedObservable = new Observable<InputText>();\r\n    /** Observable raised just before an entered character is to be added */\r\n    public onBeforeKeyAddObservable = new Observable<InputText>();\r\n    /** Observable raised when the text is highlighted */\r\n    public onTextHighlightObservable = new Observable<InputText>();\r\n    /** Observable raised when copy event is triggered */\r\n    public onTextCopyObservable = new Observable<InputText>();\r\n    /** Observable raised when cut event is triggered */\r\n    public onTextCutObservable = new Observable<InputText>();\r\n    /** Observable raised when paste event is triggered */\r\n    public onTextPasteObservable = new Observable<InputText>();\r\n\r\n    /** Gets or sets the maximum width allowed by the control */\r\n    @serialize()\r\n    public get maxWidth(): string | number {\r\n        return this._maxWidth.toString(this._host);\r\n    }\r\n\r\n    /** Gets the maximum width allowed by the control in pixels */\r\n    public get maxWidthInPixels(): number {\r\n        return this._maxWidth.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set maxWidth(value: string | number) {\r\n        if (this._maxWidth.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._maxWidth.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the text highlighter transparency; default: 0.4 */\r\n    @serialize()\r\n    public get highligherOpacity(): number {\r\n        return this._highligherOpacity;\r\n    }\r\n\r\n    public set highligherOpacity(value: number) {\r\n        if (this._highligherOpacity === value) {\r\n            return;\r\n        }\r\n        this._highligherOpacity = value;\r\n        this._markAsDirty();\r\n    }\r\n    /** Gets or sets a boolean indicating whether to select complete text by default on input focus */\r\n    @serialize()\r\n    public get onFocusSelectAll(): boolean {\r\n        return this._onFocusSelectAll;\r\n    }\r\n\r\n    public set onFocusSelectAll(value: boolean) {\r\n        if (this._onFocusSelectAll === value) {\r\n            return;\r\n        }\r\n\r\n        this._onFocusSelectAll = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the text hightlight color */\r\n    @serialize()\r\n    public get textHighlightColor(): string {\r\n        return this._textHighlightColor;\r\n    }\r\n\r\n    public set textHighlightColor(value: string) {\r\n        if (this._textHighlightColor === value) {\r\n            return;\r\n        }\r\n        this._textHighlightColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets control margin */\r\n    @serialize()\r\n    public get margin(): string {\r\n        return this._margin.toString(this._host);\r\n    }\r\n\r\n    /** Gets control margin in pixels */\r\n    public get marginInPixels(): number {\r\n        return this._margin.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set margin(value: string) {\r\n        if (this._margin.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._margin.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the control can auto stretch its width to adapt to the text */\r\n    @serialize()\r\n    public get autoStretchWidth(): boolean {\r\n        return this._autoStretchWidth;\r\n    }\r\n\r\n    public set autoStretchWidth(value: boolean) {\r\n        if (this._autoStretchWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoStretchWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets border thickness */\r\n    @serialize()\r\n    public get thickness(): number {\r\n        return this._thickness;\r\n    }\r\n\r\n    public set thickness(value: number) {\r\n        if (this._thickness === value) {\r\n            return;\r\n        }\r\n\r\n        this._thickness = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the background color when focused */\r\n    @serialize()\r\n    public get focusedBackground(): string {\r\n        return this._focusedBackground;\r\n    }\r\n\r\n    public set focusedBackground(value: string) {\r\n        if (this._focusedBackground === value) {\r\n            return;\r\n        }\r\n\r\n        this._focusedBackground = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the background color when focused */\r\n    public override set focusedColor(value: string) {\r\n        if (this._focusedColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._focusedColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the placeholder color */\r\n    @serialize()\r\n    public get placeholderColor(): string {\r\n        return this._placeholderColor;\r\n    }\r\n\r\n    public set placeholderColor(value: string) {\r\n        if (this._placeholderColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._placeholderColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the text displayed when the control is empty */\r\n    @serialize()\r\n    public get placeholderText(): string {\r\n        return this._placeholderText;\r\n    }\r\n\r\n    public set placeholderText(value: string) {\r\n        if (this._placeholderText === value) {\r\n            return;\r\n        }\r\n        this._placeholderText = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the dead key. 0 to disable. */\r\n    @serialize()\r\n    public get deadKey(): boolean {\r\n        return this._deadKey;\r\n    }\r\n\r\n    public set deadKey(flag: boolean) {\r\n        this._deadKey = flag;\r\n    }\r\n\r\n    /** Gets or sets the highlight text */\r\n    public get highlightedText(): string {\r\n        return this._highlightedText;\r\n    }\r\n    public set highlightedText(text: string) {\r\n        if (this._highlightedText === text) {\r\n            return;\r\n        }\r\n        this._highlightedText = text;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets if the current key should be added */\r\n    public get addKey(): boolean {\r\n        return this._addKey;\r\n    }\r\n\r\n    public set addKey(flag: boolean) {\r\n        this._addKey = flag;\r\n    }\r\n\r\n    /** Gets or sets the value of the current key being entered */\r\n    public get currentKey(): string {\r\n        return this._currentKey;\r\n    }\r\n\r\n    public set currentKey(key: string) {\r\n        this._currentKey = key;\r\n    }\r\n\r\n    /** Gets or sets the text displayed in the control */\r\n    @serialize()\r\n    public get text(): string {\r\n        return this._textWrapper.text;\r\n    }\r\n\r\n    public set text(value: string) {\r\n        const valueAsString = value.toString(); // Forcing convertion\r\n\r\n        if (!this._textWrapper) {\r\n            this._textWrapper = new TextWrapper();\r\n        }\r\n\r\n        if (this._textWrapper.text === valueAsString) {\r\n            return;\r\n        }\r\n        this._textWrapper.text = valueAsString;\r\n        this._textHasChanged();\r\n    }\r\n\r\n    protected _textHasChanged(): void {\r\n        this._markAsDirty();\r\n        this.onTextChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    protected override _applyStates(context: ICanvasRenderingContext): void {\r\n        super._applyStates(context);\r\n        if (this.outlineWidth) {\r\n            context.lineWidth = this.outlineWidth;\r\n            context.strokeStyle = this.outlineColor;\r\n        }\r\n    }\r\n\r\n    /** Gets or sets control width */\r\n    @serialize()\r\n    public override get width(): string | number {\r\n        return this._width.toString(this._host);\r\n    }\r\n\r\n    public override set width(value: string | number) {\r\n        if (this._width.toString(this._host) === value && !this._autoStretchWidth) {\r\n            return;\r\n        }\r\n\r\n        if (this._width.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n\r\n        this.autoStretchWidth = false;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputText\r\n     * @param name defines the control name\r\n     * @param text defines the text of the control\r\n     */\r\n    constructor(\r\n        public override name?: string,\r\n        text: string = \"\"\r\n    ) {\r\n        super(name);\r\n\r\n        this.text = text;\r\n        this.isPointerBlocker = true;\r\n        this._focusedColor = \"white\";\r\n    }\r\n\r\n    /** @internal */\r\n    public override onBlur(): void {\r\n        this._isFocused = false;\r\n        this._scrollLeft = null;\r\n        this._cursorOffset = 0;\r\n        clearTimeout(this._blinkTimeout);\r\n        this._markAsDirty();\r\n\r\n        this.onBlurObservable.notifyObservers(this);\r\n\r\n        this._host.unRegisterClipboardEvents();\r\n        if (this._onClipboardObserver) {\r\n            this._host.onClipboardObservable.remove(this._onClipboardObserver);\r\n        }\r\n        const scene = this._host.getScene();\r\n        if (this._onPointerDblTapObserver && scene) {\r\n            scene.onPointerObservable.remove(this._onPointerDblTapObserver);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override onFocus(): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n        this._scrollLeft = null;\r\n        this._isFocused = true;\r\n        this._blinkIsEven = false;\r\n        this._cursorOffset = 0;\r\n        this._markAsDirty();\r\n\r\n        this.onFocusObservable.notifyObservers(this as Control);\r\n\r\n        if (this._focusedBy === \"touch\" && !this.disableMobilePrompt) {\r\n            const value = prompt(this.promptMessage);\r\n\r\n            if (value !== null) {\r\n                this.text = value;\r\n            }\r\n            this._host.focusedControl = null;\r\n            return;\r\n        }\r\n\r\n        this._host.registerClipboardEvents();\r\n\r\n        this._onClipboardObserver = this._host.onClipboardObservable.add((clipboardInfo) => {\r\n            // process clipboard event, can be configured.\r\n            switch (clipboardInfo.type) {\r\n                case ClipboardEventTypes.COPY:\r\n                    this._onCopyText(clipboardInfo.event);\r\n                    this.onTextCopyObservable.notifyObservers(this);\r\n                    break;\r\n                case ClipboardEventTypes.CUT:\r\n                    this._onCutText(clipboardInfo.event);\r\n                    this.onTextCutObservable.notifyObservers(this);\r\n                    break;\r\n                case ClipboardEventTypes.PASTE:\r\n                    this._onPasteText(clipboardInfo.event);\r\n                    this.onTextPasteObservable.notifyObservers(this);\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n        });\r\n\r\n        const scene = this._host.getScene();\r\n        if (scene) {\r\n            //register the pointer double tap event\r\n            this._onPointerDblTapObserver = scene.onPointerObservable.add((pointerInfo) => {\r\n                if (!this._isFocused) {\r\n                    return;\r\n                }\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                    this._processDblClick(pointerInfo);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this._onFocusSelectAll) {\r\n            this.selectAllText();\r\n        }\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"InputText\";\r\n    }\r\n\r\n    /**\r\n     * Function called to get the list of controls that should not steal the focus from this control\r\n     * @returns an array of controls\r\n     */\r\n    public override keepsFocusWith(): Nullable<Control[]> {\r\n        if (!this._connectedVirtualKeyboard) {\r\n            return null;\r\n        }\r\n        return [this._connectedVirtualKeyboard];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public processKey(keyCode: number, key?: string, evt?: IKeyboardEvent) {\r\n        if (this.isReadOnly) {\r\n            return;\r\n        }\r\n\r\n        //return if clipboard event keys (i.e -ctr/cmd + c,v,x)\r\n        if (evt && (evt.ctrlKey || evt.metaKey) && (keyCode === 67 || keyCode === 86 || keyCode === 88)) {\r\n            return;\r\n        }\r\n\r\n        //select all\r\n        if (evt && (evt.ctrlKey || evt.metaKey) && keyCode === 65) {\r\n            this.selectAllText();\r\n            evt.preventDefault();\r\n            return;\r\n        }\r\n        // Specific cases\r\n        switch (keyCode) {\r\n            case 32: //SPACE\r\n                key = \" \"; //ie11 key for space is \"Spacebar\"\r\n                break;\r\n            case 191: //SLASH\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n                break;\r\n            case 8: // BACKSPACE\r\n                if (this._textWrapper.text && this._textWrapper.length > 0) {\r\n                    //delete the highlighted text\r\n                    if (this.isTextHighlightOn) {\r\n                        this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\r\n                        this._textHasChanged();\r\n                        this.isTextHighlightOn = false;\r\n                        this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n                        this._blinkIsEven = false;\r\n                        if (evt) {\r\n                            evt.preventDefault();\r\n                        }\r\n                        return;\r\n                    }\r\n                    //delete single character\r\n                    if (this._cursorOffset === 0) {\r\n                        this.text = this._textWrapper.substring(0, this._textWrapper.length - 1);\r\n                    } else {\r\n                        const deletePosition = this._textWrapper.length - this._cursorOffset;\r\n                        if (deletePosition > 0) {\r\n                            this._textWrapper.removePart(deletePosition - 1, deletePosition);\r\n                            this._textHasChanged();\r\n                        }\r\n                    }\r\n                }\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n                return;\r\n            case 46: // DELETE\r\n                if (this.isTextHighlightOn) {\r\n                    this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\r\n                    this._textHasChanged();\r\n                    this.isTextHighlightOn = false;\r\n                    this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n                    if (evt) {\r\n                        evt.preventDefault();\r\n                    }\r\n                    return;\r\n                }\r\n                if (this._textWrapper.text && this._textWrapper.length > 0 && this._cursorOffset > 0) {\r\n                    const deletePosition = this._textWrapper.length - this._cursorOffset;\r\n                    this._textWrapper.removePart(deletePosition, deletePosition + 1);\r\n                    this._textHasChanged();\r\n                    this._cursorOffset--;\r\n                }\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n                return;\r\n            case 13: // RETURN\r\n                this._host.focusedControl = null;\r\n                this.isTextHighlightOn = false;\r\n                return;\r\n            case 35: // END\r\n                this._cursorOffset = 0;\r\n                this._blinkIsEven = false;\r\n                this.isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            case 36: // HOME\r\n                this._cursorOffset = this._textWrapper.length;\r\n                this._blinkIsEven = false;\r\n                this.isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            case 37: // LEFT\r\n                this._cursorOffset++;\r\n                if (this._cursorOffset > this._textWrapper.length) {\r\n                    this._cursorOffset = this._textWrapper.length;\r\n                }\r\n\r\n                if (evt && evt.shiftKey) {\r\n                    // update the cursor\r\n                    this._blinkIsEven = false;\r\n                    // shift + ctrl/cmd + <-\r\n                    if (evt.ctrlKey || evt.metaKey) {\r\n                        if (!this.isTextHighlightOn) {\r\n                            if (this._textWrapper.length === this._cursorOffset) {\r\n                                return;\r\n                            } else {\r\n                                this._endHighlightIndex = this._textWrapper.length - this._cursorOffset + 1;\r\n                            }\r\n                        }\r\n                        this._startHighlightIndex = 0;\r\n                        this._cursorIndex = this._textWrapper.length - this._endHighlightIndex;\r\n                        this._cursorOffset = this._textWrapper.length;\r\n                        this.isTextHighlightOn = true;\r\n                        this._markAsDirty();\r\n                        return;\r\n                    }\r\n                    //store the starting point\r\n                    if (!this.isTextHighlightOn) {\r\n                        this.isTextHighlightOn = true;\r\n                        this._cursorIndex = this._cursorOffset >= this._textWrapper.length ? this._textWrapper.length : this._cursorOffset - 1;\r\n                    }\r\n                    //if text is already highlighted\r\n                    else if (this._cursorIndex === -1) {\r\n                        this._cursorIndex = this._textWrapper.length - this._endHighlightIndex;\r\n                        this._cursorOffset = this._startHighlightIndex === 0 ? this._textWrapper.length : this._textWrapper.length - this._startHighlightIndex + 1;\r\n                    }\r\n                    //set the highlight indexes\r\n                    if (this._cursorIndex < this._cursorOffset) {\r\n                        this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                        this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                    } else if (this._cursorIndex > this._cursorOffset) {\r\n                        this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                        this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                    } else {\r\n                        this.isTextHighlightOn = false;\r\n                    }\r\n                    this._markAsDirty();\r\n                    return;\r\n                }\r\n                if (this.isTextHighlightOn) {\r\n                    this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n                    this.isTextHighlightOn = false;\r\n                }\r\n                if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    this._cursorOffset = this._textWrapper.length;\r\n                    evt.preventDefault();\r\n                }\r\n                this._blinkIsEven = false;\r\n                this.isTextHighlightOn = false;\r\n                this._cursorIndex = -1;\r\n                this._markAsDirty();\r\n                return;\r\n            case 39: // RIGHT\r\n                this._cursorOffset--;\r\n                if (this._cursorOffset < 0) {\r\n                    this._cursorOffset = 0;\r\n                }\r\n                if (evt && evt.shiftKey) {\r\n                    //update the cursor\r\n                    this._blinkIsEven = false;\r\n                    //shift + ctrl/cmd + ->\r\n                    if (evt.ctrlKey || evt.metaKey) {\r\n                        if (!this.isTextHighlightOn) {\r\n                            if (this._cursorOffset === 0) {\r\n                                return;\r\n                            } else {\r\n                                this._startHighlightIndex = this._textWrapper.length - this._cursorOffset - 1;\r\n                            }\r\n                        }\r\n                        this._endHighlightIndex = this._textWrapper.length;\r\n                        this.isTextHighlightOn = true;\r\n                        this._cursorIndex = this._textWrapper.length - this._startHighlightIndex;\r\n                        this._cursorOffset = 0;\r\n                        this._markAsDirty();\r\n                        return;\r\n                    }\r\n\r\n                    if (!this.isTextHighlightOn) {\r\n                        this.isTextHighlightOn = true;\r\n                        this._cursorIndex = this._cursorOffset <= 0 ? 0 : this._cursorOffset + 1;\r\n                    }\r\n                    //if text is already highlighted\r\n                    else if (this._cursorIndex === -1) {\r\n                        this._cursorIndex = this._textWrapper.length - this._startHighlightIndex;\r\n                        this._cursorOffset = this._textWrapper.length === this._endHighlightIndex ? 0 : this._textWrapper.length - this._endHighlightIndex - 1;\r\n                    }\r\n                    //set the highlight indexes\r\n                    if (this._cursorIndex < this._cursorOffset) {\r\n                        this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                        this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                    } else if (this._cursorIndex > this._cursorOffset) {\r\n                        this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                        this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                    } else {\r\n                        this.isTextHighlightOn = false;\r\n                    }\r\n                    this._markAsDirty();\r\n                    return;\r\n                }\r\n                if (this.isTextHighlightOn) {\r\n                    this._cursorOffset = this._textWrapper.length - this._endHighlightIndex;\r\n                    this.isTextHighlightOn = false;\r\n                }\r\n                //ctr + ->\r\n                if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    this._cursorOffset = 0;\r\n                    evt.preventDefault();\r\n                }\r\n                this._blinkIsEven = false;\r\n                this.isTextHighlightOn = false;\r\n                this._cursorIndex = -1;\r\n                this._markAsDirty();\r\n                return;\r\n        }\r\n        if (keyCode === 32) {\r\n            key = evt?.key ?? \" \";\r\n        }\r\n        this._deadKey = key === \"Dead\";\r\n        // Printable characters\r\n        if (\r\n            key &&\r\n            (keyCode === -1 || // Direct access\r\n                keyCode === 32 || // Space\r\n                keyCode === 34 || // \"    add support for single and double quotes\r\n                keyCode === 39 || // '\r\n                (keyCode > 47 && keyCode < 64) || // Numbers\r\n                (keyCode > 64 && keyCode < 91) || // Letters\r\n                (keyCode > 159 && keyCode < 193) || // Special characters\r\n                (keyCode > 218 && keyCode < 223) || // Special characters\r\n                (keyCode > 95 && keyCode < 112))\r\n        ) {\r\n            // Numpad\r\n            this._currentKey = key;\r\n            this.onBeforeKeyAddObservable.notifyObservers(this);\r\n            key = this._currentKey;\r\n            if (this._addKey && !this._deadKey) {\r\n                if (this.isTextHighlightOn) {\r\n                    this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex, key);\r\n                    this._textHasChanged();\r\n                    this._cursorOffset = this._textWrapper.length - (this._startHighlightIndex + 1);\r\n                    this.isTextHighlightOn = false;\r\n                    this._blinkIsEven = false;\r\n                    this._markAsDirty();\r\n                } else if (this._cursorOffset === 0) {\r\n                    this.text += this._deadKey && evt?.key ? evt.key : key;\r\n                } else {\r\n                    const insertPosition = this._textWrapper.length - this._cursorOffset;\r\n                    this._textWrapper.removePart(insertPosition, insertPosition, key);\r\n                    this._textHasChanged();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _updateValueFromCursorIndex(offset: number) {\r\n        //update the cursor\r\n        this._blinkIsEven = false;\r\n\r\n        if (this._cursorIndex === -1) {\r\n            this._cursorIndex = offset;\r\n        } else {\r\n            if (this._cursorIndex < this._cursorOffset) {\r\n                this._endHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n                this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n            } else if (this._cursorIndex > this._cursorOffset) {\r\n                this._endHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n                this._startHighlightIndex = this._textWrapper.length - this._cursorIndex;\r\n            } else {\r\n                this.isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            }\r\n        }\r\n        this.isTextHighlightOn = true;\r\n        this._markAsDirty();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _processDblClick(evt: PointerInfo) {\r\n        //pre-find the start and end index of the word under cursor, speeds up the rendering\r\n        this._startHighlightIndex = this._textWrapper.length - this._cursorOffset;\r\n        this._endHighlightIndex = this._startHighlightIndex;\r\n        let moveLeft, moveRight;\r\n        do {\r\n            moveRight = this._endHighlightIndex < this._textWrapper.length && this._textWrapper.isWord(this._endHighlightIndex) ? ++this._endHighlightIndex : 0;\r\n            moveLeft = this._startHighlightIndex > 0 && this._textWrapper.isWord(this._startHighlightIndex - 1) ? --this._startHighlightIndex : 0;\r\n        } while (moveLeft || moveRight);\r\n\r\n        this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n\r\n        this.isTextHighlightOn = true;\r\n        this._clickedCoordinate = null;\r\n        this._blinkIsEven = true;\r\n        this._cursorIndex = -1;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Allow the user to select all text\r\n     */\r\n    public selectAllText() {\r\n        this._blinkIsEven = true;\r\n        this.isTextHighlightOn = true;\r\n\r\n        this._startHighlightIndex = 0;\r\n        this._endHighlightIndex = this._textWrapper.length;\r\n        this._cursorOffset = this._textWrapper.length;\r\n        this._cursorIndex = -1;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Handles the keyboard event\r\n     * @param evt Defines the KeyboardEvent\r\n     */\r\n    public override processKeyboard(evt: IKeyboardEvent): void {\r\n        // process pressed key\r\n        this.processKey(evt.keyCode, evt.key, evt);\r\n\r\n        super.processKeyboard(evt);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _onCopyText(ev: ClipboardEvent): void {\r\n        this.isTextHighlightOn = false;\r\n        //when write permission to clipbaord data is denied\r\n        try {\r\n            ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\r\n        } catch {} //pass\r\n        this._host.clipboardData = this._highlightedText;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _onCutText(ev: ClipboardEvent): void {\r\n        if (!this._highlightedText) {\r\n            return;\r\n        }\r\n        this._textWrapper.removePart(this._startHighlightIndex, this._endHighlightIndex);\r\n        this._textHasChanged();\r\n        this.isTextHighlightOn = false;\r\n        this._cursorOffset = this._textWrapper.length - this._startHighlightIndex;\r\n        //when write permission to clipbaord data is denied\r\n        try {\r\n            ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\r\n        } catch {} //pass\r\n\r\n        this._host.clipboardData = this._highlightedText;\r\n        this._highlightedText = \"\";\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _onPasteText(ev: ClipboardEvent): void {\r\n        let data: string = \"\";\r\n        if (ev.clipboardData && ev.clipboardData.types.indexOf(\"text/plain\") !== -1) {\r\n            data = ev.clipboardData.getData(\"text/plain\");\r\n        } else {\r\n            //get the cached data; returns blank string by default\r\n            data = this._host.clipboardData;\r\n        }\r\n        const insertPosition = this._textWrapper.length - this._cursorOffset;\r\n        this._textWrapper.removePart(insertPosition, insertPosition, data);\r\n        this._textHasChanged();\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        // Background\r\n        if (this._isFocused) {\r\n            if (this._focusedBackground) {\r\n                context.fillStyle = this._isEnabled ? this._focusedBackground : this._disabledColor;\r\n\r\n                context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            }\r\n        } else if (this._background) {\r\n            context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\r\n\r\n            context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        if (!this._fontOffset || this._wasDirty) {\r\n            this._fontOffset = Control._GetFontOffset(context.font, this._host.getScene()?.getEngine());\r\n        }\r\n\r\n        // Text\r\n        const clipTextLeft = this._currentMeasure.left + this._margin.getValueInPixel(this._host, this._tempParentMeasure.width);\r\n        if (this.color) {\r\n            context.fillStyle = this.color;\r\n        }\r\n\r\n        let text = this._beforeRenderText(this._textWrapper);\r\n\r\n        if (!this._isFocused && !this._textWrapper.text && this._placeholderText) {\r\n            text = new TextWrapper();\r\n            text.text = this._placeholderText;\r\n\r\n            if (this._placeholderColor) {\r\n                context.fillStyle = this._placeholderColor;\r\n            }\r\n        }\r\n\r\n        this._textWidth = context.measureText(text.text).width;\r\n        const marginWidth = this._margin.getValueInPixel(this._host, this._tempParentMeasure.width) * 2;\r\n        if (this._autoStretchWidth) {\r\n            this.width = Math.min(this._maxWidth.getValueInPixel(this._host, this._tempParentMeasure.width), this._textWidth + marginWidth) + \"px\";\r\n            this._autoStretchWidth = true; // setting the width will have reset _autoStretchWidth to false!\r\n        }\r\n\r\n        const rootY = this._fontOffset.ascent + (this._currentMeasure.height - this._fontOffset.height) / 2;\r\n        const availableWidth = this._width.getValueInPixel(this._host, this._tempParentMeasure.width) - marginWidth;\r\n\r\n        context.save();\r\n        context.beginPath();\r\n        context.rect(clipTextLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, availableWidth + 2, this._currentMeasure.height);\r\n        context.clip();\r\n\r\n        if (this._isFocused && this._textWidth > availableWidth) {\r\n            const textLeft = clipTextLeft - this._textWidth + availableWidth;\r\n            if (!this._scrollLeft) {\r\n                this._scrollLeft = textLeft;\r\n            }\r\n        } else {\r\n            this._scrollLeft = clipTextLeft;\r\n        }\r\n\r\n        if (this.outlineWidth) {\r\n            context.strokeText(text.text, this._scrollLeft, this._currentMeasure.top + rootY);\r\n        }\r\n\r\n        context.fillText(text.text, this._scrollLeft, this._currentMeasure.top + rootY);\r\n\r\n        // Cursor\r\n        if (this._isFocused) {\r\n            // Need to move cursor\r\n            if (this._clickedCoordinate) {\r\n                const rightPosition = this._scrollLeft + this._textWidth;\r\n                const absoluteCursorPosition = rightPosition - this._clickedCoordinate;\r\n                let currentSize = 0;\r\n                this._cursorOffset = 0;\r\n                let previousDist = 0;\r\n                do {\r\n                    if (this._cursorOffset) {\r\n                        previousDist = Math.abs(absoluteCursorPosition - currentSize);\r\n                    }\r\n                    this._cursorOffset++;\r\n                    currentSize = context.measureText(text.substr(text.length - this._cursorOffset, this._cursorOffset)).width;\r\n                } while (currentSize < absoluteCursorPosition && text.length >= this._cursorOffset);\r\n\r\n                // Find closest move\r\n                if (Math.abs(absoluteCursorPosition - currentSize) > previousDist) {\r\n                    this._cursorOffset--;\r\n                }\r\n\r\n                this._blinkIsEven = false;\r\n                this._clickedCoordinate = null;\r\n            }\r\n\r\n            // Render cursor\r\n            if (!this._blinkIsEven) {\r\n                const cursorOffsetText = text.substr(text.length - this._cursorOffset);\r\n                const cursorOffsetWidth = context.measureText(cursorOffsetText).width;\r\n                let cursorLeft = this._scrollLeft + this._textWidth - cursorOffsetWidth;\r\n\r\n                if (cursorLeft < clipTextLeft) {\r\n                    this._scrollLeft += clipTextLeft - cursorLeft;\r\n                    cursorLeft = clipTextLeft;\r\n                    this._markAsDirty();\r\n                } else if (cursorLeft > clipTextLeft + availableWidth) {\r\n                    this._scrollLeft += clipTextLeft + availableWidth - cursorLeft;\r\n                    cursorLeft = clipTextLeft + availableWidth;\r\n                    this._markAsDirty();\r\n                }\r\n                if (!this.isTextHighlightOn) {\r\n                    context.fillRect(cursorLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, 2, this._fontOffset.height);\r\n                }\r\n            }\r\n\r\n            clearTimeout(this._blinkTimeout);\r\n            this._blinkTimeout = <any>setTimeout(() => {\r\n                this._blinkIsEven = !this._blinkIsEven;\r\n                this._markAsDirty();\r\n            }, 500);\r\n\r\n            //show the highlighted text\r\n            if (this.isTextHighlightOn) {\r\n                clearTimeout(this._blinkTimeout);\r\n                const highlightCursorOffsetWidth = context.measureText(text.substring(this._startHighlightIndex)).width;\r\n                let highlightCursorLeft = this._scrollLeft + this._textWidth - highlightCursorOffsetWidth;\r\n                this._highlightedText = text.substring(this._startHighlightIndex, this._endHighlightIndex);\r\n                let width = context.measureText(text.substring(this._startHighlightIndex, this._endHighlightIndex)).width;\r\n                if (highlightCursorLeft < clipTextLeft) {\r\n                    width = width - (clipTextLeft - highlightCursorLeft);\r\n                    if (!width) {\r\n                        // when using left arrow on text.length > availableWidth;\r\n                        // assigns the width of the first letter after clipTextLeft\r\n                        width = context.measureText(text.charAt(text.length - this._cursorOffset)).width;\r\n                    }\r\n                    highlightCursorLeft = clipTextLeft;\r\n                }\r\n                //for transparancy\r\n                context.globalAlpha = this._highligherOpacity;\r\n                context.fillStyle = this._textHighlightColor;\r\n                context.fillRect(highlightCursorLeft, this._currentMeasure.top + (this._currentMeasure.height - this._fontOffset.height) / 2, width, this._fontOffset.height);\r\n                context.globalAlpha = 1.0;\r\n            }\r\n        }\r\n        context.restore();\r\n\r\n        // Border\r\n        if (this._thickness) {\r\n            if (this._isFocused) {\r\n                if (this.focusedColor) {\r\n                    context.strokeStyle = this.focusedColor;\r\n                }\r\n            } else {\r\n                if (this.color) {\r\n                    context.strokeStyle = this.color;\r\n                }\r\n            }\r\n\r\n            context.lineWidth = this._thickness;\r\n\r\n            context.strokeRect(\r\n                this._currentMeasure.left + this._thickness / 2,\r\n                this._currentMeasure.top + this._thickness / 2,\r\n                this._currentMeasure.width - this._thickness,\r\n                this._currentMeasure.height - this._thickness\r\n            );\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        this._clickedCoordinate = coordinates.x;\r\n        this.isTextHighlightOn = false;\r\n        this._highlightedText = \"\";\r\n        this._cursorIndex = -1;\r\n        this._isPointerDown = true;\r\n        this._host._capturingControl[pointerId] = this;\r\n        this._focusedBy = (pi.event as IPointerEvent).pointerType;\r\n        if (this._host.focusedControl === this) {\r\n            // Move cursor\r\n            clearTimeout(this._blinkTimeout);\r\n            this._markAsDirty();\r\n            return true;\r\n        }\r\n        if (!this._isEnabled) {\r\n            return false;\r\n        }\r\n        this._host.focusedControl = this;\r\n\r\n        return true;\r\n    }\r\n    public override _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: PointerInfoBase): void {\r\n        if (this._host.focusedControl === this && this._isPointerDown && !this.isReadOnly) {\r\n            this._clickedCoordinate = coordinates.x;\r\n            this._markAsDirty();\r\n            this._updateValueFromCursorIndex(this._cursorOffset);\r\n        }\r\n        super._onPointerMove(target, coordinates, pointerId, pi);\r\n    }\r\n\r\n    public override _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean): void {\r\n        this._isPointerDown = false;\r\n        delete this._host._capturingControl[pointerId];\r\n        super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick);\r\n    }\r\n\r\n    protected _beforeRenderText(textWrapper: TextWrapper): TextWrapper {\r\n        return textWrapper;\r\n    }\r\n\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private set isTextHighlightOn(value: boolean) {\r\n        if (this._isTextHighlightOn === value) {\r\n            return;\r\n        }\r\n        if (value) {\r\n            this.onTextHighlightObservable.notifyObservers(this);\r\n        }\r\n        this._isTextHighlightOn = value;\r\n    }\r\n\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private get isTextHighlightOn(): boolean {\r\n        return this._isTextHighlightOn;\r\n    }\r\n\r\n    public override dispose() {\r\n        super.dispose();\r\n\r\n        this.onBlurObservable.clear();\r\n        this.onFocusObservable.clear();\r\n        this.onTextChangedObservable.clear();\r\n        this.onTextCopyObservable.clear();\r\n        this.onTextCutObservable.clear();\r\n        this.onTextPasteObservable.clear();\r\n        this.onTextHighlightObservable.clear();\r\n        this.onKeyboardEventProcessedObservable.clear();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.InputText\", InputText);\r\n", "import type { Nullable } from \"core/types\";\r\n\r\nimport { Container } from \"./container\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport { Control } from \"./control\";\r\nimport type { Measure } from \"../measure\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * Class used to create a 2D grid container\r\n */\r\nexport class Grid extends Container {\r\n    private _rowDefinitions = new Array<ValueAndUnit>();\r\n    private _rowDefinitionObservers: Observer<void>[] = [];\r\n    private _columnDefinitions = new Array<ValueAndUnit>();\r\n    private _columnDefinitionObservers: Observer<void>[] = [];\r\n    private _cells: { [key: string]: Container } = {};\r\n    private _childControls = new Array<Control>();\r\n\r\n    /**\r\n     * Sets/Gets a boolean indicating that control content must be clipped\r\n     * Please note that not clipping content may generate issues with adt.useInvalidateRectOptimization so it is recommended to turn this optimization off if you want to use unclipped children\r\n     */\r\n    public override set clipContent(value: boolean) {\r\n        this._clipContent = value;\r\n\r\n        // This value has to be replicated on all of the container cells\r\n        for (const key in this._cells) {\r\n            this._cells[key].clipContent = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public override get clipContent(): boolean {\r\n        return this._clipContent;\r\n    }\r\n\r\n    /**\r\n     * Sets/Gets a boolean indicating if the children are clipped to the current control bounds.\r\n     * Please note that not clipping children may generate issues with adt.useInvalidateRectOptimization so it is recommended to turn this optimization off if you want to use unclipped children\r\n     */\r\n    public override set clipChildren(value: boolean) {\r\n        this._clipChildren = value;\r\n\r\n        // This value has to be replicated on all of the container cells\r\n        for (const key in this._cells) {\r\n            this._cells[key].clipChildren = value;\r\n        }\r\n    }\r\n\r\n    public override get clipChildren(): boolean {\r\n        return this._clipChildren;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of columns\r\n     */\r\n    public get columnCount(): number {\r\n        return this._columnDefinitions.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of rows\r\n     */\r\n    public get rowCount(): number {\r\n        return this._rowDefinitions.length;\r\n    }\r\n\r\n    /** Gets the list of children */\r\n    public override get children(): Control[] {\r\n        return this._childControls;\r\n    }\r\n\r\n    /** Gets the list of cells (e.g. the containers) */\r\n    public get cells(): { [key: string]: Container } {\r\n        return this._cells;\r\n    }\r\n\r\n    /**\r\n     * Gets the definition of a specific row\r\n     * @param index defines the index of the row\r\n     * @returns the row definition\r\n     */\r\n    public getRowDefinition(index: number): Nullable<ValueAndUnit> {\r\n        if (index < 0 || index >= this._rowDefinitions.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._rowDefinitions[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the definition of a specific column\r\n     * @param index defines the index of the column\r\n     * @returns the column definition\r\n     */\r\n    public getColumnDefinition(index: number): Nullable<ValueAndUnit> {\r\n        if (index < 0 || index >= this._columnDefinitions.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._columnDefinitions[index];\r\n    }\r\n\r\n    /**\r\n     * Adds a new row to the grid\r\n     * @param height defines the height of the row (either in pixel or a value between 0 and 1)\r\n     * @param isPixel defines if the height is expressed in pixel (or in percentage)\r\n     * @returns the current grid\r\n     */\r\n    public addRowDefinition(height: number, isPixel = false): Grid {\r\n        this._rowDefinitions.push(new ValueAndUnit(height, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE));\r\n        this._rowDefinitionObservers.push(this._rowDefinitions[this.rowCount - 1].onChangedObservable.add(() => this._markAsDirty())!);\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new column to the grid\r\n     * @param width defines the width of the column (either in pixel or a value between 0 and 1)\r\n     * @param isPixel defines if the width is expressed in pixel (or in percentage)\r\n     * @returns the current grid\r\n     */\r\n    public addColumnDefinition(width: number, isPixel = false): Grid {\r\n        this._columnDefinitions.push(new ValueAndUnit(width, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE));\r\n        this._columnDefinitionObservers.push(this._columnDefinitions[this.columnCount - 1].onChangedObservable.add(() => this._markAsDirty())!);\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update a row definition\r\n     * @param index defines the index of the row to update\r\n     * @param height defines the height of the row (either in pixel or a value between 0 and 1)\r\n     * @param isPixel defines if the weight is expressed in pixel (or in percentage)\r\n     * @returns the current grid\r\n     */\r\n    public setRowDefinition(index: number, height: number, isPixel = false): Grid {\r\n        if (index < 0 || index >= this._rowDefinitions.length) {\r\n            return this;\r\n        }\r\n\r\n        const current = this._rowDefinitions[index];\r\n        if (current && current.isPixel === isPixel && current.value === height) {\r\n            return this;\r\n        }\r\n\r\n        this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\r\n        this._rowDefinitions[index] = new ValueAndUnit(height, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE);\r\n        this._rowDefinitionObservers[index] = this._rowDefinitions[index].onChangedObservable.add(() => this._markAsDirty())!;\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update a column definition\r\n     * @param index defines the index of the column to update\r\n     * @param width defines the width of the column (either in pixel or a value between 0 and 1)\r\n     * @param isPixel defines if the width is expressed in pixel (or in percentage)\r\n     * @returns the current grid\r\n     */\r\n    public setColumnDefinition(index: number, width: number, isPixel = false): Grid {\r\n        if (index < 0 || index >= this._columnDefinitions.length) {\r\n            return this;\r\n        }\r\n\r\n        const current = this._columnDefinitions[index];\r\n        if (current && current.isPixel === isPixel && current.value === width) {\r\n            return this;\r\n        }\r\n\r\n        this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\r\n        this._columnDefinitions[index] = new ValueAndUnit(width, isPixel ? ValueAndUnit.UNITMODE_PIXEL : ValueAndUnit.UNITMODE_PERCENTAGE);\r\n        this._columnDefinitionObservers[index] = this._columnDefinitions[index].onChangedObservable.add(() => this._markAsDirty())!;\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of children stored in a specific cell\r\n     * @param row defines the row to check\r\n     * @param column defines the column to check\r\n     * @returns the list of controls\r\n     */\r\n    public getChildrenAt(row: number, column: number): Nullable<Array<Control>> {\r\n        const cell = this._cells[`${row}:${column}`];\r\n\r\n        if (!cell) {\r\n            return null;\r\n        }\r\n\r\n        return cell.children;\r\n    }\r\n\r\n    /**\r\n     * Gets a string representing the child cell info (row x column)\r\n     * @param child defines the control to get info from\r\n     * @returns a string containing the child cell info (row x column)\r\n     */\r\n    public getChildCellInfo(child: Control): string {\r\n        return child._tag;\r\n    }\r\n\r\n    private _removeCell(cell: Container, key: string) {\r\n        if (!cell) {\r\n            return;\r\n        }\r\n\r\n        super.removeControl(cell);\r\n\r\n        for (const control of cell.children) {\r\n            const childIndex = this._childControls.indexOf(control);\r\n\r\n            if (childIndex !== -1) {\r\n                this._childControls.splice(childIndex, 1);\r\n            }\r\n        }\r\n\r\n        delete this._cells[key];\r\n    }\r\n\r\n    private _offsetCell(previousKey: string, key: string) {\r\n        if (!this._cells[key]) {\r\n            return;\r\n        }\r\n\r\n        this._cells[previousKey] = this._cells[key];\r\n\r\n        for (const control of this._cells[previousKey].children) {\r\n            control._tag = previousKey;\r\n        }\r\n\r\n        delete this._cells[key];\r\n    }\r\n\r\n    /**\r\n     * Remove a column definition at specified index\r\n     * @param index defines the index of the column to remove\r\n     * @returns the current grid\r\n     */\r\n    public removeColumnDefinition(index: number): Grid {\r\n        if (index < 0 || index >= this._columnDefinitions.length) {\r\n            return this;\r\n        }\r\n\r\n        for (let x = 0; x < this._rowDefinitions.length; x++) {\r\n            const key = `${x}:${index}`;\r\n            const cell = this._cells[key];\r\n\r\n            this._removeCell(cell, key);\r\n        }\r\n\r\n        for (let x = 0; x < this._rowDefinitions.length; x++) {\r\n            for (let y = index + 1; y < this._columnDefinitions.length; y++) {\r\n                const previousKey = `${x}:${y - 1}`;\r\n                const key = `${x}:${y}`;\r\n\r\n                this._offsetCell(previousKey, key);\r\n            }\r\n        }\r\n\r\n        this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\r\n        this._columnDefinitions.splice(index, 1);\r\n        this._columnDefinitionObservers.splice(index, 1);\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a row definition at specified index\r\n     * @param index defines the index of the row to remove\r\n     * @returns the current grid\r\n     */\r\n    public removeRowDefinition(index: number): Grid {\r\n        if (index < 0 || index >= this._rowDefinitions.length) {\r\n            return this;\r\n        }\r\n\r\n        for (let y = 0; y < this._columnDefinitions.length; y++) {\r\n            const key = `${index}:${y}`;\r\n            const cell = this._cells[key];\r\n\r\n            this._removeCell(cell, key);\r\n        }\r\n\r\n        for (let y = 0; y < this._columnDefinitions.length; y++) {\r\n            for (let x = index + 1; x < this._rowDefinitions.length; x++) {\r\n                const previousKey = `${x - 1}:${y}`;\r\n                const key = `${x}:${y}`;\r\n\r\n                this._offsetCell(previousKey, key);\r\n            }\r\n        }\r\n\r\n        this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\r\n        this._rowDefinitions.splice(index, 1);\r\n        this._rowDefinitionObservers.splice(index, 1);\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new control to the current grid\r\n     * @param control defines the control to add\r\n     * @param row defines the row where to add the control (0 by default)\r\n     * @param column defines the column where to add the control (0 by default)\r\n     * @returns the current grid\r\n     */\r\n    public override addControl(control: Control, row: number = 0, column: number = 0): Grid {\r\n        if (this._rowDefinitions.length === 0) {\r\n            // Add default row definition\r\n            this.addRowDefinition(1, false);\r\n        }\r\n\r\n        if (this._columnDefinitions.length === 0) {\r\n            // Add default column definition\r\n            this.addColumnDefinition(1, false);\r\n        }\r\n\r\n        if (this._childControls.indexOf(control) !== -1) {\r\n            Tools.Warn(`Control (Name:${control.name}, UniqueId:${control.uniqueId}) is already associated with this grid. You must remove it before reattaching it`);\r\n            return this;\r\n        }\r\n\r\n        const x = Math.min(row, this._rowDefinitions.length - 1);\r\n        const y = Math.min(column, this._columnDefinitions.length - 1);\r\n        const key = `${x}:${y}`;\r\n        let goodContainer = this._cells[key];\r\n\r\n        if (!goodContainer) {\r\n            goodContainer = new Container(key);\r\n            this._cells[key] = goodContainer;\r\n            goodContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n            goodContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n            goodContainer.clipContent = this.clipContent;\r\n            goodContainer.clipChildren = this.clipChildren;\r\n            super.addControl(goodContainer);\r\n        }\r\n\r\n        goodContainer.addControl(control);\r\n        this._childControls.push(control);\r\n        control._tag = key;\r\n        control.parent = this;\r\n\r\n        this._markAsDirty();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a control from the current container\r\n     * @param control defines the control to remove\r\n     * @returns the current container\r\n     */\r\n    public override removeControl(control: Control): Container {\r\n        const index = this._childControls.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            this._childControls.splice(index, 1);\r\n        }\r\n\r\n        const cell = this._cells[control._tag];\r\n\r\n        if (cell) {\r\n            cell.removeControl(control);\r\n            control._tag = null;\r\n        }\r\n\r\n        this._markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Grid\r\n     * @param name defines control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Grid\";\r\n    }\r\n\r\n    protected _getGridDefinitions(definitionCallback: (lefts: number[], tops: number[], widths: number[], heights: number[]) => void) {\r\n        const widths = [];\r\n        const heights = [];\r\n        const lefts = [];\r\n        const tops = [];\r\n\r\n        let availableWidth = this._currentMeasure.width;\r\n        let globalWidthPercentage = 0;\r\n        let availableHeight = this._currentMeasure.height;\r\n        let globalHeightPercentage = 0;\r\n\r\n        // Heights\r\n        let index = 0;\r\n        for (const rowDefinition of this._rowDefinitions) {\r\n            if (rowDefinition.isPixel) {\r\n                const height = rowDefinition.getValue(this._host);\r\n                availableHeight -= height;\r\n                heights[index] = height;\r\n            } else {\r\n                globalHeightPercentage += rowDefinition.value;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        let top = 0;\r\n        index = 0;\r\n        for (const rowDefinition of this._rowDefinitions) {\r\n            tops.push(top);\r\n\r\n            if (!rowDefinition.isPixel) {\r\n                const height = Math.round((rowDefinition.value / globalHeightPercentage) * availableHeight);\r\n                top += height;\r\n                heights[index] = height;\r\n            } else {\r\n                top += rowDefinition.getValue(this._host);\r\n            }\r\n            index++;\r\n        }\r\n\r\n        // Widths\r\n        index = 0;\r\n        for (const columnDefinition of this._columnDefinitions) {\r\n            if (columnDefinition.isPixel) {\r\n                const width = columnDefinition.getValue(this._host);\r\n                availableWidth -= width;\r\n                widths[index] = width;\r\n            } else {\r\n                globalWidthPercentage += columnDefinition.value;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        let left = 0;\r\n        index = 0;\r\n        for (const columnDefinition of this._columnDefinitions) {\r\n            lefts.push(left);\r\n            if (!columnDefinition.isPixel) {\r\n                const width = Math.round((columnDefinition.value / globalWidthPercentage) * availableWidth);\r\n                left += width;\r\n                widths[index] = width;\r\n            } else {\r\n                left += columnDefinition.getValue(this._host);\r\n            }\r\n            index++;\r\n        }\r\n\r\n        definitionCallback(lefts, tops, widths, heights);\r\n    }\r\n\r\n    protected override _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        this._getGridDefinitions((lefts: number[], tops: number[], widths: number[], heights: number[]) => {\r\n            // Setting child sizes\r\n            for (const key in this._cells) {\r\n                if (!Object.prototype.hasOwnProperty.call(this._cells, key)) {\r\n                    continue;\r\n                }\r\n                const split = key.split(\":\");\r\n                const x = parseInt(split[0]);\r\n                const y = parseInt(split[1]);\r\n                const cell = this._cells[key];\r\n\r\n                cell.leftInPixels = lefts[y];\r\n                cell.topInPixels = tops[x];\r\n                cell.widthInPixels = widths[y];\r\n                cell.heightInPixels = heights[x];\r\n                cell._left.ignoreAdaptiveScaling = true;\r\n                cell._top.ignoreAdaptiveScaling = true;\r\n                cell._width.ignoreAdaptiveScaling = true;\r\n                cell._height.ignoreAdaptiveScaling = true;\r\n            }\r\n        });\r\n\r\n        super._additionalProcessing(parentMeasure, context);\r\n    }\r\n\r\n    public override _flagDescendantsAsMatrixDirty(): void {\r\n        for (const key in this._cells) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._cells, key)) {\r\n                continue;\r\n            }\r\n\r\n            const child = this._cells[key];\r\n            child._markMatrixAsDirty();\r\n        }\r\n    }\r\n\r\n    public override _renderHighlightSpecific(context: ICanvasRenderingContext): void {\r\n        super._renderHighlightSpecific(context);\r\n\r\n        this._getGridDefinitions((lefts: number[], tops: number[], widths: number[], heights: number[]) => {\r\n            // Columns\r\n            for (let index = 0; index < lefts.length; index++) {\r\n                const left = this._currentMeasure.left + lefts[index] + widths[index];\r\n                context.beginPath();\r\n                context.moveTo(left, this._currentMeasure.top);\r\n                context.lineTo(left, this._currentMeasure.top + this._currentMeasure.height);\r\n                context.stroke();\r\n            }\r\n\r\n            // Rows\r\n            for (let index = 0; index < tops.length; index++) {\r\n                const top = this._currentMeasure.top + tops[index] + heights[index];\r\n                context.beginPath();\r\n                context.moveTo(this._currentMeasure.left, top);\r\n                context.lineTo(this._currentMeasure.left + this._currentMeasure.width, top);\r\n                context.stroke();\r\n            }\r\n        });\r\n\r\n        context.restore();\r\n    }\r\n\r\n    /** Releases associated resources */\r\n    public override dispose() {\r\n        super.dispose();\r\n\r\n        for (const control of this._childControls) {\r\n            control.dispose();\r\n        }\r\n        for (let index = 0; index < this._rowDefinitions.length; index++) {\r\n            this._rowDefinitions[index].onChangedObservable.remove(this._rowDefinitionObservers[index]);\r\n        }\r\n        for (let index = 0; index < this._columnDefinitions.length; index++) {\r\n            this._columnDefinitions[index].onChangedObservable.remove(this._columnDefinitionObservers[index]);\r\n        }\r\n        this._rowDefinitionObservers.length = 0;\r\n        this._rowDefinitions.length = 0;\r\n        this._columnDefinitionObservers.length = 0;\r\n        this._columnDefinitions.length = 0;\r\n        this._cells = {};\r\n        this._childControls.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current control\r\n     * @param serializationObject defined the JSON serialized object\r\n     * @param force force serialization even if isSerializable === false\r\n     */\r\n    public override serialize(serializationObject: any, force: boolean) {\r\n        super.serialize(serializationObject, force);\r\n        if (!this.isSerializable && !force) {\r\n            return;\r\n        }\r\n        serializationObject.columnCount = this.columnCount;\r\n        serializationObject.rowCount = this.rowCount;\r\n        serializationObject.columns = [];\r\n        serializationObject.rows = [];\r\n        serializationObject.tags = [];\r\n        for (let i = 0; i < this.columnCount; ++i) {\r\n            const cd = this.getColumnDefinition(i);\r\n            const childSerializationObject = { value: cd?.getValue(this.host), unit: cd?.unit };\r\n            serializationObject.columns.push(childSerializationObject);\r\n        }\r\n        for (let i = 0; i < this.rowCount; ++i) {\r\n            const rd = this.getRowDefinition(i);\r\n            const childSerializationObject = { value: rd?.getValue(this.host), unit: rd?.unit };\r\n            serializationObject.rows.push(childSerializationObject);\r\n        }\r\n        this.children.forEach((child) => {\r\n            serializationObject.tags.push(child._tag);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture) {\r\n        super._parseFromContent(serializedObject, host);\r\n        const children: Control[] = [];\r\n        this.children.forEach((child) => {\r\n            children.push(child);\r\n        });\r\n        this.removeRowDefinition(0);\r\n        this.removeColumnDefinition(0);\r\n        for (let i = 0; i < serializedObject.columnCount; ++i) {\r\n            const columnValue = serializedObject.columns[i].value;\r\n            const unit = serializedObject.columns[i].unit;\r\n            this.addColumnDefinition(columnValue, unit === 1 ? true : false);\r\n        }\r\n        for (let i = 0; i < serializedObject.rowCount; ++i) {\r\n            const rowValue = serializedObject.rows[i].value;\r\n            const unit = serializedObject.rows[i].unit;\r\n            this.addRowDefinition(rowValue, unit === 1 ? true : false);\r\n        }\r\n\r\n        for (let i = 0; i < children.length; ++i) {\r\n            const cellInfo = serializedObject.tags[i];\r\n            let rowNumber = parseInt(cellInfo.substring(0, cellInfo.search(\":\")));\r\n            if (isNaN(rowNumber)) {\r\n                rowNumber = 0;\r\n            }\r\n            let columnNumber = parseInt(cellInfo.substring(cellInfo.search(\":\") + 1));\r\n            if (isNaN(columnNumber)) {\r\n                columnNumber = 0;\r\n            }\r\n            this.addControl(children[i], rowNumber, columnNumber);\r\n        }\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Grid\", Grid);\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"./control\";\r\nimport type { Measure } from \"../measure\";\r\nimport { InputText } from \"./inputText\";\r\nimport { Rectangle } from \"./rectangle\";\r\nimport { Button } from \"./button\";\r\nimport { Grid } from \"./grid\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport { TextBlock } from \"../controls/textBlock\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\n/** Class used to create color pickers */\r\nexport class ColorPicker extends Control {\r\n    private static _Epsilon = 0.000001;\r\n    private _colorWheelCanvas: ICanvas;\r\n\r\n    private _value: Color3 = Color3.Red();\r\n    private _tmpColor = new Color3();\r\n\r\n    private _pointerStartedOnSquare = false;\r\n    private _pointerStartedOnWheel = false;\r\n\r\n    private _squareLeft = 0;\r\n    private _squareTop = 0;\r\n    private _squareSize = 0;\r\n\r\n    private _h = 360;\r\n    private _s = 1;\r\n    private _v = 1;\r\n\r\n    private _lastPointerDownId = -1;\r\n\r\n    /**\r\n     * Observable raised when the value changes\r\n     */\r\n    public onValueChangedObservable = new Observable<Color3>();\r\n\r\n    /** Gets or sets the color of the color picker */\r\n    @serialize()\r\n    public get value(): Color3 {\r\n        return this._value;\r\n    }\r\n\r\n    public set value(value: Color3) {\r\n        if (this._value.equals(value)) {\r\n            return;\r\n        }\r\n\r\n        this._value.copyFrom(value);\r\n\r\n        this._value.toHSVToRef(this._tmpColor);\r\n\r\n        this._h = this._tmpColor.r;\r\n        this._s = Math.max(this._tmpColor.g, 0.00001);\r\n        this._v = Math.max(this._tmpColor.b, 0.00001);\r\n\r\n        this._markAsDirty();\r\n\r\n        if (this._value.r <= ColorPicker._Epsilon) {\r\n            this._value.r = 0;\r\n        }\r\n\r\n        if (this._value.g <= ColorPicker._Epsilon) {\r\n            this._value.g = 0;\r\n        }\r\n\r\n        if (this._value.b <= ColorPicker._Epsilon) {\r\n            this._value.b = 0;\r\n        }\r\n\r\n        if (this._value.r >= 1.0 - ColorPicker._Epsilon) {\r\n            this._value.r = 1.0;\r\n        }\r\n\r\n        if (this._value.g >= 1.0 - ColorPicker._Epsilon) {\r\n            this._value.g = 1.0;\r\n        }\r\n\r\n        if (this._value.b >= 1.0 - ColorPicker._Epsilon) {\r\n            this._value.b = 1.0;\r\n        }\r\n\r\n        this.onValueChangedObservable.notifyObservers(this._value);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets control width\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public override get width(): string | number {\r\n        return this._width.toString(this._host);\r\n    }\r\n\r\n    public override set width(value: string | number) {\r\n        if (this._width.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._width.fromString(value)) {\r\n            if (this._width.getValue(this._host) === 0) {\r\n                value = \"1px\";\r\n                this._width.fromString(value);\r\n            }\r\n            this._height.fromString(value);\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets control height\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#position-and-size\r\n     */\r\n    @serialize()\r\n    public override get height(): string | number {\r\n        return this._height.toString(this._host);\r\n    }\r\n\r\n    /** Gets or sets control height */\r\n    public override set height(value: string | number) {\r\n        if (this._height.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._height.fromString(value)) {\r\n            if (this._height.getValue(this._host) === 0) {\r\n                value = \"1px\";\r\n                this._height.fromString(value);\r\n            }\r\n            this._width.fromString(value);\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets control size */\r\n    @serialize()\r\n    public get size(): string | number {\r\n        return this.width;\r\n    }\r\n\r\n    public set size(value: string | number) {\r\n        this.width = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ColorPicker\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n        this.value = new Color3(0.88, 0.1, 0.1);\r\n        this.size = \"200px\";\r\n        this.isPointerBlocker = true;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"ColorPicker\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _preMeasure(parentMeasure: Measure): void {\r\n        if (parentMeasure.width < parentMeasure.height) {\r\n            this._currentMeasure.height = parentMeasure.width;\r\n        } else {\r\n            this._currentMeasure.width = parentMeasure.height;\r\n        }\r\n    }\r\n\r\n    private _updateSquareProps(): void {\r\n        const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\r\n        const wheelThickness = radius * 0.2;\r\n        const innerDiameter = (radius - wheelThickness) * 2;\r\n        const squareSize = innerDiameter / Math.sqrt(2);\r\n        const offset = radius - squareSize * 0.5;\r\n\r\n        this._squareLeft = this._currentMeasure.left + offset;\r\n        this._squareTop = this._currentMeasure.top + offset;\r\n        this._squareSize = squareSize;\r\n    }\r\n\r\n    private _drawGradientSquare(hueValue: number, left: number, top: number, width: number, height: number, context: ICanvasRenderingContext) {\r\n        const lgh = context.createLinearGradient(left, top, width + left, top);\r\n        lgh.addColorStop(0, \"#fff\");\r\n        lgh.addColorStop(1, \"hsl(\" + hueValue + \", 100%, 50%)\");\r\n\r\n        context.fillStyle = lgh;\r\n        context.fillRect(left, top, width, height);\r\n\r\n        const lgv = context.createLinearGradient(left, top, left, height + top);\r\n        lgv.addColorStop(0, \"rgba(0,0,0,0)\");\r\n        lgv.addColorStop(1, \"#000\");\r\n\r\n        context.fillStyle = lgv;\r\n        context.fillRect(left, top, width, height);\r\n    }\r\n\r\n    private _drawCircle(centerX: number, centerY: number, radius: number, context: ICanvasRenderingContext) {\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, radius + 1, 0, 2 * Math.PI, false);\r\n        context.lineWidth = 3;\r\n        context.strokeStyle = \"#333333\";\r\n        context.stroke();\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n        context.lineWidth = 3;\r\n        context.strokeStyle = \"#ffffff\";\r\n        context.stroke();\r\n    }\r\n\r\n    private _createColorWheelCanvas(radius: number, thickness: number): ICanvas {\r\n        // Shoudl abstract platform instead of using LastCreatedEngine\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            throw new Error(\"Invalid engine. Unable to create a canvas.\");\r\n        }\r\n        const canvas = engine.createCanvas(radius * 2, radius * 2);\r\n        const context = canvas.getContext(\"2d\");\r\n        const image = context.getImageData(0, 0, radius * 2, radius * 2);\r\n        const data = image.data;\r\n\r\n        const color = this._tmpColor;\r\n        const maxDistSq = radius * radius;\r\n        const innerRadius = radius - thickness;\r\n        const minDistSq = innerRadius * innerRadius;\r\n\r\n        for (let x = -radius; x < radius; x++) {\r\n            for (let y = -radius; y < radius; y++) {\r\n                const distSq = x * x + y * y;\r\n\r\n                if (distSq > maxDistSq || distSq < minDistSq) {\r\n                    continue;\r\n                }\r\n\r\n                const dist = Math.sqrt(distSq);\r\n                const ang = Math.atan2(y, x);\r\n\r\n                Color3.HSVtoRGBToRef((ang * 180) / Math.PI + 180, dist / radius, 1, color);\r\n\r\n                const index = (x + radius + (y + radius) * 2 * radius) * 4;\r\n\r\n                data[index] = color.r * 255;\r\n                data[index + 1] = color.g * 255;\r\n                data[index + 2] = color.b * 255;\r\n                let alphaRatio = (dist - innerRadius) / (radius - innerRadius);\r\n\r\n                //apply less alpha to bigger color pickers\r\n                let alphaAmount = 0.2;\r\n                const maxAlpha = 0.2;\r\n                const minAlpha = 0.04;\r\n                const lowerRadius = 50;\r\n                const upperRadius = 150;\r\n\r\n                if (radius < lowerRadius) {\r\n                    alphaAmount = maxAlpha;\r\n                } else if (radius > upperRadius) {\r\n                    alphaAmount = minAlpha;\r\n                } else {\r\n                    alphaAmount = ((minAlpha - maxAlpha) * (radius - lowerRadius)) / (upperRadius - lowerRadius) + maxAlpha;\r\n                }\r\n\r\n                alphaRatio = (dist - innerRadius) / (radius - innerRadius);\r\n\r\n                if (alphaRatio < alphaAmount) {\r\n                    data[index + 3] = 255 * (alphaRatio / alphaAmount);\r\n                } else if (alphaRatio > 1 - alphaAmount) {\r\n                    data[index + 3] = 255 * (1.0 - (alphaRatio - (1 - alphaAmount)) / alphaAmount);\r\n                } else {\r\n                    data[index + 3] = 255;\r\n                }\r\n            }\r\n        }\r\n\r\n        context.putImageData(image, 0, 0);\r\n\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\r\n        const wheelThickness = radius * 0.2;\r\n        const left = this._currentMeasure.left;\r\n        const top = this._currentMeasure.top;\r\n\r\n        if (!this._colorWheelCanvas || this._colorWheelCanvas.width != radius * 2) {\r\n            this._colorWheelCanvas = this._createColorWheelCanvas(radius, wheelThickness);\r\n        }\r\n\r\n        this._updateSquareProps();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n\r\n            context.fillRect(this._squareLeft, this._squareTop, this._squareSize, this._squareSize);\r\n        }\r\n\r\n        context.drawImage(this._colorWheelCanvas, left, top);\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        this._drawGradientSquare(this._h, this._squareLeft, this._squareTop, this._squareSize, this._squareSize, context);\r\n\r\n        let cx = this._squareLeft + this._squareSize * this._s;\r\n        let cy = this._squareTop + this._squareSize * (1 - this._v);\r\n\r\n        this._drawCircle(cx, cy, radius * 0.04, context);\r\n\r\n        const dist = radius - wheelThickness * 0.5;\r\n        cx = left + radius + Math.cos(((this._h - 180) * Math.PI) / 180) * dist;\r\n        cy = top + radius + Math.sin(((this._h - 180) * Math.PI) / 180) * dist;\r\n        this._drawCircle(cx, cy, wheelThickness * 0.35, context);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    // Events\r\n    private _pointerIsDown = false;\r\n\r\n    private _updateValueFromPointer(x: number, y: number): void {\r\n        if (this._pointerStartedOnWheel) {\r\n            const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\r\n            const centerX = radius + this._currentMeasure.left;\r\n            const centerY = radius + this._currentMeasure.top;\r\n            this._h = (Math.atan2(y - centerY, x - centerX) * 180) / Math.PI + 180;\r\n        } else if (this._pointerStartedOnSquare) {\r\n            this._updateSquareProps();\r\n            this._s = (x - this._squareLeft) / this._squareSize;\r\n            this._v = 1 - (y - this._squareTop) / this._squareSize;\r\n            this._s = Math.min(this._s, 1);\r\n            this._s = Math.max(this._s, ColorPicker._Epsilon);\r\n            this._v = Math.min(this._v, 1);\r\n            this._v = Math.max(this._v, ColorPicker._Epsilon);\r\n        }\r\n\r\n        Color3.HSVtoRGBToRef(this._h, this._s, this._v, this._tmpColor);\r\n\r\n        this.value = this._tmpColor;\r\n    }\r\n\r\n    private _isPointOnSquare(x: number, y: number): boolean {\r\n        this._updateSquareProps();\r\n\r\n        const left = this._squareLeft;\r\n        const top = this._squareTop;\r\n        const size = this._squareSize;\r\n\r\n        if (x >= left && x <= left + size && y >= top && y <= top + size) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _isPointOnWheel(x: number, y: number): boolean {\r\n        const radius = Math.min(this._currentMeasure.width, this._currentMeasure.height) * 0.5;\r\n        const centerX = radius + this._currentMeasure.left;\r\n        const centerY = radius + this._currentMeasure.top;\r\n        const wheelThickness = radius * 0.2;\r\n        const innerRadius = radius - wheelThickness;\r\n        const radiusSq = radius * radius;\r\n        const innerRadiusSq = innerRadius * innerRadius;\r\n\r\n        const dx = x - centerX;\r\n        const dy = y - centerY;\r\n\r\n        const distSq = dx * dx + dy * dy;\r\n\r\n        if (distSq <= radiusSq && distSq >= innerRadiusSq) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        this._pointerIsDown = true;\r\n\r\n        this._pointerStartedOnSquare = false;\r\n        this._pointerStartedOnWheel = false;\r\n\r\n        // Invert transform\r\n        this._invertTransformMatrix.transformCoordinates(coordinates.x, coordinates.y, this._transformedPosition);\r\n\r\n        const x = this._transformedPosition.x;\r\n        const y = this._transformedPosition.y;\r\n\r\n        if (this._isPointOnSquare(x, y)) {\r\n            this._pointerStartedOnSquare = true;\r\n        } else if (this._isPointOnWheel(x, y)) {\r\n            this._pointerStartedOnWheel = true;\r\n        }\r\n\r\n        this._updateValueFromPointer(x, y);\r\n        this._host._capturingControl[pointerId] = this;\r\n        this._lastPointerDownId = pointerId;\r\n        return true;\r\n    }\r\n\r\n    public override _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: PointerInfoBase): void {\r\n        // Only listen to pointer move events coming from the last pointer to click on the element (To support dual vr controller interaction)\r\n        if (pointerId != this._lastPointerDownId) {\r\n            return;\r\n        }\r\n\r\n        if (!this.isReadOnly) {\r\n            // Invert transform\r\n            this._invertTransformMatrix.transformCoordinates(coordinates.x, coordinates.y, this._transformedPosition);\r\n\r\n            const x = this._transformedPosition.x;\r\n            const y = this._transformedPosition.y;\r\n\r\n            if (this._pointerIsDown) {\r\n                this._updateValueFromPointer(x, y);\r\n            }\r\n        }\r\n\r\n        super._onPointerMove(target, coordinates, pointerId, pi);\r\n    }\r\n\r\n    public override _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean, pi: PointerInfoBase): void {\r\n        this._pointerIsDown = false;\r\n\r\n        delete this._host._capturingControl[pointerId];\r\n        super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick, pi);\r\n    }\r\n\r\n    public override _onCanvasBlur() {\r\n        this._forcePointerUp();\r\n        super._onCanvasBlur();\r\n    }\r\n\r\n    /**\r\n     * This function expands the color picker by creating a color picker dialog with manual\r\n     * color value input and the ability to save colors into an array to be used later in\r\n     * subsequent launches of the dialogue.\r\n     * @param advancedTexture defines the AdvancedDynamicTexture the dialog is assigned to\r\n     * @param options defines size for dialog and options for saved colors. Also accepts last color picked as hex string and saved colors array as hex strings.\r\n     * @param options.pickerWidth\r\n     * @param options.pickerHeight\r\n     * @param options.headerHeight\r\n     * @param options.lastColor\r\n     * @param options.swatchLimit\r\n     * @param options.numSwatchesPerLine\r\n     * @param options.savedColors\r\n     * @returns picked color as a hex string and the saved colors array as hex strings.\r\n     */\r\n    public static ShowPickerDialogAsync(\r\n        advancedTexture: AdvancedDynamicTexture,\r\n        options: {\r\n            pickerWidth?: string;\r\n            pickerHeight?: string;\r\n            headerHeight?: string;\r\n            lastColor?: string;\r\n            swatchLimit?: number;\r\n            numSwatchesPerLine?: number;\r\n            savedColors?: Array<string>;\r\n        }\r\n    ): Promise<{\r\n        savedColors?: string[];\r\n        pickedColor: string;\r\n    }> {\r\n        return new Promise((resolve) => {\r\n            // Default options\r\n            options.pickerWidth = options.pickerWidth || \"640px\";\r\n            options.pickerHeight = options.pickerHeight || \"400px\";\r\n            options.headerHeight = options.headerHeight || \"35px\";\r\n            options.lastColor = options.lastColor || \"#000000\";\r\n            options.swatchLimit = options.swatchLimit || 20;\r\n            options.numSwatchesPerLine = options.numSwatchesPerLine || 10;\r\n\r\n            // Window size settings\r\n            const drawerMaxRows: number = options.swatchLimit / options.numSwatchesPerLine;\r\n            const rawSwatchSize: number = parseFloat(<string>options.pickerWidth) / options.numSwatchesPerLine;\r\n            const gutterSize: number = Math.floor(rawSwatchSize * 0.25);\r\n            const colGutters: number = gutterSize * (options.numSwatchesPerLine + 1);\r\n            const swatchSize: number = Math.floor((parseFloat(<string>options.pickerWidth) - colGutters) / options.numSwatchesPerLine);\r\n            const drawerMaxSize: number = swatchSize * drawerMaxRows + gutterSize * (drawerMaxRows + 1);\r\n            const containerSize: string = (parseInt(options.pickerHeight) + drawerMaxSize + Math.floor(swatchSize * 0.25)).toString() + \"px\";\r\n\r\n            // Button Colors\r\n            const buttonColor: string = \"#c0c0c0\";\r\n            const buttonBackgroundColor: string = \"#535353\";\r\n            const buttonBackgroundHoverColor: string = \"#414141\";\r\n            const buttonBackgroundClickColor: string = \"515151\";\r\n            const buttonDisabledColor: string = \"#555555\";\r\n            const buttonDisabledBackgroundColor: string = \"#454545\";\r\n            const currentSwatchesOutlineColor: string = \"#404040\";\r\n            const luminanceLimitColor: Color3 = Color3.FromHexString(\"#dddddd\");\r\n            const luminanceLimit: number = luminanceLimitColor.r + luminanceLimitColor.g + luminanceLimitColor.b;\r\n            const iconColorDark: string = \"#aaaaaa\";\r\n            const iconColorLight: string = \"#ffffff\";\r\n\r\n            // Button settings\r\n            let buttonFontSize: number;\r\n            let butEdit: Button;\r\n\r\n            // Input Text Colors\r\n            const inputFieldLabels: string[] = [\"R\", \"G\", \"B\"];\r\n            const inputTextBackgroundColor: string = \"#454545\";\r\n            const inputTextColor: string = \"#f0f0f0\";\r\n\r\n            // This int is used for naming swatches and serves as the index for calling them from the list\r\n            let swatchNumber: number;\r\n\r\n            // Menu Panel options. We need to know if the swatchDrawer exists so we can create it if needed.\r\n            let swatchDrawer: Grid;\r\n            let editSwatchMode: boolean = false;\r\n\r\n            // Color InputText fields that will be updated upon value change\r\n            let butSave: Button;\r\n            let lastVal: string;\r\n            let activeField: string;\r\n\r\n            // Dialog menu container which will contain both the main dialogue window and the swatch drawer which opens once a color is saved.\r\n            const dialogContainer: Grid = new Grid();\r\n            dialogContainer.name = \"Dialog Container\";\r\n            dialogContainer.width = options.pickerWidth;\r\n            if (options.savedColors) {\r\n                dialogContainer.height = containerSize;\r\n                const topRow: number = parseInt(options.pickerHeight) / parseInt(containerSize);\r\n                dialogContainer.addRowDefinition(topRow, false);\r\n                dialogContainer.addRowDefinition(1.0 - topRow, false);\r\n            } else {\r\n                dialogContainer.height = options.pickerHeight;\r\n                dialogContainer.addRowDefinition(1.0, false);\r\n            }\r\n            advancedTexture.addControl(dialogContainer);\r\n\r\n            // Swatch drawer which contains all saved color buttons\r\n            if (options.savedColors) {\r\n                swatchDrawer = new Grid();\r\n                swatchDrawer.name = \"Swatch Drawer\";\r\n                swatchDrawer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n                swatchDrawer.background = buttonBackgroundColor;\r\n                swatchDrawer.width = options.pickerWidth!;\r\n                const initialRows: number = options.savedColors.length / options.numSwatchesPerLine;\r\n                let gutterCount: number;\r\n                if (initialRows == 0) {\r\n                    gutterCount = 0;\r\n                } else {\r\n                    gutterCount = initialRows + 1;\r\n                }\r\n                swatchDrawer.height = (swatchSize * initialRows + gutterCount * gutterSize).toString() + \"px\";\r\n                swatchDrawer.top = Math.floor(swatchSize * 0.25).toString() + \"px\";\r\n                for (let i = 0; i < Math.ceil(options.savedColors.length / options.numSwatchesPerLine) * 2 + 1; i++) {\r\n                    if (i % 2 != 0) {\r\n                        swatchDrawer.addRowDefinition(swatchSize, true);\r\n                    } else {\r\n                        swatchDrawer.addRowDefinition(gutterSize, true);\r\n                    }\r\n                }\r\n                for (let i = 0; i < options.numSwatchesPerLine! * 2 + 1; i++) {\r\n                    if (i % 2 != 0) {\r\n                        swatchDrawer.addColumnDefinition(swatchSize, true);\r\n                    } else {\r\n                        swatchDrawer.addColumnDefinition(gutterSize, true);\r\n                    }\r\n                }\r\n                dialogContainer.addControl(swatchDrawer, 1, 0);\r\n            }\r\n\r\n            // Picker container\r\n            const pickerPanel: Grid = new Grid();\r\n            pickerPanel.name = \"Picker Panel\";\r\n            pickerPanel.height = options.pickerHeight;\r\n            const panelHead: number = parseInt(options.headerHeight) / parseInt(options.pickerHeight);\r\n            const pickerPanelRows: number[] = [panelHead, 1.0 - panelHead];\r\n            pickerPanel.addRowDefinition(pickerPanelRows[0], false);\r\n            pickerPanel.addRowDefinition(pickerPanelRows[1], false);\r\n            dialogContainer.addControl(pickerPanel, 0, 0);\r\n\r\n            // Picker container header\r\n            const header: Rectangle = new Rectangle();\r\n            header.name = \"Dialogue Header Bar\";\r\n            header.background = \"#cccccc\";\r\n            header.thickness = 0;\r\n            pickerPanel.addControl(header, 0, 0);\r\n\r\n            // Header close button\r\n            const closeButton: Button = Button.CreateSimpleButton(\"closeButton\", \"a\");\r\n            closeButton.fontFamily = \"coreglyphs\";\r\n            const headerColor3: Color3 = Color3.FromHexString(header.background);\r\n            const closeIconColor = new Color3(1.0 - headerColor3.r, 1.0 - headerColor3.g, 1.0 - headerColor3.b);\r\n            closeButton.color = closeIconColor.toHexString();\r\n            closeButton.fontSize = Math.floor(parseInt(options.headerHeight!) * 0.6);\r\n            closeButton.textBlock!.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            closeButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_RIGHT;\r\n            closeButton.height = closeButton.width = options.headerHeight;\r\n            closeButton.background = header.background;\r\n            closeButton.thickness = 0;\r\n            closeButton.pointerDownAnimation = () => {};\r\n            closeButton.pointerUpAnimation = () => {\r\n                closeButton.background = header.background;\r\n            };\r\n            closeButton.pointerEnterAnimation = () => {\r\n                closeButton.color = header.background;\r\n                closeButton.background = \"red\";\r\n            };\r\n            closeButton.pointerOutAnimation = () => {\r\n                closeButton.color = closeIconColor.toHexString();\r\n                closeButton.background = header.background;\r\n            };\r\n            closeButton.onPointerClickObservable.add(() => {\r\n                closePicker(currentSwatch.background);\r\n            });\r\n            pickerPanel.addControl(closeButton, 0, 0);\r\n\r\n            // Dialog container body\r\n            const dialogBody: Grid = new Grid();\r\n            dialogBody.name = \"Dialogue Body\";\r\n            dialogBody.background = buttonBackgroundColor;\r\n            const dialogBodyCols: number[] = [0.4375, 0.5625];\r\n            dialogBody.addRowDefinition(1.0, false);\r\n            dialogBody.addColumnDefinition(dialogBodyCols[0], false);\r\n            dialogBody.addColumnDefinition(dialogBodyCols[1], false);\r\n            pickerPanel.addControl(dialogBody, 1, 0);\r\n\r\n            // Picker grid\r\n            const pickerGrid: Grid = new Grid();\r\n            pickerGrid.name = \"Picker Grid\";\r\n            pickerGrid.addRowDefinition(0.85, false);\r\n            pickerGrid.addRowDefinition(0.15, false);\r\n            dialogBody.addControl(pickerGrid, 0, 0);\r\n\r\n            //  Picker control\r\n            const picker = new ColorPicker();\r\n            picker.name = \"GUI Color Picker\";\r\n            if (options.pickerHeight < options.pickerWidth) {\r\n                picker.width = 0.89;\r\n            } else {\r\n                picker.height = 0.89;\r\n            }\r\n            picker.value = Color3.FromHexString(options.lastColor);\r\n            picker.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n            picker.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            picker.onPointerDownObservable.add(() => {\r\n                activeField = picker.name!;\r\n                lastVal = \"\";\r\n                editSwatches(false);\r\n            });\r\n            picker.onValueChangedObservable.add(function (value) {\r\n                // value is a color3\r\n                if (activeField == picker.name) {\r\n                    updateValues(value, picker.name);\r\n                }\r\n            });\r\n            pickerGrid.addControl(picker, 0, 0);\r\n\r\n            // Picker body right quarant\r\n            const pickerBodyRight: Grid = new Grid();\r\n            pickerBodyRight.name = \"Dialogue Right Half\";\r\n            pickerBodyRight.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n            const pickerBodyRightRows: number[] = [0.514, 0.486];\r\n            pickerBodyRight.addRowDefinition(pickerBodyRightRows[0], false);\r\n            pickerBodyRight.addRowDefinition(pickerBodyRightRows[1], false);\r\n            dialogBody.addControl(pickerBodyRight, 1, 1);\r\n\r\n            // Picker container swatches and buttons\r\n            const pickerSwatchesButtons: Grid = new Grid();\r\n            pickerSwatchesButtons.name = \"Swatches and Buttons\";\r\n            const pickerButtonsCol: number[] = [0.417, 0.583];\r\n            pickerSwatchesButtons.addRowDefinition(1.0, false);\r\n            pickerSwatchesButtons.addColumnDefinition(pickerButtonsCol[0], false);\r\n            pickerSwatchesButtons.addColumnDefinition(pickerButtonsCol[1], false);\r\n            pickerBodyRight.addControl(pickerSwatchesButtons, 0, 0);\r\n\r\n            // Picker Swatches quadrant\r\n            const pickerSwatches: Grid = new Grid();\r\n            pickerSwatches.name = \"New and Current Swatches\";\r\n            const pickeSwatchesRows: number[] = [0.04, 0.16, 0.64, 0.16];\r\n            pickerSwatches.addRowDefinition(pickeSwatchesRows[0], false);\r\n            pickerSwatches.addRowDefinition(pickeSwatchesRows[1], false);\r\n            pickerSwatches.addRowDefinition(pickeSwatchesRows[2], false);\r\n            pickerSwatches.addRowDefinition(pickeSwatchesRows[3], false);\r\n            pickerSwatchesButtons.addControl(pickerSwatches, 0, 0);\r\n\r\n            // Active swatches\r\n            const activeSwatches: Grid = new Grid();\r\n            activeSwatches.name = \"Active Swatches\";\r\n            activeSwatches.width = 0.67;\r\n            activeSwatches.addRowDefinition(0.5, false);\r\n            activeSwatches.addRowDefinition(0.5, false);\r\n            pickerSwatches.addControl(activeSwatches, 2, 0);\r\n\r\n            const labelWidth: number = Math.floor(parseInt(options.pickerWidth) * dialogBodyCols[1] * pickerButtonsCol[0] * 0.11);\r\n            const labelHeight: number = Math.floor(parseInt(options.pickerHeight) * pickerPanelRows[1] * pickerBodyRightRows[0] * pickeSwatchesRows[1] * 0.5);\r\n\r\n            let labelTextSize: number;\r\n            if (options.pickerWidth > options.pickerHeight) {\r\n                labelTextSize = labelHeight;\r\n            } else {\r\n                labelTextSize = labelWidth;\r\n            }\r\n            // New color swatch and previous color button\r\n            const newText: TextBlock = new TextBlock();\r\n            newText.text = \"new\";\r\n            newText.name = \"New Color Label\";\r\n            newText.color = buttonColor;\r\n            newText.fontSize = labelTextSize;\r\n            pickerSwatches.addControl(newText, 1, 0);\r\n\r\n            const newSwatch = new Rectangle();\r\n            newSwatch.name = \"New Color Swatch\";\r\n            newSwatch.background = options.lastColor;\r\n            newSwatch.thickness = 0;\r\n            activeSwatches.addControl(newSwatch, 0, 0);\r\n\r\n            const currentSwatch: Button = Button.CreateSimpleButton(\"currentSwatch\", \"\");\r\n            currentSwatch.background = options.lastColor;\r\n            currentSwatch.thickness = 0;\r\n            currentSwatch.onPointerClickObservable.add(() => {\r\n                const revertColor = Color3.FromHexString(currentSwatch.background);\r\n                updateValues(revertColor, currentSwatch.name!);\r\n                editSwatches(false);\r\n            });\r\n            currentSwatch.pointerDownAnimation = () => {};\r\n            currentSwatch.pointerUpAnimation = () => {};\r\n            currentSwatch.pointerEnterAnimation = () => {};\r\n            currentSwatch.pointerOutAnimation = () => {};\r\n            activeSwatches.addControl(currentSwatch, 1, 0);\r\n\r\n            const swatchOutline: Rectangle = new Rectangle();\r\n            swatchOutline.name = \"Swatch Outline\";\r\n            swatchOutline.width = 0.67;\r\n            swatchOutline.thickness = 2;\r\n            swatchOutline.color = currentSwatchesOutlineColor;\r\n            swatchOutline.isHitTestVisible = false;\r\n            pickerSwatches.addControl(swatchOutline, 2, 0);\r\n\r\n            const currentText: TextBlock = new TextBlock();\r\n            currentText.name = \"Current Color Label\";\r\n            currentText.text = \"current\";\r\n            currentText.color = buttonColor;\r\n            currentText.fontSize = labelTextSize;\r\n            pickerSwatches.addControl(currentText, 3, 0);\r\n\r\n            // Buttons grid\r\n            const buttonGrid: Grid = new Grid();\r\n            buttonGrid.name = \"Button Grid\";\r\n            buttonGrid.height = 0.8;\r\n            const buttonGridRows: number = 1 / 3;\r\n            buttonGrid.addRowDefinition(buttonGridRows, false);\r\n            buttonGrid.addRowDefinition(buttonGridRows, false);\r\n            buttonGrid.addRowDefinition(buttonGridRows, false);\r\n            pickerSwatchesButtons.addControl(buttonGrid, 0, 1);\r\n\r\n            // Determine pixel width and height for all buttons from overall panel dimensions\r\n            const buttonWidth = Math.floor(parseInt(options.pickerWidth) * dialogBodyCols[1] * pickerButtonsCol[1] * 0.67).toString() + \"px\";\r\n            const buttonHeight =\r\n                Math.floor(\r\n                    parseInt(options.pickerHeight) * pickerPanelRows[1] * pickerBodyRightRows[0] * (parseFloat(buttonGrid.height.toString()) / 100) * buttonGridRows * 0.7\r\n                ).toString() + \"px\";\r\n\r\n            // Determine button type size\r\n            if (parseFloat(buttonWidth) > parseFloat(buttonHeight)) {\r\n                buttonFontSize = Math.floor(parseFloat(buttonHeight) * 0.45);\r\n            } else {\r\n                buttonFontSize = Math.floor(parseFloat(buttonWidth) * 0.11);\r\n            }\r\n\r\n            // Panel Buttons\r\n            const butOK: Button = Button.CreateSimpleButton(\"butOK\", \"OK\");\r\n            butOK.width = buttonWidth;\r\n            butOK.height = buttonHeight;\r\n            butOK.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            butOK.thickness = 2;\r\n            butOK.color = buttonColor;\r\n            butOK.fontSize = buttonFontSize;\r\n            butOK.background = buttonBackgroundColor;\r\n            butOK.onPointerEnterObservable.add(() => {\r\n                butOK.background = buttonBackgroundHoverColor;\r\n            });\r\n            butOK.onPointerOutObservable.add(() => {\r\n                butOK.background = buttonBackgroundColor;\r\n            });\r\n            butOK.pointerDownAnimation = () => {\r\n                butOK.background = buttonBackgroundClickColor;\r\n            };\r\n            butOK.pointerUpAnimation = () => {\r\n                butOK.background = buttonBackgroundHoverColor;\r\n            };\r\n            butOK.onPointerClickObservable.add(() => {\r\n                editSwatches(false);\r\n                closePicker(newSwatch.background);\r\n            });\r\n            buttonGrid.addControl(butOK, 0, 0);\r\n\r\n            const butCancel: Button = Button.CreateSimpleButton(\"butCancel\", \"Cancel\");\r\n            butCancel.width = buttonWidth;\r\n            butCancel.height = buttonHeight;\r\n            butCancel.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            butCancel.thickness = 2;\r\n            butCancel.color = buttonColor;\r\n            butCancel.fontSize = buttonFontSize;\r\n            butCancel.background = buttonBackgroundColor;\r\n            butCancel.onPointerEnterObservable.add(() => {\r\n                butCancel.background = buttonBackgroundHoverColor;\r\n            });\r\n            butCancel.onPointerOutObservable.add(() => {\r\n                butCancel.background = buttonBackgroundColor;\r\n            });\r\n            butCancel.pointerDownAnimation = () => {\r\n                butCancel.background = buttonBackgroundClickColor;\r\n            };\r\n            butCancel.pointerUpAnimation = () => {\r\n                butCancel.background = buttonBackgroundHoverColor;\r\n            };\r\n            butCancel.onPointerClickObservable.add(() => {\r\n                editSwatches(false);\r\n                closePicker(currentSwatch.background);\r\n            });\r\n            buttonGrid.addControl(butCancel, 1, 0);\r\n\r\n            if (options.savedColors) {\r\n                butSave = Button.CreateSimpleButton(\"butSave\", \"Save\");\r\n                butSave.width = buttonWidth;\r\n                butSave.height = buttonHeight;\r\n                butSave.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n                butSave.thickness = 2;\r\n                butSave.fontSize = buttonFontSize;\r\n                if (options.savedColors.length < options.swatchLimit!) {\r\n                    butSave.color = buttonColor;\r\n                    butSave.background = buttonBackgroundColor;\r\n                } else {\r\n                    disableButton(butSave, true);\r\n                }\r\n                butSave.onPointerEnterObservable.add(() => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            butSave.background = buttonBackgroundHoverColor;\r\n                        }\r\n                    }\r\n                });\r\n                butSave.onPointerOutObservable.add(() => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            butSave.background = buttonBackgroundColor;\r\n                        }\r\n                    }\r\n                });\r\n                butSave.pointerDownAnimation = () => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            butSave.background = buttonBackgroundClickColor;\r\n                        }\r\n                    }\r\n                };\r\n                butSave.pointerUpAnimation = () => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            butSave.background = buttonBackgroundHoverColor;\r\n                        }\r\n                    }\r\n                };\r\n                butSave.onPointerClickObservable.add(() => {\r\n                    if (options.savedColors) {\r\n                        if (options.savedColors.length == 0) {\r\n                            setEditButtonVisibility(true);\r\n                        }\r\n                        if (options.savedColors.length < options.swatchLimit!) {\r\n                            updateSwatches(newSwatch.background, butSave);\r\n                        }\r\n                        editSwatches(false);\r\n                    }\r\n                });\r\n                if (options.savedColors.length > 0) {\r\n                    setEditButtonVisibility(true);\r\n                }\r\n                buttonGrid.addControl(butSave, 2, 0);\r\n            }\r\n\r\n            // Picker color values input\r\n            const pickerColorValues: Grid = new Grid();\r\n            pickerColorValues.name = \"Dialog Lower Right\";\r\n            pickerColorValues.addRowDefinition(0.02, false);\r\n            pickerColorValues.addRowDefinition(0.63, false);\r\n            pickerColorValues.addRowDefinition(0.21, false);\r\n            pickerColorValues.addRowDefinition(0.14, false);\r\n            pickerBodyRight.addControl(pickerColorValues, 1, 0);\r\n\r\n            // RGB values text boxes\r\n            const currentColor = Color3.FromHexString(options.lastColor);\r\n            const rgbValuesQuadrant: Grid = new Grid();\r\n            rgbValuesQuadrant.name = \"RGB Values\";\r\n            rgbValuesQuadrant.width = 0.82;\r\n            rgbValuesQuadrant.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n            rgbValuesQuadrant.addRowDefinition(1 / 3, false);\r\n            rgbValuesQuadrant.addRowDefinition(1 / 3, false);\r\n            rgbValuesQuadrant.addRowDefinition(1 / 3, false);\r\n            rgbValuesQuadrant.addColumnDefinition(0.1, false);\r\n            rgbValuesQuadrant.addColumnDefinition(0.2, false);\r\n            rgbValuesQuadrant.addColumnDefinition(0.7, false);\r\n            pickerColorValues.addControl(rgbValuesQuadrant, 1, 0);\r\n\r\n            for (let i = 0; i < inputFieldLabels.length; i++) {\r\n                const labelText: TextBlock = new TextBlock();\r\n                labelText.text = inputFieldLabels[i];\r\n                labelText.color = buttonColor;\r\n                labelText.fontSize = buttonFontSize;\r\n                rgbValuesQuadrant.addControl(labelText, i, 0);\r\n            }\r\n\r\n            // Input fields for RGB values\r\n            const rValInt = new InputText();\r\n            rValInt.width = 0.83;\r\n            rValInt.height = 0.72;\r\n            rValInt.name = \"rIntField\";\r\n            rValInt.fontSize = buttonFontSize;\r\n            rValInt.text = (currentColor.r * 255).toString();\r\n            rValInt.color = inputTextColor;\r\n            rValInt.background = inputTextBackgroundColor;\r\n            rValInt.onFocusObservable.add(() => {\r\n                activeField = rValInt.name!;\r\n                lastVal = rValInt.text;\r\n                editSwatches(false);\r\n            });\r\n            rValInt.onBlurObservable.add(() => {\r\n                if (rValInt.text == \"\") {\r\n                    rValInt.text = \"0\";\r\n                }\r\n                updateInt(rValInt, \"r\");\r\n                if (activeField == rValInt.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            rValInt.onTextChangedObservable.add(() => {\r\n                if (activeField == rValInt.name) {\r\n                    updateInt(rValInt, \"r\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(rValInt, 0, 1);\r\n\r\n            const gValInt = new InputText();\r\n            gValInt.width = 0.83;\r\n            gValInt.height = 0.72;\r\n            gValInt.name = \"gIntField\";\r\n            gValInt.fontSize = buttonFontSize;\r\n            gValInt.text = (currentColor.g * 255).toString();\r\n            gValInt.color = inputTextColor;\r\n            gValInt.background = inputTextBackgroundColor;\r\n            gValInt.onFocusObservable.add(() => {\r\n                activeField = gValInt.name!;\r\n                lastVal = gValInt.text;\r\n                editSwatches(false);\r\n            });\r\n            gValInt.onBlurObservable.add(() => {\r\n                if (gValInt.text == \"\") {\r\n                    gValInt.text = \"0\";\r\n                }\r\n                updateInt(gValInt, \"g\");\r\n                if (activeField == gValInt.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            gValInt.onTextChangedObservable.add(() => {\r\n                if (activeField == gValInt.name) {\r\n                    updateInt(gValInt, \"g\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(gValInt, 1, 1);\r\n\r\n            const bValInt = new InputText();\r\n            bValInt.width = 0.83;\r\n            bValInt.height = 0.72;\r\n            bValInt.name = \"bIntField\";\r\n            bValInt.fontSize = buttonFontSize;\r\n            bValInt.text = (currentColor.b * 255).toString();\r\n            bValInt.color = inputTextColor;\r\n            bValInt.background = inputTextBackgroundColor;\r\n            bValInt.onFocusObservable.add(() => {\r\n                activeField = bValInt.name!;\r\n                lastVal = bValInt.text;\r\n                editSwatches(false);\r\n            });\r\n            bValInt.onBlurObservable.add(() => {\r\n                if (bValInt.text == \"\") {\r\n                    bValInt.text = \"0\";\r\n                }\r\n                updateInt(bValInt, \"b\");\r\n                if (activeField == bValInt.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            bValInt.onTextChangedObservable.add(() => {\r\n                if (activeField == bValInt.name) {\r\n                    updateInt(bValInt, \"b\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(bValInt, 2, 1);\r\n\r\n            const rValDec = new InputText();\r\n            rValDec.width = 0.95;\r\n            rValDec.height = 0.72;\r\n            rValDec.name = \"rDecField\";\r\n            rValDec.fontSize = buttonFontSize;\r\n            rValDec.text = currentColor.r.toString();\r\n            rValDec.color = inputTextColor;\r\n            rValDec.background = inputTextBackgroundColor;\r\n            rValDec.onFocusObservable.add(() => {\r\n                activeField = rValDec.name!;\r\n                lastVal = rValDec.text;\r\n                editSwatches(false);\r\n            });\r\n            rValDec.onBlurObservable.add(() => {\r\n                if (parseFloat(rValDec.text) == 0 || rValDec.text == \"\") {\r\n                    rValDec.text = \"0\";\r\n                    updateFloat(rValDec, \"r\");\r\n                }\r\n                if (activeField == rValDec.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            rValDec.onTextChangedObservable.add(() => {\r\n                if (activeField == rValDec.name) {\r\n                    updateFloat(rValDec, \"r\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(rValDec, 0, 2);\r\n\r\n            const gValDec = new InputText();\r\n            gValDec.width = 0.95;\r\n            gValDec.height = 0.72;\r\n            gValDec.name = \"gDecField\";\r\n            gValDec.fontSize = buttonFontSize;\r\n            gValDec.text = currentColor.g.toString();\r\n            gValDec.color = inputTextColor;\r\n            gValDec.background = inputTextBackgroundColor;\r\n            gValDec.onFocusObservable.add(() => {\r\n                activeField = gValDec.name!;\r\n                lastVal = gValDec.text;\r\n                editSwatches(false);\r\n            });\r\n            gValDec.onBlurObservable.add(() => {\r\n                if (parseFloat(gValDec.text) == 0 || gValDec.text == \"\") {\r\n                    gValDec.text = \"0\";\r\n                    updateFloat(gValDec, \"g\");\r\n                }\r\n                if (activeField == gValDec.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            gValDec.onTextChangedObservable.add(() => {\r\n                if (activeField == gValDec.name) {\r\n                    updateFloat(gValDec, \"g\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(gValDec, 1, 2);\r\n\r\n            const bValDec = new InputText();\r\n            bValDec.width = 0.95;\r\n            bValDec.height = 0.72;\r\n            bValDec.name = \"bDecField\";\r\n            bValDec.fontSize = buttonFontSize;\r\n            bValDec.text = currentColor.b.toString();\r\n            bValDec.color = inputTextColor;\r\n            bValDec.background = inputTextBackgroundColor;\r\n            bValDec.onFocusObservable.add(() => {\r\n                activeField = bValDec.name!;\r\n                lastVal = bValDec.text;\r\n                editSwatches(false);\r\n            });\r\n            bValDec.onBlurObservable.add(() => {\r\n                if (parseFloat(bValDec.text) == 0 || bValDec.text == \"\") {\r\n                    bValDec.text = \"0\";\r\n                    updateFloat(bValDec, \"b\");\r\n                }\r\n                if (activeField == bValDec.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            bValDec.onTextChangedObservable.add(() => {\r\n                if (activeField == bValDec.name) {\r\n                    updateFloat(bValDec, \"b\");\r\n                }\r\n            });\r\n            rgbValuesQuadrant.addControl(bValDec, 2, 2);\r\n\r\n            // Hex value input\r\n            const hexValueQuadrant: Grid = new Grid();\r\n            hexValueQuadrant.name = \"Hex Value\";\r\n            hexValueQuadrant.width = 0.82;\r\n            hexValueQuadrant.addRowDefinition(1.0, false);\r\n            hexValueQuadrant.addColumnDefinition(0.1, false);\r\n            hexValueQuadrant.addColumnDefinition(0.9, false);\r\n            pickerColorValues.addControl(hexValueQuadrant, 2, 0);\r\n\r\n            const labelText: TextBlock = new TextBlock();\r\n            labelText.text = \"#\";\r\n            labelText.color = buttonColor;\r\n            labelText.fontSize = buttonFontSize;\r\n            hexValueQuadrant.addControl(labelText, 0, 0);\r\n\r\n            const hexVal = new InputText();\r\n            hexVal.width = 0.96;\r\n            hexVal.height = 0.72;\r\n            hexVal.name = \"hexField\";\r\n            hexVal.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n            hexVal.fontSize = buttonFontSize;\r\n            const minusPound = options.lastColor.split(\"#\");\r\n            hexVal.text = minusPound[1];\r\n            hexVal.color = inputTextColor;\r\n            hexVal.background = inputTextBackgroundColor;\r\n            hexVal.onFocusObservable.add(() => {\r\n                activeField = hexVal.name!;\r\n                lastVal = hexVal.text;\r\n                editSwatches(false);\r\n            });\r\n            hexVal.onBlurObservable.add(() => {\r\n                if (hexVal.text.length == 3) {\r\n                    const val = hexVal.text.split(\"\");\r\n                    hexVal.text = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\r\n                }\r\n                if (hexVal.text == \"\") {\r\n                    hexVal.text = \"000000\";\r\n                    updateValues(Color3.FromHexString(hexVal.text), \"b\");\r\n                }\r\n                if (activeField == hexVal.name) {\r\n                    activeField = \"\";\r\n                }\r\n            });\r\n            hexVal.onTextChangedObservable.add(() => {\r\n                let newHexValue: string = hexVal.text;\r\n                const checkHex: boolean = /[^0-9A-F]/i.test(newHexValue);\r\n                if ((hexVal.text.length > 6 || checkHex) && activeField == hexVal.name) {\r\n                    hexVal.text = lastVal;\r\n                } else {\r\n                    if (hexVal.text.length < 6) {\r\n                        const leadingZero: number = 6 - hexVal.text.length;\r\n                        for (let i = 0; i < leadingZero; i++) {\r\n                            newHexValue = \"0\" + newHexValue;\r\n                        }\r\n                    }\r\n                    if (hexVal.text.length == 3) {\r\n                        const val: string[] = hexVal.text.split(\"\");\r\n                        newHexValue = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\r\n                    }\r\n                    newHexValue = \"#\" + newHexValue;\r\n                    if (activeField == hexVal.name) {\r\n                        lastVal = hexVal.text;\r\n                        updateValues(Color3.FromHexString(newHexValue), hexVal.name);\r\n                    }\r\n                }\r\n            });\r\n            hexValueQuadrant.addControl(hexVal, 0, 1);\r\n\r\n            if (options.savedColors && options.savedColors.length > 0) {\r\n                updateSwatches(\"\", butSave!);\r\n            }\r\n\r\n            /**\r\n             * Will update all values for InputText and ColorPicker controls based on the BABYLON.Color3 passed to this function.\r\n             * Each InputText control and the ColorPicker control will be tested to see if they are the activeField and if they\r\n             * are will receive no update. This is to prevent the input from the user being overwritten.\r\n             * @param value\r\n             * @param inputField\r\n             */\r\n            function updateValues(value: Color3, inputField: string) {\r\n                activeField = inputField;\r\n                const pickedColor: string = value.toHexString();\r\n                newSwatch.background = pickedColor;\r\n                if (rValInt.name != activeField) {\r\n                    rValInt.text = Math.floor(value.r * 255).toString();\r\n                }\r\n                if (gValInt.name != activeField) {\r\n                    gValInt.text = Math.floor(value.g * 255).toString();\r\n                }\r\n                if (bValInt.name != activeField) {\r\n                    bValInt.text = Math.floor(value.b * 255).toString();\r\n                }\r\n                if (rValDec.name != activeField) {\r\n                    rValDec.text = value.r.toString();\r\n                }\r\n                if (gValDec.name != activeField) {\r\n                    gValDec.text = value.g.toString();\r\n                }\r\n                if (bValDec.name != activeField) {\r\n                    bValDec.text = value.b.toString();\r\n                }\r\n                if (hexVal.name != activeField) {\r\n                    const minusPound: string[] = pickedColor.split(\"#\");\r\n                    hexVal.text = minusPound[1];\r\n                }\r\n                if (picker.name != activeField) {\r\n                    picker.value = value;\r\n                }\r\n            }\r\n\r\n            // When the user enters an integer for R, G, or B we check to make sure it is a valid number and replace if not.\r\n            function updateInt(field: InputText, channel: string) {\r\n                let newValue: string = field.text;\r\n                const checkVal: boolean = /[^0-9]/g.test(newValue);\r\n                if (checkVal) {\r\n                    field.text = lastVal;\r\n                    return;\r\n                } else {\r\n                    if (newValue != \"\") {\r\n                        if (Math.floor(parseInt(newValue)) < 0) {\r\n                            newValue = \"0\";\r\n                        } else if (Math.floor(parseInt(newValue)) > 255) {\r\n                            newValue = \"255\";\r\n                        } else if (isNaN(parseInt(newValue))) {\r\n                            newValue = \"0\";\r\n                        }\r\n                    }\r\n                    if (activeField == field.name) {\r\n                        lastVal = newValue;\r\n                    }\r\n                }\r\n                if (newValue != \"\") {\r\n                    newValue = parseInt(newValue).toString();\r\n                    field.text = newValue;\r\n                    const newSwatchRGB: Color3 = Color3.FromHexString(newSwatch.background);\r\n                    if (activeField == field.name) {\r\n                        if (channel == \"r\") {\r\n                            updateValues(new Color3(parseInt(newValue) / 255, newSwatchRGB.g, newSwatchRGB.b), field.name);\r\n                        } else if (channel == \"g\") {\r\n                            updateValues(new Color3(newSwatchRGB.r, parseInt(newValue) / 255, newSwatchRGB.b), field.name);\r\n                        } else {\r\n                            updateValues(new Color3(newSwatchRGB.r, newSwatchRGB.g, parseInt(newValue) / 255), field.name);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // When the user enters a float for R, G, or B we check to make sure it is a valid number and replace if not.\r\n            function updateFloat(field: InputText, channel: string) {\r\n                let newValue: string = field.text;\r\n                const checkVal: boolean = /[^0-9.]/g.test(newValue);\r\n                if (checkVal) {\r\n                    field.text = lastVal;\r\n                    return;\r\n                } else {\r\n                    if (newValue != \"\" && newValue != \".\" && parseFloat(newValue) != 0) {\r\n                        if (parseFloat(newValue) < 0.0) {\r\n                            newValue = \"0.0\";\r\n                        } else if (parseFloat(newValue) > 1.0) {\r\n                            newValue = \"1.0\";\r\n                        } else if (isNaN(parseFloat(newValue))) {\r\n                            newValue = \"0.0\";\r\n                        }\r\n                    }\r\n                    if (activeField == field.name) {\r\n                        lastVal = newValue;\r\n                    }\r\n                }\r\n                if (newValue != \"\" && newValue != \".\" && parseFloat(newValue) != 0) {\r\n                    newValue = parseFloat(newValue).toString();\r\n                    field.text = newValue;\r\n                } else {\r\n                    newValue = \"0.0\";\r\n                }\r\n                const newSwatchRGB = Color3.FromHexString(newSwatch.background);\r\n                if (activeField == field.name) {\r\n                    if (channel == \"r\") {\r\n                        updateValues(new Color3(parseFloat(newValue), newSwatchRGB.g, newSwatchRGB.b), field.name);\r\n                    } else if (channel == \"g\") {\r\n                        updateValues(new Color3(newSwatchRGB.r, parseFloat(newValue), newSwatchRGB.b), field.name);\r\n                    } else {\r\n                        updateValues(new Color3(newSwatchRGB.r, newSwatchRGB.g, parseFloat(newValue)), field.name);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Removes the current index from the savedColors array. Drawer can then be regenerated.\r\n            function deleteSwatch(index: number) {\r\n                if (options.savedColors) {\r\n                    options.savedColors.splice(index, 1);\r\n                }\r\n                if (options.savedColors && options.savedColors.length == 0) {\r\n                    setEditButtonVisibility(false);\r\n                    editSwatchMode = false;\r\n                }\r\n            }\r\n\r\n            // Creates and styles an individual swatch when updateSwatches is called.\r\n            function createSwatch() {\r\n                if (options.savedColors && options.savedColors[swatchNumber]) {\r\n                    let icon: string;\r\n                    if (editSwatchMode) {\r\n                        icon = \"b\";\r\n                    } else {\r\n                        icon = \"\";\r\n                    }\r\n                    const swatch: Button = Button.CreateSimpleButton(\"Swatch_\" + swatchNumber, icon);\r\n                    swatch.fontFamily = \"coreglyphs\";\r\n                    const swatchColor: Color3 = Color3.FromHexString(options.savedColors[swatchNumber]);\r\n                    const swatchLuminence: number = swatchColor.r + swatchColor.g + swatchColor.b;\r\n\r\n                    // Set color of outline and textBlock based on luminance of the color swatch so feedback always visible\r\n                    if (swatchLuminence > luminanceLimit) {\r\n                        swatch.color = iconColorDark;\r\n                    } else {\r\n                        swatch.color = iconColorLight;\r\n                    }\r\n                    swatch.fontSize = Math.floor(swatchSize * 0.7);\r\n                    swatch.textBlock!.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n                    swatch.height = swatch.width = swatchSize.toString() + \"px\";\r\n                    swatch.background = options.savedColors[swatchNumber];\r\n                    swatch.thickness = 2;\r\n                    const metadata = swatchNumber;\r\n                    swatch.pointerDownAnimation = () => {\r\n                        swatch.thickness = 4;\r\n                    };\r\n                    swatch.pointerUpAnimation = () => {\r\n                        swatch.thickness = 3;\r\n                    };\r\n                    swatch.pointerEnterAnimation = () => {\r\n                        swatch.thickness = 3;\r\n                    };\r\n                    swatch.pointerOutAnimation = () => {\r\n                        swatch.thickness = 2;\r\n                    };\r\n                    swatch.onPointerClickObservable.add(() => {\r\n                        if (!editSwatchMode) {\r\n                            if (options.savedColors) {\r\n                                updateValues(Color3.FromHexString(options.savedColors[metadata]), swatch.name!);\r\n                            }\r\n                        } else {\r\n                            deleteSwatch(metadata);\r\n                            updateSwatches(\"\", butSave);\r\n                        }\r\n                    });\r\n                    return swatch;\r\n                } else {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            // Mode switch to render button text and close symbols on swatch controls\r\n            function editSwatches(mode?: boolean) {\r\n                if (mode !== undefined) {\r\n                    editSwatchMode = mode;\r\n                }\r\n                let thisButton: Button;\r\n                if (editSwatchMode) {\r\n                    for (let i = 0; i < swatchDrawer.children.length; i++) {\r\n                        thisButton = swatchDrawer.children[i] as Button;\r\n                        thisButton.textBlock!.text = \"b\";\r\n                    }\r\n                    if (butEdit !== undefined) {\r\n                        butEdit.textBlock!.text = \"Done\";\r\n                    }\r\n                } else {\r\n                    for (let i = 0; i < swatchDrawer.children.length; i++) {\r\n                        thisButton = swatchDrawer.children[i] as Button;\r\n                        thisButton.textBlock!.text = \"\";\r\n                    }\r\n                    if (butEdit !== undefined) {\r\n                        butEdit.textBlock!.text = \"Edit\";\r\n                    }\r\n                }\r\n            }\r\n\r\n            /**\r\n             * When Save Color button is pressed this function will first create a swatch drawer if one is not already\r\n             * made. Then all controls are removed from the drawer and we step through the savedColors array and\r\n             * creates one swatch per color. It will also set the height of the drawer control based on how many\r\n             * saved colors there are and how many can be stored per row.\r\n             * @param color\r\n             * @param button\r\n             */\r\n            function updateSwatches(color: string, button: Button) {\r\n                if (options.savedColors) {\r\n                    if (color != \"\") {\r\n                        options.savedColors.push(color);\r\n                    }\r\n                    swatchNumber = 0;\r\n                    swatchDrawer.clearControls();\r\n                    const rowCount: number = Math.ceil(options.savedColors.length / options.numSwatchesPerLine!);\r\n                    let gutterCount: number;\r\n                    if (rowCount == 0) {\r\n                        gutterCount = 0;\r\n                    } else {\r\n                        gutterCount = rowCount + 1;\r\n                    }\r\n                    if (swatchDrawer.rowCount != rowCount + gutterCount) {\r\n                        const currentRows: number = swatchDrawer.rowCount;\r\n                        for (let i = 0; i < currentRows; i++) {\r\n                            swatchDrawer.removeRowDefinition(0);\r\n                        }\r\n                        for (let i = 0; i < rowCount + gutterCount; i++) {\r\n                            if (i % 2) {\r\n                                swatchDrawer.addRowDefinition(swatchSize, true);\r\n                            } else {\r\n                                swatchDrawer.addRowDefinition(gutterSize, true);\r\n                            }\r\n                        }\r\n                    }\r\n                    swatchDrawer.height = (swatchSize * rowCount + gutterCount * gutterSize).toString() + \"px\";\r\n\r\n                    for (let y = 1, thisRow = 1; y < rowCount + gutterCount; y += 2, thisRow++) {\r\n                        // Determine number of buttons to create per row based on the button limit per row and number of saved colors\r\n                        let totalButtonsThisRow: number;\r\n                        if (options.savedColors.length > thisRow * options.numSwatchesPerLine!) {\r\n                            totalButtonsThisRow = options.numSwatchesPerLine!;\r\n                        } else {\r\n                            totalButtonsThisRow = options.savedColors.length - (thisRow - 1) * options.numSwatchesPerLine!;\r\n                        }\r\n                        const buttonIterations: number = Math.min(Math.max(totalButtonsThisRow, 0), options.numSwatchesPerLine!);\r\n                        for (let x = 0, w = 1; x < buttonIterations; x++) {\r\n                            if (x > options.numSwatchesPerLine!) {\r\n                                continue;\r\n                            }\r\n                            const swatch: Button | null = createSwatch();\r\n                            if (swatch != null) {\r\n                                swatchDrawer.addControl(swatch, y, w);\r\n                                w += 2;\r\n                                swatchNumber++;\r\n                            } else {\r\n                                continue;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (options.savedColors.length >= options.swatchLimit!) {\r\n                        disableButton(button, true);\r\n                    } else {\r\n                        disableButton(button, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Shows or hides edit swatches button depending on if there are saved swatches\r\n            function setEditButtonVisibility(enableButton: boolean) {\r\n                if (enableButton) {\r\n                    butEdit = Button.CreateSimpleButton(\"butEdit\", \"Edit\");\r\n                    butEdit.width = buttonWidth;\r\n                    butEdit.height = buttonHeight;\r\n                    butEdit.left = Math.floor(parseInt(buttonWidth) * 0.1).toString() + \"px\";\r\n                    butEdit.top = (parseFloat(butEdit.left) * -1).toString() + \"px\";\r\n                    butEdit.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n                    butEdit.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n                    butEdit.thickness = 2;\r\n                    butEdit.color = buttonColor;\r\n                    butEdit.fontSize = buttonFontSize;\r\n                    butEdit.background = buttonBackgroundColor;\r\n                    butEdit.onPointerEnterObservable.add(() => {\r\n                        butEdit.background = buttonBackgroundHoverColor;\r\n                    });\r\n                    butEdit.onPointerOutObservable.add(() => {\r\n                        butEdit.background = buttonBackgroundColor;\r\n                    });\r\n                    butEdit.pointerDownAnimation = () => {\r\n                        butEdit.background = buttonBackgroundClickColor;\r\n                    };\r\n                    butEdit.pointerUpAnimation = () => {\r\n                        butEdit.background = buttonBackgroundHoverColor;\r\n                    };\r\n                    butEdit.onPointerClickObservable.add(() => {\r\n                        if (editSwatchMode) {\r\n                            editSwatchMode = false;\r\n                        } else {\r\n                            editSwatchMode = true;\r\n                        }\r\n                        editSwatches();\r\n                    });\r\n                    pickerGrid.addControl(butEdit, 1, 0);\r\n                } else {\r\n                    pickerGrid.removeControl(butEdit);\r\n                }\r\n            }\r\n\r\n            // Called when the user hits the limit of saved colors in the drawer.\r\n            function disableButton(button: Button, disabled: boolean) {\r\n                if (disabled) {\r\n                    button.color = buttonDisabledColor;\r\n                    button.background = buttonDisabledBackgroundColor;\r\n                } else {\r\n                    button.color = buttonColor;\r\n                    button.background = buttonBackgroundColor;\r\n                }\r\n            }\r\n\r\n            // Passes last chosen color back to scene and kills dialog by removing from AdvancedDynamicTexture\r\n            function closePicker(color: string) {\r\n                if (options.savedColors && options.savedColors.length > 0) {\r\n                    resolve({\r\n                        savedColors: options.savedColors,\r\n                        pickedColor: color,\r\n                    });\r\n                } else {\r\n                    resolve({\r\n                        pickedColor: color,\r\n                    });\r\n                }\r\n                advancedTexture.removeControl(dialogContainer);\r\n            }\r\n        });\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.ColorPicker\", ColorPicker);\r\n", "import { Container } from \"./container\";\r\nimport { Control } from \"./control\";\r\nimport type { Measure } from \"../measure\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/** Class used to create 2D ellipse containers */\r\nexport class Ellipse extends Container {\r\n    private _thickness = 1;\r\n\r\n    /** Gets or sets border thickness */\r\n    @serialize()\r\n    public get thickness(): number {\r\n        return this._thickness;\r\n    }\r\n\r\n    public set thickness(value: number) {\r\n        if (this._thickness === value) {\r\n            return;\r\n        }\r\n\r\n        this._thickness = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _arc = 1;\r\n\r\n    /** Gets or sets arcing of the ellipse (ratio of the circumference between 0 and 1) */\r\n    @serialize()\r\n    public get arc(): number {\r\n        return this._arc;\r\n    }\r\n\r\n    public set arc(value: number) {\r\n        if (this._arc === value) {\r\n            return;\r\n        }\r\n\r\n        this._arc = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new Ellipse\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Ellipse\";\r\n    }\r\n\r\n    protected override _localDraw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        Control.drawEllipse(\r\n            this._currentMeasure.left + this._currentMeasure.width / 2,\r\n            this._currentMeasure.top + this._currentMeasure.height / 2,\r\n            this._currentMeasure.width / 2 - this._thickness / 2,\r\n            this._currentMeasure.height / 2 - this._thickness / 2,\r\n            this._arc,\r\n            context\r\n        );\r\n\r\n        if (this._backgroundGradient || this._background) {\r\n            context.fillStyle = this._getBackgroundColor(context);\r\n\r\n            context.fill();\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        if (this._thickness) {\r\n            if (this.color) {\r\n                context.strokeStyle = this.color;\r\n            }\r\n            context.lineWidth = this._thickness;\r\n\r\n            context.stroke();\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    protected override _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._additionalProcessing(parentMeasure, context);\r\n\r\n        this._measureForChildren.width -= 2 * this._thickness;\r\n        this._measureForChildren.height -= 2 * this._thickness;\r\n        this._measureForChildren.left += this._thickness;\r\n        this._measureForChildren.top += this._thickness;\r\n    }\r\n\r\n    protected override _clipForChildren(context: ICanvasRenderingContext) {\r\n        Control.drawEllipse(\r\n            this._currentMeasure.left + this._currentMeasure.width / 2,\r\n            this._currentMeasure.top + this._currentMeasure.height / 2,\r\n            this._currentMeasure.width / 2,\r\n            this._currentMeasure.height / 2,\r\n            this._arc,\r\n            context\r\n        );\r\n\r\n        context.clip();\r\n    }\r\n\r\n    public override _renderHighlightSpecific(context: ICanvasRenderingContext): void {\r\n        Control.drawEllipse(\r\n            this._currentMeasure.left + this._currentMeasure.width / 2,\r\n            this._currentMeasure.top + this._currentMeasure.height / 2,\r\n            this._currentMeasure.width / 2 - this._highlightLineWidth / 2,\r\n            this._currentMeasure.height / 2 - this._highlightLineWidth / 2,\r\n            this._arc,\r\n            context\r\n        );\r\n        context.stroke();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Ellipse\", Ellipse);\r\n", "import type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Button } from \"./button\";\r\nimport type { Control } from \"./control\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport type { IFocusableControl } from \"./focusableControl\";\r\n\r\n/**\r\n * Class used to create a focusable button that can easily handle keyboard events\r\n * @since 5.0.0\r\n */\r\nexport class FocusableButton extends Button implements IFocusableControl {\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n\r\n        this._unfocusedColor = this.color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!this.isReadOnly) {\r\n            // Clicking on button should focus\r\n            this.focus();\r\n        }\r\n\r\n        return super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi);\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.FocusableButton\", FocusableButton);\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport type { VirtualKeyboard } from \"./virtualKeyboard\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Measure } from \"../measure\";\r\nimport { InputText } from \"./inputText\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport type { PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport type { IKeyboardEvent } from \"core/Events/deviceInputEvents\";\r\n\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * Class used to create input text control\r\n */\r\nexport class InputTextArea extends InputText {\r\n    private _textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n    private _textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n\r\n    private _prevText: string = this.text;\r\n\r\n    private _lines: any[];\r\n    private _lineSpacing: ValueAndUnit = new ValueAndUnit(0);\r\n    private _maxHeight = new ValueAndUnit(1, ValueAndUnit.UNITMODE_PERCENTAGE, false);\r\n\r\n    private _clipTextTop: number;\r\n    private _clipTextLeft: number;\r\n\r\n    private _cursorInfo: { globalStartIndex: number; globalEndIndex: number; relativeStartIndex: number; relativeEndIndex: number; currentLineIndex: number };\r\n    private _highlightCursorInfo: { initialStartIndex: number; initialRelativeStartIndex: number; initialLineIndex: number };\r\n\r\n    /**\r\n     * An event triggered after the text was broken up into lines\r\n     */\r\n    public onLinesReadyObservable = new Observable<InputTextArea>();\r\n\r\n    /** @internal */\r\n    public override _connectedVirtualKeyboard: Nullable<VirtualKeyboard>;\r\n    private _contextForBreakLines: ICanvasRenderingContext;\r\n    private _clickedCoordinateX: Nullable<number>;\r\n    private _clickedCoordinateY: Nullable<number>;\r\n\r\n    private _availableWidth: number;\r\n    private _availableHeight: number;\r\n\r\n    private _scrollTop: Nullable<number>;\r\n\r\n    private _autoStretchHeight: boolean;\r\n\r\n    /** Gets or sets a boolean indicating if the control can auto stretch its height to adapt to the text */\r\n    @serialize()\r\n    public get autoStretchHeight(): boolean {\r\n        return this._autoStretchHeight;\r\n    }\r\n\r\n    public set autoStretchHeight(value: boolean) {\r\n        if (this._autoStretchHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoStretchHeight = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    public override set height(value: string | number) {\r\n        this.fixedRatioMasterIsWidth = false;\r\n\r\n        if (this._height.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._height.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n\r\n        this._autoStretchHeight = false;\r\n    }\r\n\r\n    @serialize()\r\n    public get maxHeight(): string | number {\r\n        return this._maxHeight.toString(this._host);\r\n    }\r\n\r\n    /** Gets the maximum width allowed by the control in pixels */\r\n    public get maxHeightInPixels(): number {\r\n        return this._maxHeight.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n    }\r\n\r\n    public set maxHeight(value: string | number) {\r\n        if (this._maxHeight.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._maxHeight.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputTextArea\r\n     * @param name defines the control name\r\n     * @param text defines the text of the control\r\n     */\r\n    constructor(\r\n        public override name?: string,\r\n        text: string = \"\"\r\n    ) {\r\n        super(name);\r\n\r\n        this.text = text;\r\n\r\n        this.isPointerBlocker = true;\r\n\r\n        this.onLinesReadyObservable.add(() => this._updateCursorPosition());\r\n\r\n        this._highlightCursorInfo = {\r\n            initialStartIndex: -1,\r\n            initialRelativeStartIndex: -1,\r\n            initialLineIndex: -1,\r\n        };\r\n\r\n        this._cursorInfo = {\r\n            globalStartIndex: 0,\r\n            globalEndIndex: 0,\r\n            relativeEndIndex: 0,\r\n            relativeStartIndex: 0,\r\n            currentLineIndex: 0,\r\n        };\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"InputTextArea\";\r\n    }\r\n\r\n    /**\r\n     * Handles the keyboard event\r\n     * @param evt Defines the KeyboardEvent\r\n     */\r\n    public override processKeyboard(evt: IKeyboardEvent): void {\r\n        if (this.isReadOnly) {\r\n            return;\r\n        }\r\n\r\n        // process pressed key\r\n        this.alternativeProcessKey(evt.code, evt.key, evt);\r\n\r\n        this.onKeyboardEventProcessedObservable.notifyObservers(evt);\r\n    }\r\n\r\n    /**\r\n     * Process the last keyboard input\r\n     *\r\n     * @param code The ascii input number\r\n     * @param key The key string representation\r\n     * @param evt The keyboard event emits with input\r\n     * @internal\r\n     */\r\n    public alternativeProcessKey(code: string, key?: string, evt?: IKeyboardEvent) {\r\n        //return if clipboard event keys (i.e -ctr/cmd + c,v,x)\r\n        if (evt && (evt.ctrlKey || evt.metaKey) && (key === \"c\" || key === \"v\" || key === \"x\")) {\r\n            return;\r\n        }\r\n\r\n        // Specific cases\r\n        switch (code) {\r\n            case \"Period\": //SLASH\r\n                if (evt && evt.shiftKey) {\r\n                    evt.preventDefault();\r\n                }\r\n                break;\r\n            case \"Backspace\": // BACKSPACE\r\n                if (!this._isTextHighlightOn && this._cursorInfo.globalStartIndex > 0) {\r\n                    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                    this._cursorInfo.globalStartIndex--;\r\n                }\r\n                this._prevText = this._textWrapper.text;\r\n                this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\r\n\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n\r\n                this._textHasChanged();\r\n                break;\r\n            case \"Delete\": // DELETE\r\n                if (!this._isTextHighlightOn && this._cursorInfo.globalEndIndex < this.text.length) {\r\n                    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex + 1;\r\n                }\r\n                this._prevText = this._textWrapper.text;\r\n                this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\r\n\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n                if (evt) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n\r\n                this._textHasChanged();\r\n                break;\r\n            case \"NumpadEnter\": // NUMPAD ENTER\r\n            case \"Enter\": // RETURN\r\n                this._prevText = this._textWrapper.text;\r\n                this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, \"\\n\");\r\n                this._cursorInfo.globalStartIndex++;\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n\r\n                this._textHasChanged();\r\n                return;\r\n            case \"End\": // END\r\n                this._cursorInfo.globalStartIndex = this.text.length;\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            case \"Home\": // HOME\r\n                this._cursorInfo.globalStartIndex = 0;\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n                this._markAsDirty();\r\n                return;\r\n            case \"ArrowLeft\": // LEFT\r\n                this._markAsDirty();\r\n\r\n                if (evt && evt.shiftKey) {\r\n                    // shift + ctrl/cmd + <-\r\n                    if (evt.ctrlKey || evt.metaKey) {\r\n                        // Go to line's start by substract the relativeStartIndex to the globalStartIndex\r\n                        this._cursorInfo.globalStartIndex -= this._cursorInfo.relativeStartIndex;\r\n                        this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\r\n                    }\r\n                    // store the starting point\r\n                    if (!this._isTextHighlightOn) {\r\n                        this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                        this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                        this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n\r\n                        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                        this._cursorInfo.globalStartIndex--;\r\n                        this._isTextHighlightOn = true;\r\n                    } else {\r\n                        if (this._cursorInfo.globalEndIndex > this._highlightCursorInfo.initialStartIndex) {\r\n                            this._cursorInfo.globalEndIndex--;\r\n                        } else {\r\n                            this._cursorInfo.globalStartIndex--;\r\n                        }\r\n                    }\r\n                    this._blinkIsEven = true;\r\n                    evt.preventDefault();\r\n                    return;\r\n                }\r\n\r\n                if (this._isTextHighlightOn) {\r\n                    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                } else if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    // ctr + <-\r\n                    this._cursorInfo.globalStartIndex -= this._cursorInfo.relativeStartIndex;\r\n                    evt.preventDefault();\r\n                } else if (this._cursorInfo.globalStartIndex > 0) {\r\n                    this._cursorInfo.globalStartIndex--;\r\n                }\r\n\r\n                // update the cursor\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n                return;\r\n            case \"ArrowRight\": // RIGHT\r\n                this._markAsDirty();\r\n\r\n                if (evt && evt.shiftKey) {\r\n                    // shift + ctrl/cmd + ->\r\n                    if (evt.ctrlKey || evt.metaKey) {\r\n                        const rightDelta = this._lines[this._cursorInfo.currentLineIndex].text.length - this._cursorInfo.relativeEndIndex - 1;\r\n                        this._cursorInfo.globalEndIndex += rightDelta;\r\n                        this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\r\n                    }\r\n                    // store the starting point\r\n                    if (!this._isTextHighlightOn) {\r\n                        this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                        this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                        this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n\r\n                        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                        this._cursorInfo.globalEndIndex++;\r\n                        this._isTextHighlightOn = true;\r\n                    } else {\r\n                        if (this._cursorInfo.globalStartIndex < this._highlightCursorInfo.initialStartIndex) {\r\n                            this._cursorInfo.globalStartIndex++;\r\n                        } else {\r\n                            this._cursorInfo.globalEndIndex++;\r\n                        }\r\n                    }\r\n                    this._blinkIsEven = true;\r\n                    evt.preventDefault();\r\n                    return;\r\n                }\r\n                if (this._isTextHighlightOn) {\r\n                    this._cursorInfo.globalStartIndex = this._cursorInfo.globalEndIndex;\r\n                } else if (evt && (evt.ctrlKey || evt.metaKey)) {\r\n                    //ctr + ->\r\n                    const rightDelta = this._lines[this._cursorInfo.currentLineIndex].text.length - this._cursorInfo.relativeEndIndex;\r\n                    this._cursorInfo.globalStartIndex += rightDelta;\r\n                } else if (this._cursorInfo.globalStartIndex < this.text.length) {\r\n                    this._cursorInfo.globalStartIndex++;\r\n                }\r\n\r\n                // update the cursor\r\n                this._blinkIsEven = false;\r\n                this._isTextHighlightOn = false;\r\n                return;\r\n            case \"ArrowUp\": // UP\r\n                // update the cursor\r\n                this._blinkIsEven = false;\r\n\r\n                if (evt) {\r\n                    if (evt.shiftKey) {\r\n                        if (!this._isTextHighlightOn) {\r\n                            this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                            this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                            this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n                        }\r\n                        this._isTextHighlightOn = true;\r\n                        this._blinkIsEven = true;\r\n                    } else {\r\n                        this._isTextHighlightOn = false;\r\n                    }\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                if (this._cursorInfo.currentLineIndex === 0) {\r\n                    // First line\r\n                    this._cursorInfo.globalStartIndex = 0;\r\n                } else {\r\n                    const currentLine = this._lines[this._cursorInfo.currentLineIndex];\r\n                    const upperLine = this._lines[this._cursorInfo.currentLineIndex - 1];\r\n\r\n                    let tmpIndex = 0;\r\n                    let relativeIndex = 0;\r\n                    if (!this._isTextHighlightOn || this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\r\n                        tmpIndex = this._cursorInfo.globalStartIndex;\r\n                        relativeIndex = this._cursorInfo.relativeStartIndex;\r\n                    } else {\r\n                        tmpIndex = this._cursorInfo.globalEndIndex;\r\n                        relativeIndex = this._cursorInfo.relativeEndIndex;\r\n                    }\r\n\r\n                    const currentText = currentLine.text.substring(0, relativeIndex);\r\n                    const currentWidth = this._contextForBreakLines.measureText(currentText).width;\r\n\r\n                    let upperWidth = 0;\r\n                    let previousWidth = 0;\r\n\r\n                    tmpIndex -= relativeIndex; // Start of current line\r\n                    tmpIndex -= upperLine.text.length + upperLine.lineEnding.length; // Start of upper line\r\n                    let upperLineRelativeIndex = 0;\r\n\r\n                    while (upperWidth < currentWidth && upperLineRelativeIndex < upperLine.text.length) {\r\n                        tmpIndex++;\r\n                        upperLineRelativeIndex++;\r\n                        previousWidth = Math.abs(currentWidth - upperWidth);\r\n                        upperWidth = this._contextForBreakLines.measureText(upperLine.text.substring(0, upperLineRelativeIndex)).width;\r\n                    }\r\n\r\n                    // Find closest move\r\n                    if (Math.abs(currentWidth - upperWidth) > previousWidth && upperLineRelativeIndex > 0) {\r\n                        tmpIndex--;\r\n                    }\r\n\r\n                    if (!this._isTextHighlightOn) {\r\n                        this._cursorInfo.globalStartIndex = tmpIndex;\r\n                    } else if (this._cursorInfo.currentLineIndex <= this._highlightCursorInfo.initialLineIndex) {\r\n                        this._cursorInfo.globalStartIndex = tmpIndex;\r\n                        this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\r\n                        this._cursorInfo.relativeEndIndex = this._highlightCursorInfo.initialRelativeStartIndex;\r\n                    } else {\r\n                        this._cursorInfo.globalEndIndex = tmpIndex;\r\n                    }\r\n                }\r\n\r\n                this._markAsDirty();\r\n                return;\r\n            case \"ArrowDown\": // DOWN\r\n                // update the cursor\r\n                this._blinkIsEven = false;\r\n\r\n                if (evt) {\r\n                    if (evt.shiftKey) {\r\n                        if (!this._isTextHighlightOn) {\r\n                            this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                            this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                            this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n                        }\r\n\r\n                        this._isTextHighlightOn = true;\r\n                        this._blinkIsEven = true;\r\n                    } else {\r\n                        this._isTextHighlightOn = false;\r\n                    }\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                if (this._cursorInfo.currentLineIndex === this._lines.length - 1) {\r\n                    // Last line\r\n                    this._cursorInfo.globalStartIndex = this.text.length;\r\n                } else {\r\n                    const currentLine = this._lines[this._cursorInfo.currentLineIndex];\r\n                    const underLine = this._lines[this._cursorInfo.currentLineIndex + 1];\r\n\r\n                    let tmpIndex = 0;\r\n                    let relativeIndex = 0;\r\n                    if (!this._isTextHighlightOn || this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\r\n                        tmpIndex = this._cursorInfo.globalStartIndex;\r\n                        relativeIndex = this._cursorInfo.relativeStartIndex;\r\n                    } else {\r\n                        tmpIndex = this._cursorInfo.globalEndIndex;\r\n                        relativeIndex = this._cursorInfo.relativeEndIndex;\r\n                    }\r\n\r\n                    const currentText = currentLine.text.substring(0, relativeIndex);\r\n                    const currentWidth = this._contextForBreakLines.measureText(currentText).width;\r\n\r\n                    let underWidth = 0;\r\n                    let previousWidth = 0;\r\n\r\n                    tmpIndex += currentLine.text.length - relativeIndex + currentLine.lineEnding.length; // Start of current line\r\n                    let underLineRelativeIndex = 0;\r\n\r\n                    while (underWidth < currentWidth && underLineRelativeIndex < underLine.text.length) {\r\n                        tmpIndex++;\r\n                        underLineRelativeIndex++;\r\n                        previousWidth = Math.abs(currentWidth - underWidth);\r\n                        underWidth = this._contextForBreakLines.measureText(underLine.text.substring(0, underLineRelativeIndex)).width;\r\n                    }\r\n\r\n                    // Find closest move\r\n                    if (Math.abs(currentWidth - underWidth) > previousWidth && underLineRelativeIndex > 0) {\r\n                        tmpIndex--;\r\n                    }\r\n\r\n                    if (!this._isTextHighlightOn) {\r\n                        this._cursorInfo.globalStartIndex = tmpIndex;\r\n                    } else if (this._cursorInfo.currentLineIndex < this._highlightCursorInfo.initialLineIndex) {\r\n                        this._cursorInfo.globalStartIndex = tmpIndex;\r\n                        if (this._cursorInfo.globalStartIndex > this._cursorInfo.globalEndIndex) {\r\n                            this._cursorInfo.globalEndIndex += this._cursorInfo.globalStartIndex;\r\n                            this._cursorInfo.globalStartIndex = this._cursorInfo.globalEndIndex - this._cursorInfo.globalStartIndex;\r\n                            this._cursorInfo.globalEndIndex -= this._cursorInfo.globalStartIndex;\r\n                        }\r\n                    } else {\r\n                        this._cursorInfo.globalEndIndex = tmpIndex;\r\n                        this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\r\n                    }\r\n                }\r\n\r\n                this._markAsDirty();\r\n                return;\r\n        }\r\n\r\n        // special case - select all. Use key instead of code to support all keyboard layouts\r\n        if (key === \"a\" && evt && (evt.ctrlKey || evt.metaKey)) {\r\n            this.selectAllText();\r\n            evt.preventDefault();\r\n            return;\r\n        }\r\n\r\n        // Printable characters\r\n        if (key?.length === 1) {\r\n            evt?.preventDefault();\r\n            this._currentKey = key;\r\n            this.onBeforeKeyAddObservable.notifyObservers(this);\r\n            key = this._currentKey;\r\n            if (this._addKey) {\r\n                this._isTextHighlightOn = false;\r\n                this._blinkIsEven = false;\r\n                this._prevText = this._textWrapper.text;\r\n                this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, key);\r\n                this._cursorInfo.globalStartIndex += key.length;\r\n                this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n\r\n                this._textHasChanged();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _parseLineWordWrap(line: string = \"\", width: number, context: ICanvasRenderingContext): { text: string; width: number; lineEnding: string }[] {\r\n        const lines = [];\r\n        const words = line.split(\" \");\r\n        let lineWidth = 0;\r\n\r\n        for (let n = 0; n < words.length; n++) {\r\n            const testLine = n > 0 ? line + \" \" + words[n] : words[0];\r\n            const metrics = context.measureText(testLine);\r\n            const testWidth = metrics.width;\r\n            if (testWidth > width) {\r\n                if (n > 0) {\r\n                    // Avoid first word duplication if of too long\r\n                    lineWidth = context.measureText(line).width;\r\n                    lines.push({ text: line, width: lineWidth, lineEnding: \" \" });\r\n                }\r\n\r\n                line = words[n];\r\n\r\n                let flushedLine = \"\";\r\n\r\n                line.split(\"\").map((char) => {\r\n                    if (context.measureText(flushedLine + char).width > width) {\r\n                        lines.push({ text: flushedLine, width: context.measureText(flushedLine).width, lineEnding: \"\" });\r\n                        flushedLine = \"\";\r\n                    }\r\n                    flushedLine += char;\r\n                });\r\n\r\n                line = flushedLine;\r\n                // Measure remaining characters\r\n                lineWidth = context.measureText(line).width;\r\n            } else {\r\n                lineWidth = testWidth;\r\n                line = testLine;\r\n            }\r\n        }\r\n        lines.push({ text: line, width: lineWidth, lineEnding: \" \" });\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _breakLines(refWidth: number, context: ICanvasRenderingContext): object[] {\r\n        const lines: { text: string; width: number; lineEnding: string }[] = [];\r\n        const _lines = (this.text || this.placeholderText).split(\"\\n\");\r\n\r\n        if (this.clipContent) {\r\n            for (const _line of _lines) {\r\n                lines.push(...this._parseLineWordWrap(_line, refWidth, context));\r\n            }\r\n        } else {\r\n            for (const _line of _lines) {\r\n                lines.push(this._parseLine(_line, context));\r\n            }\r\n        }\r\n\r\n        lines[lines.length - 1].lineEnding = \"\\n\";\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _parseLine(line: string = \"\", context: ICanvasRenderingContext): { text: string; width: number; lineEnding: string } {\r\n        return { text: line, width: context.measureText(line).width, lineEnding: \" \" };\r\n    }\r\n\r\n    /**\r\n     * Processing of child right before the parent measurement update\r\n     *\r\n     * @param parentMeasure The parent measure\r\n     * @param context The rendering canvas\r\n     * @internal\r\n     */\r\n    protected override _preMeasure(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        if (!this._fontOffset || this._wasDirty) {\r\n            this._fontOffset = Control._GetFontOffset(context.font, this._host.getScene()?.getEngine());\r\n        }\r\n\r\n        let text = this._beforeRenderText(this._textWrapper).text;\r\n\r\n        // placeholder conditions and color setting\r\n        if (!this.text && this._placeholderText) {\r\n            text = this._placeholderText;\r\n        }\r\n\r\n        // measures the textlength -> this.measure.width\r\n        this._textWidth = context.measureText(text).width;\r\n        // we double up the margin width\r\n        const marginWidth = this._margin.getValueInPixel(this._host, parentMeasure.width) * 2;\r\n\r\n        if (this._autoStretchWidth) {\r\n            const tmpLines = text.split(\"\\n\");\r\n            const longerString = tmpLines.reduce((acc: string, val: string) => {\r\n                const valueLength = context.measureText(val).width;\r\n                const accLength = context.measureText(acc).width;\r\n                return valueLength > accLength ? val : acc;\r\n            }, \"\");\r\n\r\n            const longerStringWidth = context.measureText(longerString).width;\r\n            this.width = Math.min(this._maxWidth.getValueInPixel(this._host, parentMeasure.width), longerStringWidth + marginWidth) + \"px\";\r\n\r\n            this.autoStretchWidth = true;\r\n        }\r\n\r\n        this._availableWidth = this._width.getValueInPixel(this._host, parentMeasure.width) - marginWidth;\r\n\r\n        // Prepare lines\r\n        this._lines = this._breakLines(this._availableWidth, context);\r\n        // can we find a cleaner implementation here?\r\n        this._contextForBreakLines = context;\r\n\r\n        if (this._autoStretchHeight) {\r\n            const textHeight = this._lines.length * this._fontOffset.height;\r\n            const totalHeight = textHeight + this._margin.getValueInPixel(this._host, parentMeasure.height) * 2;\r\n            this.height = Math.min(this._maxHeight.getValueInPixel(this._host, parentMeasure.height), totalHeight) + \"px\";\r\n\r\n            this._autoStretchHeight = true;\r\n        }\r\n\r\n        this._availableHeight = this._height.getValueInPixel(this._host, parentMeasure.height) - marginWidth;\r\n\r\n        if (this._isFocused) {\r\n            this._cursorInfo.currentLineIndex = 0;\r\n\r\n            let lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n            let tmpLength = 0;\r\n\r\n            while (tmpLength + lineLength <= this._cursorInfo.globalStartIndex) {\r\n                tmpLength += lineLength;\r\n\r\n                if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\r\n                    this._cursorInfo.currentLineIndex++;\r\n                    lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _textHasChanged() {\r\n        if (!this._prevText && this._textWrapper.text && this.placeholderText) {\r\n            this._cursorInfo.currentLineIndex = 0;\r\n            this._cursorInfo.globalStartIndex = 1;\r\n            this._cursorInfo.globalEndIndex = 1;\r\n            this._cursorInfo.relativeStartIndex = 1;\r\n            this._cursorInfo.relativeEndIndex = 1;\r\n        }\r\n        super._textHasChanged();\r\n    }\r\n\r\n    private _computeScroll() {\r\n        this._clipTextLeft = this._currentMeasure.left + this._margin.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n        this._clipTextTop = this._currentMeasure.top + this._margin.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n\r\n        if (this._isFocused && this._lines[this._cursorInfo.currentLineIndex].width > this._availableWidth) {\r\n            const textLeft = this._clipTextLeft - this._lines[this._cursorInfo.currentLineIndex].width + this._availableWidth;\r\n\r\n            if (!this._scrollLeft) {\r\n                this._scrollLeft = textLeft;\r\n            }\r\n        } else {\r\n            this._scrollLeft = this._clipTextLeft;\r\n        }\r\n\r\n        if (this._isFocused) {\r\n            const selectedHeight = (this._cursorInfo.currentLineIndex + 1) * this._fontOffset.height;\r\n            const textTop = this._clipTextTop - selectedHeight;\r\n\r\n            if (!this._scrollTop) {\r\n                this._scrollTop = textTop;\r\n            }\r\n        } else {\r\n            this._scrollTop = this._clipTextTop;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processing of child after the parent measurement update\r\n     *\r\n     * @internal\r\n     */\r\n    protected override _additionalProcessing(): void {\r\n        // Flush the highlighted text each frame\r\n        this.highlightedText = \"\";\r\n\r\n        this.onLinesReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _drawText(text: string, textWidth: number, y: number, context: ICanvasRenderingContext): void {\r\n        const width = this._currentMeasure.width;\r\n        let x = this._scrollLeft as number;\r\n        switch (this._textHorizontalAlignment) {\r\n            case Control.HORIZONTAL_ALIGNMENT_LEFT:\r\n                x += 0;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_RIGHT:\r\n                x += width - textWidth;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_CENTER:\r\n                x += (width - textWidth) / 2;\r\n                break;\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        if (this.outlineWidth) {\r\n            context.strokeText(text, this._currentMeasure.left + x, y);\r\n        }\r\n        context.fillText(text, x, y);\r\n    }\r\n\r\n    /**\r\n     * Copy the text in the clipboard\r\n     *\r\n     * @param ev The clipboard event\r\n     * @internal\r\n     */\r\n    protected override _onCopyText(ev: ClipboardEvent): void {\r\n        this._isTextHighlightOn = false;\r\n        //when write permission to clipbaord data is denied\r\n        try {\r\n            ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\r\n        } catch {} //pass\r\n        this._host.clipboardData = this._highlightedText;\r\n    }\r\n\r\n    /**\r\n     * Cut the text and copy it in the clipboard\r\n     *\r\n     * @param ev The clipboard event\r\n     * @internal\r\n     */\r\n    protected override _onCutText(ev: ClipboardEvent): void {\r\n        if (!this._highlightedText) {\r\n            return;\r\n        }\r\n        //when write permission to clipbaord data is denied\r\n        try {\r\n            ev.clipboardData && ev.clipboardData.setData(\"text/plain\", this._highlightedText);\r\n        } catch {} //pass\r\n\r\n        this._host.clipboardData = this._highlightedText;\r\n        this._prevText = this._textWrapper.text;\r\n        this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\r\n\r\n        this._textHasChanged();\r\n    }\r\n\r\n    /**\r\n     * Paste the copied text from the clipboard\r\n     *\r\n     * @param ev The clipboard event\r\n     * @internal\r\n     */\r\n    protected override _onPasteText(ev: ClipboardEvent): void {\r\n        let data: string = \"\";\r\n        if (ev.clipboardData && ev.clipboardData.types.indexOf(\"text/plain\") !== -1) {\r\n            data = ev.clipboardData.getData(\"text/plain\");\r\n        } else {\r\n            //get the cached data; returns blank string by default\r\n            data = this._host.clipboardData;\r\n        }\r\n\r\n        this._isTextHighlightOn = false;\r\n        this._prevText = this._textWrapper.text;\r\n        this._textWrapper.removePart(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex, data);\r\n\r\n        const deltaIndex = data.length - (this._cursorInfo.globalEndIndex - this._cursorInfo.globalStartIndex);\r\n\r\n        this._cursorInfo.globalStartIndex += deltaIndex;\r\n        this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n        this._clickedCoordinateX = null;\r\n        this._clickedCoordinateY = null;\r\n\r\n        super._textHasChanged();\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        this._computeScroll();\r\n\r\n        this._scrollLeft = this._scrollLeft ?? 0;\r\n        this._scrollTop = this._scrollTop ?? 0;\r\n\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        // Background\r\n        if (this._isFocused) {\r\n            if (this._focusedBackground) {\r\n                context.fillStyle = this._isEnabled ? this._focusedBackground : this._disabledColor;\r\n\r\n                context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            }\r\n        } else if (this._background) {\r\n            context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\r\n\r\n            context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        // sets the color of the rectangle (border if background available)\r\n        if (this.color) {\r\n            context.fillStyle = this.color;\r\n        }\r\n\r\n        const height = this._currentMeasure.height;\r\n        const width = this._currentMeasure.width;\r\n        let rootY = 0;\r\n\r\n        switch (this._textVerticalAlignment) {\r\n            case Control.VERTICAL_ALIGNMENT_TOP:\r\n                rootY = this._fontOffset.ascent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_BOTTOM:\r\n                rootY = height - this._fontOffset.height * (this._lines.length - 1) - this._fontOffset.descent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_CENTER:\r\n                rootY = this._fontOffset.ascent + (height - this._fontOffset.height * this._lines.length) / 2;\r\n                break;\r\n        }\r\n\r\n        context.save();\r\n        context.beginPath();\r\n        context.fillStyle = this.fontStyle;\r\n        if (!this._textWrapper.text && this.placeholderText) {\r\n            context.fillStyle = this._placeholderColor;\r\n        }\r\n        // here we define the visible reactangle to clip it in next line\r\n        context.rect(this._clipTextLeft, this._clipTextTop, this._availableWidth + 2, this._availableHeight + 2);\r\n        context.clip();\r\n\r\n        // Text\r\n        rootY += this._scrollTop;\r\n\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n\r\n            if (i !== 0 && this._lineSpacing.internalValue !== 0) {\r\n                if (this._lineSpacing.isPixel) {\r\n                    rootY += this._lineSpacing.getValue(this._host);\r\n                } else {\r\n                    rootY = rootY + this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n                }\r\n            }\r\n\r\n            this._drawText(line.text, line.width, rootY, context);\r\n            rootY += this._fontOffset.height;\r\n        }\r\n\r\n        context.restore();\r\n\r\n        // Cursor\r\n        if (this._isFocused) {\r\n            // Render cursor\r\n            if (!this._blinkIsEven || this._isTextHighlightOn) {\r\n                let cursorLeft =\r\n                    this._scrollLeft + context.measureText(this._lines[this._cursorInfo.currentLineIndex].text.substring(0, this._cursorInfo.relativeStartIndex)).width;\r\n\r\n                if (cursorLeft < this._clipTextLeft) {\r\n                    this._scrollLeft += this._clipTextLeft - cursorLeft;\r\n                    cursorLeft = this._clipTextLeft;\r\n                    this._markAsDirty();\r\n                } else if (cursorLeft > this._clipTextLeft + this._availableWidth) {\r\n                    this._scrollLeft += this._clipTextLeft + this._availableWidth - cursorLeft;\r\n                    cursorLeft = this._clipTextLeft + this._availableWidth;\r\n                    this._markAsDirty();\r\n                }\r\n\r\n                let cursorTop = this._scrollTop + this._cursorInfo.currentLineIndex * this._fontOffset.height; //cursorTop distance from top to cursor start\r\n\r\n                if (cursorTop < this._clipTextTop) {\r\n                    this._scrollTop += this._clipTextTop - cursorTop;\r\n                    cursorTop = this._clipTextTop;\r\n                    this._markAsDirty();\r\n                } else if (cursorTop + this._fontOffset.height > this._clipTextTop + this._availableHeight && this._availableHeight > this._fontOffset.height) {\r\n                    this._scrollTop += this._clipTextTop + this._availableHeight - cursorTop - this._fontOffset.height;\r\n                    cursorTop = this._clipTextTop + this._availableHeight - this._fontOffset.height;\r\n                    this._markAsDirty();\r\n                }\r\n\r\n                if (!this._isTextHighlightOn) {\r\n                    context.fillRect(cursorLeft, cursorTop, 2, this._fontOffset.height);\r\n                }\r\n            }\r\n\r\n            this._resetBlinking();\r\n\r\n            //show the highlighted text\r\n            if (this._isTextHighlightOn) {\r\n                clearTimeout(this._blinkTimeout);\r\n\r\n                this._highlightedText = this.text.substring(this._cursorInfo.globalStartIndex, this._cursorInfo.globalEndIndex);\r\n\r\n                context.globalAlpha = this._highligherOpacity;\r\n                context.fillStyle = this._textHighlightColor;\r\n\r\n                const startLineIndex = Math.min(this._cursorInfo.currentLineIndex, this._highlightCursorInfo.initialLineIndex);\r\n                const endLineIndex = Math.max(this._cursorInfo.currentLineIndex, this._highlightCursorInfo.initialLineIndex);\r\n\r\n                let highlightRootY = this._scrollTop + startLineIndex * this._fontOffset.height;\r\n\r\n                for (let i = startLineIndex; i <= endLineIndex; i++) {\r\n                    const line = this._lines[i];\r\n\r\n                    let highlightRootX = this._scrollLeft as number;\r\n                    switch (this._textHorizontalAlignment) {\r\n                        case Control.HORIZONTAL_ALIGNMENT_LEFT:\r\n                            highlightRootX += 0;\r\n                            break;\r\n                        case Control.HORIZONTAL_ALIGNMENT_RIGHT:\r\n                            highlightRootX += width - line.width;\r\n                            break;\r\n                        case Control.HORIZONTAL_ALIGNMENT_CENTER:\r\n                            highlightRootX += (width - line.width) / 2;\r\n                            break;\r\n                    }\r\n\r\n                    const begin = i === startLineIndex ? this._cursorInfo.relativeStartIndex : 0;\r\n                    const end = i === endLineIndex ? this._cursorInfo.relativeEndIndex : line.text.length;\r\n\r\n                    const leftOffsetWidth = context.measureText(line.text.substring(0, begin)).width;\r\n                    const selectedText = line.text.substring(begin, end);\r\n                    const hightlightWidth = context.measureText(selectedText).width;\r\n\r\n                    context.fillRect(highlightRootX + leftOffsetWidth, highlightRootY, hightlightWidth, this._fontOffset.height);\r\n\r\n                    highlightRootY += this._fontOffset.height;\r\n                }\r\n\r\n                if (this._cursorInfo.globalEndIndex === this._cursorInfo.globalStartIndex) {\r\n                    this._resetBlinking();\r\n                }\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n\r\n        // Border\r\n        if (this._thickness) {\r\n            if (this._isFocused) {\r\n                if (this.focusedColor) {\r\n                    context.strokeStyle = this.focusedColor;\r\n                }\r\n            } else {\r\n                if (this.color) {\r\n                    context.strokeStyle = this.color;\r\n                }\r\n            }\r\n\r\n            context.lineWidth = this._thickness;\r\n\r\n            context.strokeRect(\r\n                this._currentMeasure.left + this._thickness / 2,\r\n                this._currentMeasure.top + this._thickness / 2,\r\n                this._currentMeasure.width - this._thickness,\r\n                this._currentMeasure.height - this._thickness\r\n            );\r\n        }\r\n    }\r\n\r\n    private _resetBlinking() {\r\n        clearTimeout(this._blinkTimeout);\r\n        this._blinkTimeout = <any>setTimeout(() => {\r\n            this._blinkIsEven = !this._blinkIsEven;\r\n            this._markAsDirty();\r\n        }, 500);\r\n    }\r\n\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        this._clickedCoordinateX = coordinates.x;\r\n        this._clickedCoordinateY = coordinates.y;\r\n\r\n        this._isTextHighlightOn = false;\r\n        this._highlightedText = \"\";\r\n        this._isPointerDown = true;\r\n        this._host._capturingControl[pointerId] = this;\r\n        if (this._host.focusedControl === this) {\r\n            // Move cursor\r\n            clearTimeout(this._blinkTimeout);\r\n            this._markAsDirty();\r\n            return true;\r\n        }\r\n        if (!this._isEnabled) {\r\n            return false;\r\n        }\r\n        this._host.focusedControl = this;\r\n\r\n        return true;\r\n    }\r\n\r\n    // for textselection\r\n    public override _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: PointerInfoBase): void {\r\n        // Avoid Chromium-like beahavior when this event is fired right after onPointerDown\r\n        if (pi.event.movementX === 0 && pi.event.movementY === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this._host.focusedControl === this && this._isPointerDown && !this.isReadOnly) {\r\n            this._clickedCoordinateX = coordinates.x;\r\n            this._clickedCoordinateY = coordinates.y;\r\n\r\n            if (!this._isTextHighlightOn) {\r\n                this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n                this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n                this._highlightCursorInfo.initialRelativeStartIndex = this._cursorInfo.relativeStartIndex;\r\n\r\n                this._isTextHighlightOn = true;\r\n            }\r\n\r\n            this._markAsDirty();\r\n        }\r\n        super._onPointerMove(target, coordinates, pointerId, pi);\r\n    }\r\n\r\n    /**\r\n     * Apply the correct position of cursor according to current modification\r\n     */\r\n    private _updateCursorPosition() {\r\n        if (!this._isFocused) {\r\n            return;\r\n        }\r\n\r\n        if (!this._textWrapper.text && this.placeholderText) {\r\n            this._cursorInfo.currentLineIndex = 0;\r\n            this._cursorInfo.globalStartIndex = 0;\r\n            this._cursorInfo.globalEndIndex = 0;\r\n            this._cursorInfo.relativeStartIndex = 0;\r\n            this._cursorInfo.relativeEndIndex = 0;\r\n        } else {\r\n            if (this._clickedCoordinateX && this._clickedCoordinateY) {\r\n                if (!this._isTextHighlightOn) {\r\n                    this._cursorInfo = {\r\n                        globalStartIndex: 0,\r\n                        globalEndIndex: 0,\r\n                        relativeStartIndex: 0,\r\n                        relativeEndIndex: 0,\r\n                        currentLineIndex: 0,\r\n                    };\r\n                }\r\n\r\n                let globalIndex = 0;\r\n                let relativeIndex = 0;\r\n\r\n                const lastClickedCoordinateY = this._clickedCoordinateY - (this._scrollTop as number);\r\n\r\n                const relativeCoordinateY = Math.floor(lastClickedCoordinateY / this._fontOffset.height);\r\n                this._cursorInfo.currentLineIndex = Math.min(Math.max(relativeCoordinateY, 0), this._lines.length - 1);\r\n\r\n                let currentSize = 0;\r\n\r\n                const relativeXPosition = this._clickedCoordinateX - (this._scrollLeft ?? 0);\r\n\r\n                let previousDist = 0;\r\n\r\n                for (let index = 0; index < this._cursorInfo.currentLineIndex; index++) {\r\n                    const line = this._lines[index];\r\n                    globalIndex += line.text.length + line.lineEnding.length;\r\n                }\r\n\r\n                while (currentSize < relativeXPosition && this._lines[this._cursorInfo.currentLineIndex].text.length > relativeIndex) {\r\n                    relativeIndex++;\r\n                    previousDist = Math.abs(relativeXPosition - currentSize);\r\n                    currentSize = this._contextForBreakLines.measureText(this._lines[this._cursorInfo.currentLineIndex].text.substring(0, relativeIndex)).width;\r\n                }\r\n\r\n                // Find closest move\r\n                if (Math.abs(relativeXPosition - currentSize) > previousDist && relativeIndex > 0) {\r\n                    relativeIndex--;\r\n                }\r\n\r\n                globalIndex += relativeIndex;\r\n\r\n                if (!this._isTextHighlightOn) {\r\n                    this._cursorInfo.globalStartIndex = globalIndex;\r\n                    this._cursorInfo.relativeStartIndex = relativeIndex;\r\n                    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                    this._cursorInfo.relativeEndIndex = this._cursorInfo.relativeStartIndex;\r\n                } else {\r\n                    if (globalIndex < this._highlightCursorInfo.initialStartIndex) {\r\n                        this._cursorInfo.globalStartIndex = globalIndex;\r\n                        this._cursorInfo.relativeStartIndex = relativeIndex;\r\n                        this._cursorInfo.globalEndIndex = this._highlightCursorInfo.initialStartIndex;\r\n                        this._cursorInfo.relativeEndIndex = this._highlightCursorInfo.initialRelativeStartIndex;\r\n                    } else {\r\n                        this._cursorInfo.globalStartIndex = this._highlightCursorInfo.initialStartIndex;\r\n                        this._cursorInfo.relativeStartIndex = this._highlightCursorInfo.initialRelativeStartIndex;\r\n                        this._cursorInfo.globalEndIndex = globalIndex;\r\n                        this._cursorInfo.relativeEndIndex = relativeIndex;\r\n                    }\r\n                }\r\n\r\n                // Avoid the caret during highlighting\r\n                this._blinkIsEven = this._isTextHighlightOn;\r\n                this._clickedCoordinateX = null;\r\n                this._clickedCoordinateY = null;\r\n            } else {\r\n                // Standard behavior same as Current line is at least above the initial highlight index\r\n                this._cursorInfo.relativeStartIndex = 0;\r\n                this._cursorInfo.currentLineIndex = 0;\r\n\r\n                let lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n                let tmpLength = 0;\r\n\r\n                while (tmpLength + lineLength <= this._cursorInfo.globalStartIndex) {\r\n                    tmpLength += lineLength;\r\n\r\n                    if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\r\n                        this._cursorInfo.currentLineIndex++;\r\n                        lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n                    }\r\n                }\r\n\r\n                this._cursorInfo.relativeStartIndex = this._cursorInfo.globalStartIndex - tmpLength;\r\n\r\n                if (!this._isTextHighlightOn) {\r\n                    this._cursorInfo.relativeEndIndex = this._cursorInfo.relativeStartIndex;\r\n                    this._cursorInfo.globalEndIndex = this._cursorInfo.globalStartIndex;\r\n                } else if (this._highlightCursorInfo.initialStartIndex !== -1 && this._cursorInfo.globalStartIndex >= this._highlightCursorInfo.initialStartIndex) {\r\n                    // Current line is at least below the initial highlight index\r\n                    while (tmpLength + lineLength <= this._cursorInfo.globalEndIndex) {\r\n                        tmpLength += lineLength;\r\n\r\n                        if (this._cursorInfo.currentLineIndex < this._lines.length - 1) {\r\n                            this._cursorInfo.currentLineIndex++;\r\n                            lineLength = this._lines[this._cursorInfo.currentLineIndex].text.length + this._lines[this._cursorInfo.currentLineIndex].lineEnding.length;\r\n                        }\r\n                    }\r\n\r\n                    this._cursorInfo.relativeEndIndex = this._cursorInfo.globalEndIndex - tmpLength;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update all values of cursor information based on cursorIndex value\r\n     *\r\n     * @param offset The index to take care of\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected override _updateValueFromCursorIndex(offset: number) {\r\n        // Override to avoid parent behavior during _onPointerMove\r\n    }\r\n\r\n    /**\r\n     * Select the word immediatly under the cursor on double click\r\n     *\r\n     * @param _evt Pointer informations of double click\r\n     * @internal\r\n     */\r\n    protected override _processDblClick(_evt: PointerInfo) {\r\n        //pre-find the start and end index of the word under cursor, speeds up the rendering\r\n        let moveLeft, moveRight;\r\n        do {\r\n            moveLeft = this._cursorInfo.globalStartIndex > 0 && this._textWrapper.isWord(this._cursorInfo.globalStartIndex - 1) ? --this._cursorInfo.globalStartIndex : 0;\r\n            moveRight =\r\n                this._cursorInfo.globalEndIndex < this._textWrapper.length && this._textWrapper.isWord(this._cursorInfo.globalEndIndex) ? ++this._cursorInfo.globalEndIndex : 0;\r\n        } while (moveLeft || moveRight);\r\n\r\n        this._highlightCursorInfo.initialLineIndex = this._cursorInfo.currentLineIndex;\r\n        this._highlightCursorInfo.initialStartIndex = this._cursorInfo.globalStartIndex;\r\n\r\n        this.onTextHighlightObservable.notifyObservers(this);\r\n\r\n        this._isTextHighlightOn = true;\r\n        this._blinkIsEven = true;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    public override selectAllText() {\r\n        this._isTextHighlightOn = true;\r\n        this._blinkIsEven = true;\r\n\r\n        this._highlightCursorInfo = {\r\n            initialStartIndex: 0,\r\n            initialRelativeStartIndex: 0,\r\n            initialLineIndex: 0,\r\n        };\r\n\r\n        this._cursorInfo = {\r\n            globalStartIndex: 0,\r\n            globalEndIndex: this._textWrapper.length,\r\n            relativeEndIndex: this._lines[this._lines.length - 1].text.length,\r\n            relativeStartIndex: 0,\r\n            currentLineIndex: this._lines.length - 1,\r\n        };\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    public override dispose() {\r\n        super.dispose();\r\n\r\n        this.onLinesReadyObservable.clear();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.InputTextArea\", InputTextArea);\r\n", "import { InputText } from \"./inputText\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { TextWrapper } from \"./textWrapper\";\r\n\r\n/**\r\n * Class used to create a password control\r\n */\r\nexport class InputPassword extends InputText {\r\n    protected override _getTypeName(): string {\r\n        return \"InputPassword\";\r\n    }\r\n\r\n    protected override _beforeRenderText(textWrapper: TextWrapper): TextWrapper {\r\n        const pwdTextWrapper = new TextWrapper();\r\n        let txt = \"\";\r\n        for (let i = 0; i < textWrapper.length; i++) {\r\n            txt += \"\\u2022\";\r\n        }\r\n        pwdTextWrapper.text = txt;\r\n        return pwdTextWrapper;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.InputPassword\", InputPassword);\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport type { Measure } from \"../measure\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/** Class used to render 2D lines */\r\nexport class Line extends Control {\r\n    private _lineWidth = 1;\r\n    /** @internal */\r\n    public _x1 = new ValueAndUnit(0);\r\n    /** @internal */\r\n    public _y1 = new ValueAndUnit(0);\r\n    /** @internal */\r\n    public _x2 = new ValueAndUnit(0);\r\n    /** @internal */\r\n    public _y2 = new ValueAndUnit(0);\r\n    private _dash = new Array<number>();\r\n    private _connectedControl: Control;\r\n    private _connectedControlDirtyObserver: Nullable<Observer<Control>>;\r\n\r\n    /** Gets or sets the dash pattern */\r\n    @serialize()\r\n    public get dash(): Array<number> {\r\n        return this._dash;\r\n    }\r\n\r\n    public set dash(value: Array<number>) {\r\n        if (this._dash === value) {\r\n            return;\r\n        }\r\n\r\n        this._dash = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the control connected with the line end */\r\n    public get connectedControl(): Control {\r\n        return this._connectedControl;\r\n    }\r\n\r\n    public set connectedControl(value: Control) {\r\n        if (this._connectedControl === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._connectedControlDirtyObserver && this._connectedControl) {\r\n            this._connectedControl.onDirtyObservable.remove(this._connectedControlDirtyObserver);\r\n            this._connectedControlDirtyObserver = null;\r\n        }\r\n\r\n        if (value) {\r\n            this._connectedControlDirtyObserver = value.onDirtyObservable.add(() => this._markAsDirty());\r\n        }\r\n\r\n        this._connectedControl = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets start coordinates on X axis */\r\n    @serialize()\r\n    public get x1(): string | number {\r\n        return this._x1.toString(this._host);\r\n    }\r\n\r\n    public set x1(value: string | number) {\r\n        if (this._x1.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._x1.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets start coordinates on Y axis */\r\n    @serialize()\r\n    public get y1(): string | number {\r\n        return this._y1.toString(this._host);\r\n    }\r\n\r\n    public set y1(value: string | number) {\r\n        if (this._y1.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._y1.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets end coordinates on X axis */\r\n    @serialize()\r\n    public get x2(): string | number {\r\n        return this._x2.toString(this._host);\r\n    }\r\n\r\n    public set x2(value: string | number) {\r\n        if (this._x2.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._x2.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets end coordinates on Y axis */\r\n    @serialize()\r\n    public get y2(): string | number {\r\n        return this._y2.toString(this._host);\r\n    }\r\n\r\n    public set y2(value: string | number) {\r\n        if (this._y2.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._y2.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets line width */\r\n    @serialize()\r\n    public get lineWidth(): number {\r\n        return this._lineWidth;\r\n    }\r\n\r\n    public set lineWidth(value: number) {\r\n        if (this._lineWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._lineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets horizontal alignment */\r\n    public override set horizontalAlignment(value: number) {\r\n        return;\r\n    }\r\n\r\n    /** Gets or sets vertical alignment */\r\n    public override set verticalAlignment(value: number) {\r\n        return;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _effectiveX2(): number {\r\n        return (this._connectedControl ? this._connectedControl.centerX : 0) + this._x2.getValue(this._host);\r\n    }\r\n\r\n    /** @internal */\r\n    public get _effectiveY2(): number {\r\n        return (this._connectedControl ? this._connectedControl.centerY : 0) + this._y2.getValue(this._host);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Line\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n\r\n        this._automaticSize = true;\r\n\r\n        this.isHitTestVisible = false;\r\n        this._horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this._verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Line\";\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        this._applyStates(context);\r\n        context.strokeStyle = this._getColor(context);\r\n        context.lineWidth = this._lineWidth;\r\n        context.setLineDash(this._dash);\r\n\r\n        context.beginPath();\r\n        context.moveTo(this._cachedParentMeasure.left + this._x1.getValue(this._host), this._cachedParentMeasure.top + this._y1.getValue(this._host));\r\n\r\n        context.lineTo(this._cachedParentMeasure.left + this._effectiveX2, this._cachedParentMeasure.top + this._effectiveY2);\r\n        context.stroke();\r\n\r\n        context.restore();\r\n    }\r\n\r\n    public override _measure(): void {\r\n        // Width / Height\r\n        this._currentMeasure.width = Math.abs(this._x1.getValue(this._host) - this._effectiveX2) + this._lineWidth;\r\n        this._currentMeasure.height = Math.abs(this._y1.getValue(this._host) - this._effectiveY2) + this._lineWidth;\r\n    }\r\n\r\n    protected override _computeAlignment(parentMeasure: Measure): void {\r\n        this._currentMeasure.left = parentMeasure.left + Math.min(this._x1.getValue(this._host), this._effectiveX2) - this._lineWidth / 2;\r\n        this._currentMeasure.top = parentMeasure.top + Math.min(this._y1.getValue(this._host), this._effectiveY2) - this._lineWidth / 2;\r\n    }\r\n\r\n    /**\r\n     * Move one end of the line given 3D cartesian coordinates.\r\n     * @param position Targeted world position\r\n     * @param scene Scene\r\n     * @param end (opt) Set to true to assign x2 and y2 coordinates of the line. Default assign to x1 and y1.\r\n     */\r\n    public override moveToVector3(position: Vector3, scene: Scene, end: boolean = false): void {\r\n        if (!this._host || this.parent !== this._host._rootContainer) {\r\n            Tools.Error(\"Cannot move a control to a vector3 if the control is not at root level\");\r\n            return;\r\n        }\r\n\r\n        const globalViewport = this._host._getGlobalViewport();\r\n        const projectedPosition = Vector3.Project(position, Matrix.IdentityReadOnly, scene.getTransformMatrix(), globalViewport);\r\n\r\n        this._moveToProjectedPosition(projectedPosition, end);\r\n\r\n        if (projectedPosition.z < 0 || projectedPosition.z > 1) {\r\n            this.notRenderable = true;\r\n            return;\r\n        }\r\n        this.notRenderable = false;\r\n    }\r\n\r\n    /**\r\n     * Move one end of the line to a position in screen absolute space.\r\n     * @param projectedPosition Position in screen absolute space (X, Y)\r\n     * @param end (opt) Set to true to assign x2 and y2 coordinates of the line. Default assign to x1 and y1.\r\n     */\r\n    public override _moveToProjectedPosition(projectedPosition: Vector3, end: boolean = false): void {\r\n        const x: string = projectedPosition.x + this._linkOffsetX.getValue(this._host) + \"px\";\r\n        const y: string = projectedPosition.y + this._linkOffsetY.getValue(this._host) + \"px\";\r\n\r\n        if (end) {\r\n            this.x2 = x;\r\n            this.y2 = y;\r\n            this._x2.ignoreAdaptiveScaling = true;\r\n            this._y2.ignoreAdaptiveScaling = true;\r\n        } else {\r\n            this.x1 = x;\r\n            this.y1 = y;\r\n            this._x1.ignoreAdaptiveScaling = true;\r\n            this._y1.ignoreAdaptiveScaling = true;\r\n        }\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Line\", Line);\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\n\r\nimport type { MultiLine } from \"./controls/multiLine\";\r\nimport { ValueAndUnit } from \"./valueAndUnit\";\r\nimport type { Control } from \"./controls/control\";\r\n\r\n/**\r\n * Class used to store a point for a MultiLine object.\r\n * The point can be pure 2D coordinates, a mesh or a control\r\n */\r\nexport class MultiLinePoint {\r\n    private _multiLine: MultiLine;\r\n\r\n    private _x: ValueAndUnit;\r\n    private _y: ValueAndUnit;\r\n    private _control: Nullable<Control>;\r\n    private _mesh: Nullable<AbstractMesh>;\r\n\r\n    private _controlObserver: Nullable<Observer<Control>>;\r\n    private _meshObserver: Nullable<Observer<Camera>>;\r\n\r\n    /** @internal */\r\n    public _point: Vector3;\r\n\r\n    /**\r\n     * Creates a new MultiLinePoint\r\n     * @param multiLine defines the source MultiLine object\r\n     */\r\n    constructor(multiLine: MultiLine) {\r\n        this._multiLine = multiLine;\r\n\r\n        this._x = new ValueAndUnit(0);\r\n        this._y = new ValueAndUnit(0);\r\n\r\n        this._point = new Vector3(0, 0, 0);\r\n    }\r\n\r\n    /** Gets or sets x coordinate */\r\n    public get x(): string | number {\r\n        return this._x.toString(this._multiLine._host);\r\n    }\r\n\r\n    public set x(value: string | number) {\r\n        if (this._x.toString(this._multiLine._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._x.fromString(value)) {\r\n            this._multiLine._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets y coordinate */\r\n    public get y(): string | number {\r\n        return this._y.toString(this._multiLine._host);\r\n    }\r\n\r\n    public set y(value: string | number) {\r\n        if (this._y.toString(this._multiLine._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._y.fromString(value)) {\r\n            this._multiLine._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the control associated with this point */\r\n    public get control(): Nullable<Control> {\r\n        return this._control;\r\n    }\r\n\r\n    public set control(value: Nullable<Control>) {\r\n        if (this._control === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._control && this._controlObserver) {\r\n            this._control.onDirtyObservable.remove(this._controlObserver);\r\n\r\n            this._controlObserver = null;\r\n        }\r\n\r\n        this._control = value;\r\n\r\n        if (this._control) {\r\n            this._controlObserver = this._control.onDirtyObservable.add(this._multiLine.onPointUpdate);\r\n        }\r\n\r\n        this._multiLine._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the mesh associated with this point */\r\n    public get mesh(): Nullable<AbstractMesh> {\r\n        return this._mesh;\r\n    }\r\n\r\n    public set mesh(value: Nullable<AbstractMesh>) {\r\n        if (this._mesh === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._mesh && this._meshObserver) {\r\n            this._mesh.getScene().onAfterCameraRenderObservable.remove(this._meshObserver);\r\n        }\r\n\r\n        this._mesh = value;\r\n\r\n        if (this._mesh) {\r\n            this._meshObserver = this._mesh.getScene().onAfterCameraRenderObservable.add(this._multiLine.onPointUpdate);\r\n        }\r\n\r\n        this._multiLine._markAsDirty();\r\n    }\r\n\r\n    /** Resets links */\r\n    public resetLinks(): void {\r\n        this.control = null;\r\n        this.mesh = null;\r\n    }\r\n\r\n    /**\r\n     * Gets a translation vector with Z component\r\n     * @returns the translation vector\r\n     */\r\n    public translate(): Vector3 {\r\n        this._point = this._translatePoint();\r\n\r\n        return this._point;\r\n    }\r\n\r\n    private _translatePoint(): Vector3 {\r\n        if (this._mesh != null) {\r\n            return this._multiLine._host.getProjectedPositionWithZ(this._mesh.getBoundingInfo().boundingSphere.center, this._mesh.getWorldMatrix());\r\n        } else if (this._control != null) {\r\n            return new Vector3(this._control.centerX, this._control.centerY, 1 - Epsilon);\r\n        } else {\r\n            const host: any = this._multiLine._host as any;\r\n\r\n            const xValue: number = this._x.getValueInPixel(host, Number(host._canvas.width));\r\n            const yValue: number = this._y.getValueInPixel(host, Number(host._canvas.height));\r\n\r\n            return new Vector3(xValue, yValue, 1 - Epsilon);\r\n        }\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose(): void {\r\n        this.resetLinks();\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { MultiLinePoint } from \"../multiLinePoint\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Vector3 } from \"core/Maths/math.vector\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to create multi line control\r\n */\r\nexport class MultiLine extends Control {\r\n    private _lineWidth: number = 1;\r\n    private _dash: number[];\r\n    private _points: Nullable<MultiLinePoint>[];\r\n\r\n    private _minX: Nullable<number>;\r\n    private _minY: Nullable<number>;\r\n    private _maxX: Nullable<number>;\r\n    private _maxY: Nullable<number>;\r\n\r\n    /**\r\n     * Creates a new MultiLine\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n\r\n        this._automaticSize = true;\r\n        this.isHitTestVisible = false;\r\n        this._horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this._verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n\r\n        this._dash = [];\r\n        this._points = [];\r\n    }\r\n\r\n    /** Gets or sets dash pattern */\r\n    @serialize()\r\n    public get dash(): Array<number> {\r\n        return this._dash;\r\n    }\r\n\r\n    public set dash(value: Array<number>) {\r\n        if (this._dash === value) {\r\n            return;\r\n        }\r\n\r\n        this._dash = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets point stored at specified index\r\n     * @param index defines the index to look for\r\n     * @returns the requested point if found\r\n     */\r\n    public getAt(index: number): MultiLinePoint {\r\n        if (!this._points[index]) {\r\n            this._points[index] = new MultiLinePoint(this);\r\n        }\r\n\r\n        return this._points[index] as MultiLinePoint;\r\n    }\r\n\r\n    /** Function called when a point is updated */\r\n    public onPointUpdate = (): void => {\r\n        this._markAsDirty();\r\n    };\r\n\r\n    /**\r\n     * Adds new points to the point collection\r\n     * @param items defines the list of items (mesh, control or 2d coordinates) to add\r\n     * @returns the list of created MultiLinePoint\r\n     */\r\n    public add(...items: (AbstractMesh | Control | { x: string | number; y: string | number })[]): MultiLinePoint[] {\r\n        return items.map((item) => this.push(item));\r\n    }\r\n\r\n    /**\r\n     * Adds a new point to the point collection\r\n     * @param item defines the item (mesh, control or 2d coordinates) to add\r\n     * @returns the created MultiLinePoint\r\n     */\r\n    public push(item?: AbstractMesh | Control | { x: string | number; y: string | number }): MultiLinePoint {\r\n        const point: MultiLinePoint = this.getAt(this._points.length);\r\n\r\n        if (item == null) {\r\n            return point;\r\n        }\r\n\r\n        if (item instanceof AbstractMesh) {\r\n            point.mesh = item;\r\n        } else if (item instanceof Control) {\r\n            point.control = item;\r\n        } else if (item.x != null && item.y != null) {\r\n            point.x = item.x;\r\n            point.y = item.y;\r\n        }\r\n\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific value or point from the active point collection\r\n     * @param value defines the value or point to remove\r\n     */\r\n    public remove(value: number | MultiLinePoint): void {\r\n        let index: number;\r\n\r\n        if (value instanceof MultiLinePoint) {\r\n            index = this._points.indexOf(value);\r\n\r\n            if (index === -1) {\r\n                return;\r\n            }\r\n        } else {\r\n            index = value;\r\n        }\r\n\r\n        const point: Nullable<MultiLinePoint> = this._points[index];\r\n\r\n        if (!point) {\r\n            return;\r\n        }\r\n\r\n        point.dispose();\r\n\r\n        this._points.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Resets this object to initial state (no point)\r\n     */\r\n    public reset(): void {\r\n        while (this._points.length > 0) {\r\n            this.remove(this._points.length - 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets all links\r\n     */\r\n    public resetLinks(): void {\r\n        this._points.forEach((point) => {\r\n            if (point != null) {\r\n                point.resetLinks();\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Gets or sets line width */\r\n    public get lineWidth(): number {\r\n        return this._lineWidth;\r\n    }\r\n\r\n    public set lineWidth(value: number) {\r\n        if (this._lineWidth === value) {\r\n            return;\r\n        }\r\n\r\n        this._lineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    public override set horizontalAlignment(value: number) {\r\n        return;\r\n    }\r\n\r\n    public override set verticalAlignment(value: number) {\r\n        return;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"MultiLine\";\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        this._applyStates(context);\r\n\r\n        context.strokeStyle = this.color;\r\n        context.lineWidth = this._lineWidth;\r\n        context.setLineDash(this._dash);\r\n\r\n        context.beginPath();\r\n\r\n        let first: boolean = true; //first index is not necessarily 0\r\n        let previousPoint: Vector3;\r\n\r\n        this._points.forEach((point) => {\r\n            if (!point) {\r\n                return;\r\n            }\r\n\r\n            if (first) {\r\n                context.moveTo(point._point.x, point._point.y);\r\n\r\n                first = false;\r\n            } else {\r\n                if (point._point.z < 1 && previousPoint.z < 1) {\r\n                    context.lineTo(point._point.x, point._point.y);\r\n                } else {\r\n                    context.moveTo(point._point.x, point._point.y);\r\n                }\r\n            }\r\n            previousPoint = point._point;\r\n        });\r\n\r\n        context.stroke();\r\n\r\n        context.restore();\r\n    }\r\n\r\n    protected override _additionalProcessing(): void {\r\n        this._minX = null;\r\n        this._minY = null;\r\n        this._maxX = null;\r\n        this._maxY = null;\r\n\r\n        this._points.forEach((point) => {\r\n            if (!point) {\r\n                return;\r\n            }\r\n\r\n            point.translate();\r\n\r\n            if (this._minX == null || point._point.x < this._minX) {\r\n                this._minX = point._point.x;\r\n            }\r\n            if (this._minY == null || point._point.y < this._minY) {\r\n                this._minY = point._point.y;\r\n            }\r\n            if (this._maxX == null || point._point.x > this._maxX) {\r\n                this._maxX = point._point.x;\r\n            }\r\n            if (this._maxY == null || point._point.y > this._maxY) {\r\n                this._maxY = point._point.y;\r\n            }\r\n        });\r\n\r\n        if (this._minX == null) {\r\n            this._minX = 0;\r\n        }\r\n        if (this._minY == null) {\r\n            this._minY = 0;\r\n        }\r\n        if (this._maxX == null) {\r\n            this._maxX = 0;\r\n        }\r\n        if (this._maxY == null) {\r\n            this._maxY = 0;\r\n        }\r\n    }\r\n\r\n    public override _measure(): void {\r\n        if (this._minX == null || this._maxX == null || this._minY == null || this._maxY == null) {\r\n            return;\r\n        }\r\n\r\n        this._currentMeasure.width = Math.abs(this._maxX - this._minX) + this._lineWidth;\r\n        this._currentMeasure.height = Math.abs(this._maxY - this._minY) + this._lineWidth;\r\n    }\r\n\r\n    protected override _computeAlignment(): void {\r\n        if (this._minX == null || this._minY == null) {\r\n            return;\r\n        }\r\n\r\n        this._currentMeasure.left = this._minX - this._lineWidth / 2;\r\n        this._currentMeasure.top = this._minY - this._lineWidth / 2;\r\n    }\r\n\r\n    public override dispose(): void {\r\n        this.reset();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.MultiLine\", MultiLine);\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"./control\";\r\nimport { StackPanel } from \"./stackPanel\";\r\nimport { TextBlock } from \"./textBlock\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to create radio button controls\r\n */\r\nexport class RadioButton extends Control {\r\n    private _isChecked = false;\r\n    private _background = \"black\";\r\n    private _checkSizeRatio = 0.8;\r\n    private _thickness = 1;\r\n\r\n    /** Gets or sets border thickness */\r\n    @serialize()\r\n    public get thickness(): number {\r\n        return this._thickness;\r\n    }\r\n\r\n    public set thickness(value: number) {\r\n        if (this._thickness === value) {\r\n            return;\r\n        }\r\n\r\n        this._thickness = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets group name */\r\n    @serialize()\r\n    public group = \"\";\r\n\r\n    /** Observable raised when isChecked is changed */\r\n    public onIsCheckedChangedObservable = new Observable<boolean>();\r\n\r\n    /** Gets or sets a value indicating the ratio between overall size and check size */\r\n    @serialize()\r\n    public get checkSizeRatio(): number {\r\n        return this._checkSizeRatio;\r\n    }\r\n\r\n    public set checkSizeRatio(value: number) {\r\n        value = Math.max(Math.min(1, value), 0);\r\n\r\n        if (this._checkSizeRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._checkSizeRatio = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the checkbox is checked or not */\r\n    @serialize()\r\n    public get isChecked(): boolean {\r\n        return this._isChecked;\r\n    }\r\n\r\n    public set isChecked(value: boolean) {\r\n        if (this._isChecked === value) {\r\n            return;\r\n        }\r\n\r\n        this._isChecked = value;\r\n        this._markAsDirty();\r\n\r\n        this.onIsCheckedChangedObservable.notifyObservers(value);\r\n\r\n        if (this._isChecked && this._host) {\r\n            // Update all controls from same group\r\n            this._host.executeOnAllControls((control) => {\r\n                if (control === this) {\r\n                    return;\r\n                }\r\n\r\n                if ((<any>control).group === undefined) {\r\n                    return;\r\n                }\r\n                const childRadio = <RadioButton>control;\r\n                if (childRadio.group === this.group) {\r\n                    childRadio.isChecked = false;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new RadioButton\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n\r\n        this.isPointerBlocker = true;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"RadioButton\";\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        const actualWidth = this._currentMeasure.width - this._thickness;\r\n        const actualHeight = this._currentMeasure.height - this._thickness;\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        // Outer\r\n        Control.drawEllipse(\r\n            this._currentMeasure.left + this._currentMeasure.width / 2,\r\n            this._currentMeasure.top + this._currentMeasure.height / 2,\r\n            this._currentMeasure.width / 2 - this._thickness / 2,\r\n            this._currentMeasure.height / 2 - this._thickness / 2,\r\n            1,\r\n            context\r\n        );\r\n\r\n        context.fillStyle = this._isEnabled ? this._background : this._disabledColor;\r\n        context.fill();\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        context.strokeStyle = this.color;\r\n        context.lineWidth = this._thickness;\r\n\r\n        context.stroke();\r\n\r\n        // Inner\r\n        if (this._isChecked) {\r\n            context.fillStyle = this._isEnabled ? this.color : this._disabledColor;\r\n            const offsetWidth = actualWidth * this._checkSizeRatio;\r\n            const offseHeight = actualHeight * this._checkSizeRatio;\r\n\r\n            Control.drawEllipse(\r\n                this._currentMeasure.left + this._currentMeasure.width / 2,\r\n                this._currentMeasure.top + this._currentMeasure.height / 2,\r\n                offsetWidth / 2 - this._thickness / 2,\r\n                offseHeight / 2 - this._thickness / 2,\r\n                1,\r\n                context\r\n            );\r\n\r\n            context.fill();\r\n        }\r\n        context.restore();\r\n    }\r\n\r\n    // Events\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isChecked) {\r\n            this.isChecked = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Utility function to easily create a radio button with a header\r\n     * @param title defines the label to use for the header\r\n     * @param group defines the group to use for the radio button\r\n     * @param isChecked defines the initial state of the radio button\r\n     * @param onValueChanged defines the callback to call when value changes\r\n     * @returns a StackPanel containing the radio button and a textBlock\r\n     */\r\n    public static AddRadioButtonWithHeader(title: string, group: string, isChecked: boolean, onValueChanged: (button: RadioButton, value: boolean) => void): StackPanel {\r\n        const panel = new StackPanel();\r\n        panel.isVertical = false;\r\n        panel.height = \"30px\";\r\n\r\n        const radio = new RadioButton();\r\n        radio.width = \"20px\";\r\n        radio.height = \"20px\";\r\n        radio.isChecked = isChecked;\r\n        radio.color = \"green\";\r\n        radio.group = group;\r\n        radio.onIsCheckedChangedObservable.add((value) => onValueChanged(radio, value));\r\n        panel.addControl(radio);\r\n\r\n        const header = new TextBlock();\r\n        header.text = title;\r\n        header.width = \"180px\";\r\n        header.paddingLeft = \"5px\";\r\n        header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        header.color = \"white\";\r\n        panel.addControl(header);\r\n\r\n        return panel;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.RadioButton\", RadioButton);\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Control } from \"../control\";\r\nimport { ValueAndUnit } from \"../../valueAndUnit\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Class used to create slider controls\r\n */\r\nexport class BaseSlider extends Control {\r\n    protected _thumbWidth = new ValueAndUnit(20, ValueAndUnit.UNITMODE_PIXEL, false);\r\n    private _minimum = 0;\r\n    private _maximum = 100;\r\n    private _value = 50;\r\n    private _isVertical = false;\r\n    protected _barOffset = new ValueAndUnit(5, ValueAndUnit.UNITMODE_PIXEL, false);\r\n    private _isThumbClamped = false;\r\n    protected _displayThumb = true;\r\n    private _step = 0;\r\n\r\n    private _lastPointerDownId = -1;\r\n\r\n    // Shared rendering info\r\n    protected _effectiveBarOffset = 0;\r\n    protected _renderLeft: number;\r\n    protected _renderTop: number;\r\n    protected _renderWidth: number;\r\n    protected _renderHeight: number;\r\n    protected _backgroundBoxLength: number;\r\n    protected _backgroundBoxThickness: number;\r\n    protected _effectiveThumbThickness: number;\r\n\r\n    /** Observable raised when the slider value changes */\r\n    public onValueChangedObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a boolean indicating if the thumb must be rendered */\r\n    @serialize()\r\n    public get displayThumb(): boolean {\r\n        return this._displayThumb;\r\n    }\r\n\r\n    public set displayThumb(value: boolean) {\r\n        if (this._displayThumb === value) {\r\n            return;\r\n        }\r\n\r\n        this._displayThumb = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a step to apply to values (0 by default) */\r\n    @serialize()\r\n    public get step(): number {\r\n        return this._step;\r\n    }\r\n\r\n    public set step(value: number) {\r\n        if (this._step === value) {\r\n            return;\r\n        }\r\n\r\n        this._step = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets main bar offset (ie. the margin applied to the value bar) */\r\n    @serialize()\r\n    public get barOffset(): string | number {\r\n        return this._barOffset.toString(this._host);\r\n    }\r\n\r\n    /** Gets main bar offset in pixels*/\r\n    public get barOffsetInPixels(): number {\r\n        return this._barOffset.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set barOffset(value: string | number) {\r\n        if (this._barOffset.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._barOffset.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets thumb width */\r\n    @serialize()\r\n    public get thumbWidth(): string | number {\r\n        return this._thumbWidth.toString(this._host);\r\n    }\r\n\r\n    /** Gets thumb width in pixels */\r\n    public get thumbWidthInPixels(): number {\r\n        return this._thumbWidth.getValueInPixel(this._host, this._cachedParentMeasure.width);\r\n    }\r\n\r\n    public set thumbWidth(value: string | number) {\r\n        if (this._thumbWidth.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._thumbWidth.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** Gets or sets minimum value */\r\n    @serialize()\r\n    public get minimum(): number {\r\n        return this._minimum;\r\n    }\r\n\r\n    public set minimum(value: number) {\r\n        if (this._minimum === value) {\r\n            return;\r\n        }\r\n\r\n        this._minimum = value;\r\n        this._markAsDirty();\r\n\r\n        this.value = Math.max(Math.min(this.value, this._maximum), this._minimum);\r\n    }\r\n\r\n    /** Gets or sets maximum value */\r\n    @serialize()\r\n    public get maximum(): number {\r\n        return this._maximum;\r\n    }\r\n\r\n    public set maximum(value: number) {\r\n        if (this._maximum === value) {\r\n            return;\r\n        }\r\n\r\n        this._maximum = value;\r\n        this._markAsDirty();\r\n\r\n        this.value = Math.max(Math.min(this.value, this._maximum), this._minimum);\r\n    }\r\n\r\n    /** Gets or sets current value */\r\n    @serialize()\r\n    public get value(): number {\r\n        return this._value;\r\n    }\r\n\r\n    public set value(value: number) {\r\n        value = Math.max(Math.min(value, this._maximum), this._minimum);\r\n\r\n        if (this._value === value) {\r\n            return;\r\n        }\r\n\r\n        this._value = value;\r\n        this._markAsDirty();\r\n        this.onValueChangedObservable.notifyObservers(this._value);\r\n    }\r\n\r\n    /**Gets or sets a boolean indicating if the slider should be vertical or horizontal */\r\n    @serialize()\r\n    public get isVertical(): boolean {\r\n        return this._isVertical;\r\n    }\r\n\r\n    public set isVertical(value: boolean) {\r\n        if (this._isVertical === value) {\r\n            return;\r\n        }\r\n\r\n        this._isVertical = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a value indicating if the thumb can go over main bar extends */\r\n    @serialize()\r\n    public get isThumbClamped(): boolean {\r\n        return this._isThumbClamped;\r\n    }\r\n\r\n    public set isThumbClamped(value: boolean) {\r\n        if (this._isThumbClamped === value) {\r\n            return;\r\n        }\r\n\r\n        this._isThumbClamped = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new BaseSlider\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n\r\n        this.isPointerBlocker = true;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"BaseSlider\";\r\n    }\r\n\r\n    protected _getThumbPosition() {\r\n        if (this.isVertical) {\r\n            return ((this.maximum - this.value) / (this.maximum - this.minimum)) * this._backgroundBoxLength;\r\n        }\r\n\r\n        return ((this.value - this.minimum) / (this.maximum - this.minimum)) * this._backgroundBoxLength;\r\n    }\r\n\r\n    protected _getThumbThickness(type: string): number {\r\n        let thumbThickness = 0;\r\n        switch (type) {\r\n            case \"circle\":\r\n                if (this._thumbWidth.isPixel) {\r\n                    thumbThickness = Math.max(this._thumbWidth.getValue(this._host), this._backgroundBoxThickness);\r\n                } else {\r\n                    thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);\r\n                }\r\n                break;\r\n            case \"rectangle\":\r\n                if (this._thumbWidth.isPixel) {\r\n                    thumbThickness = Math.min(this._thumbWidth.getValue(this._host), this._backgroundBoxThickness);\r\n                } else {\r\n                    thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);\r\n                }\r\n        }\r\n        return thumbThickness;\r\n    }\r\n\r\n    protected _prepareRenderingData(type: string) {\r\n        // Main bar\r\n        this._effectiveBarOffset = 0;\r\n        this._renderLeft = this._currentMeasure.left;\r\n        this._renderTop = this._currentMeasure.top;\r\n        this._renderWidth = this._currentMeasure.width;\r\n        this._renderHeight = this._currentMeasure.height;\r\n\r\n        this._backgroundBoxLength = Math.max(this._currentMeasure.width, this._currentMeasure.height);\r\n        this._backgroundBoxThickness = Math.min(this._currentMeasure.width, this._currentMeasure.height);\r\n        this._effectiveThumbThickness = this._getThumbThickness(type);\r\n\r\n        if (this.displayThumb) {\r\n            this._backgroundBoxLength -= this._effectiveThumbThickness;\r\n        }\r\n        //throw error when height is less than width for vertical slider\r\n        if (this.isVertical && this._currentMeasure.height < this._currentMeasure.width) {\r\n            Logger.Error(\"Height should be greater than width\");\r\n            return;\r\n        }\r\n        if (this._barOffset.isPixel) {\r\n            this._effectiveBarOffset = Math.min(this._barOffset.getValue(this._host), this._backgroundBoxThickness);\r\n        } else {\r\n            this._effectiveBarOffset = this._backgroundBoxThickness * this._barOffset.getValue(this._host);\r\n        }\r\n\r\n        this._backgroundBoxThickness -= this._effectiveBarOffset * 2;\r\n\r\n        if (this.isVertical) {\r\n            this._renderLeft += this._effectiveBarOffset;\r\n            if (!this.isThumbClamped && this.displayThumb) {\r\n                this._renderTop += this._effectiveThumbThickness / 2;\r\n            }\r\n\r\n            this._renderHeight = this._backgroundBoxLength;\r\n            this._renderWidth = this._backgroundBoxThickness;\r\n        } else {\r\n            this._renderTop += this._effectiveBarOffset;\r\n            if (!this.isThumbClamped && this.displayThumb) {\r\n                this._renderLeft += this._effectiveThumbThickness / 2;\r\n            }\r\n            this._renderHeight = this._backgroundBoxThickness;\r\n            this._renderWidth = this._backgroundBoxLength;\r\n        }\r\n    }\r\n\r\n    // Events\r\n    private _pointerIsDown = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _updateValueFromPointer(x: number, y: number): void {\r\n        if (this.rotation != 0) {\r\n            this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);\r\n            x = this._transformedPosition.x;\r\n            y = this._transformedPosition.y;\r\n        }\r\n\r\n        let value: number;\r\n        if (this._isVertical) {\r\n            value = this._minimum + (1 - (y - this._currentMeasure.top) / this._currentMeasure.height) * (this._maximum - this._minimum);\r\n        } else {\r\n            value = this._minimum + ((x - this._currentMeasure.left) / this._currentMeasure.width) * (this._maximum - this._minimum);\r\n        }\r\n        this.value = this._step ? Math.round(value / this._step) * this._step : value;\r\n    }\r\n\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        this._pointerIsDown = true;\r\n\r\n        this._updateValueFromPointer(coordinates.x, coordinates.y);\r\n        this._host._capturingControl[pointerId] = this;\r\n        this._lastPointerDownId = pointerId;\r\n        return true;\r\n    }\r\n\r\n    public override _onPointerMove(target: Control, coordinates: Vector2, pointerId: number, pi: PointerInfoBase): void {\r\n        // Only listen to pointer move events coming from the last pointer to click on the element (To support dual vr controller interaction)\r\n        if (pointerId != this._lastPointerDownId) {\r\n            return;\r\n        }\r\n\r\n        if (this._pointerIsDown && !this.isReadOnly) {\r\n            this._updateValueFromPointer(coordinates.x, coordinates.y);\r\n        }\r\n\r\n        super._onPointerMove(target, coordinates, pointerId, pi);\r\n    }\r\n\r\n    public override _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean): void {\r\n        this._pointerIsDown = false;\r\n\r\n        delete this._host._capturingControl[pointerId];\r\n        super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick);\r\n    }\r\n\r\n    public override _onCanvasBlur(): void {\r\n        this._forcePointerUp();\r\n        super._onCanvasBlur();\r\n    }\r\n}\r\n", "import { BaseSlider } from \"./baseSlider\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { BaseGradient } from \"../gradient/BaseGradient\";\r\nimport type { AdvancedDynamicTexture } from \"gui/2D/advancedDynamicTexture\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Class used to create slider controls\r\n */\r\nexport class Slider extends BaseSlider {\r\n    private _background = \"black\";\r\n    private _borderColor = \"white\";\r\n    private _thumbColor = \"\";\r\n    private _isThumbCircle = false;\r\n    protected _displayValueBar = true;\r\n    private _backgroundGradient: Nullable<BaseGradient> = null;\r\n\r\n    /** Gets or sets a boolean indicating if the value bar must be rendered */\r\n    @serialize()\r\n    public get displayValueBar(): boolean {\r\n        return this._displayValueBar;\r\n    }\r\n\r\n    public set displayValueBar(value: boolean) {\r\n        if (this._displayValueBar === value) {\r\n            return;\r\n        }\r\n\r\n        this._displayValueBar = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets border color */\r\n    @serialize()\r\n    public get borderColor(): string {\r\n        return this._borderColor;\r\n    }\r\n\r\n    public set borderColor(value: string) {\r\n        if (this._borderColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._borderColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background gradient */\r\n    public get backgroundGradient(): Nullable<BaseGradient> {\r\n        return this._backgroundGradient;\r\n    }\r\n\r\n    public set backgroundGradient(value: Nullable<BaseGradient>) {\r\n        if (this._backgroundGradient === value) {\r\n            return;\r\n        }\r\n\r\n        this._backgroundGradient = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets thumb's color */\r\n    @serialize()\r\n    public get thumbColor(): string {\r\n        return this._thumbColor;\r\n    }\r\n\r\n    public set thumbColor(value: string) {\r\n        if (this._thumbColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._thumbColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the thumb should be round or square */\r\n    @serialize()\r\n    public get isThumbCircle(): boolean {\r\n        return this._isThumbCircle;\r\n    }\r\n\r\n    public set isThumbCircle(value: boolean) {\r\n        if (this._isThumbCircle === value) {\r\n            return;\r\n        }\r\n\r\n        this._isThumbCircle = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new Slider\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Slider\";\r\n    }\r\n\r\n    protected _getBackgroundColor(context: ICanvasRenderingContext) {\r\n        return this._backgroundGradient ? this._backgroundGradient.getCanvasGradient(context) : this._background;\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        this._prepareRenderingData(this.isThumbCircle ? \"circle\" : \"rectangle\");\r\n        let left = this._renderLeft;\r\n        let top = this._renderTop;\r\n        const width = this._renderWidth;\r\n        const height = this._renderHeight;\r\n\r\n        let radius = 0;\r\n\r\n        if (this.isThumbClamped && this.isThumbCircle) {\r\n            if (this.isVertical) {\r\n                top += this._effectiveThumbThickness / 2;\r\n            } else {\r\n                left += this._effectiveThumbThickness / 2;\r\n            }\r\n\r\n            radius = this._backgroundBoxThickness / 2;\r\n        } else {\r\n            radius = (this._effectiveThumbThickness - this._effectiveBarOffset) / 2;\r\n        }\r\n        radius = Math.max(0, radius);\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n        }\r\n\r\n        const thumbPosition = this._getThumbPosition();\r\n        context.fillStyle = this._getBackgroundColor(context);\r\n\r\n        if (this.isVertical) {\r\n            if (this.isThumbClamped) {\r\n                if (this.isThumbCircle) {\r\n                    context.beginPath();\r\n                    context.arc(left + this._backgroundBoxThickness / 2, top, radius, Math.PI, 2 * Math.PI);\r\n                    context.fill();\r\n                    context.fillRect(left, top, width, height);\r\n                } else {\r\n                    context.fillRect(left, top, width, height + this._effectiveThumbThickness);\r\n                }\r\n            } else {\r\n                context.fillRect(left, top, width, height);\r\n            }\r\n        } else {\r\n            if (this.isThumbClamped) {\r\n                if (this.isThumbCircle) {\r\n                    context.beginPath();\r\n                    context.arc(left + this._backgroundBoxLength, top + this._backgroundBoxThickness / 2, radius, 0, 2 * Math.PI);\r\n                    context.fill();\r\n                    context.fillRect(left, top, width, height);\r\n                } else {\r\n                    context.fillRect(left, top, width + this._effectiveThumbThickness, height);\r\n                }\r\n            } else {\r\n                context.fillRect(left, top, width, height);\r\n            }\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowBlur = 0;\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n        }\r\n\r\n        // Value bar\r\n        context.fillStyle = this._getColor(context);\r\n        if (this._displayValueBar) {\r\n            if (this.isVertical) {\r\n                if (this.isThumbClamped) {\r\n                    if (this.isThumbCircle) {\r\n                        context.beginPath();\r\n                        context.arc(left + this._backgroundBoxThickness / 2, top + this._backgroundBoxLength, radius, 0, 2 * Math.PI);\r\n                        context.fill();\r\n                        context.fillRect(left, top + thumbPosition, width, height - thumbPosition);\r\n                    } else {\r\n                        context.fillRect(left, top + thumbPosition, width, height - thumbPosition + this._effectiveThumbThickness);\r\n                    }\r\n                } else {\r\n                    context.fillRect(left, top + thumbPosition, width, height - thumbPosition);\r\n                }\r\n            } else {\r\n                if (this.isThumbClamped) {\r\n                    if (this.isThumbCircle) {\r\n                        context.beginPath();\r\n                        context.arc(left, top + this._backgroundBoxThickness / 2, radius, 0, 2 * Math.PI);\r\n                        context.fill();\r\n                        context.fillRect(left, top, thumbPosition, height);\r\n                    } else {\r\n                        context.fillRect(left, top, thumbPosition, height);\r\n                    }\r\n                } else {\r\n                    context.fillRect(left, top, thumbPosition, height);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Thumb\r\n        context.fillStyle = this._thumbColor || this._getColor(context);\r\n        if (this.displayThumb) {\r\n            if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n                context.shadowColor = this.shadowColor;\r\n                context.shadowBlur = this.shadowBlur;\r\n                context.shadowOffsetX = this.shadowOffsetX;\r\n                context.shadowOffsetY = this.shadowOffsetY;\r\n            }\r\n            if (this._isThumbCircle) {\r\n                context.beginPath();\r\n                if (this.isVertical) {\r\n                    context.arc(left + this._backgroundBoxThickness / 2, top + thumbPosition, radius, 0, 2 * Math.PI);\r\n                } else {\r\n                    context.arc(left + thumbPosition, top + this._backgroundBoxThickness / 2, radius, 0, 2 * Math.PI);\r\n                }\r\n                context.fill();\r\n                if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n                    context.shadowBlur = 0;\r\n                    context.shadowOffsetX = 0;\r\n                    context.shadowOffsetY = 0;\r\n                }\r\n                context.strokeStyle = this._borderColor;\r\n                context.stroke();\r\n            } else {\r\n                if (this.isVertical) {\r\n                    context.fillRect(left - this._effectiveBarOffset, this._currentMeasure.top + thumbPosition, this._currentMeasure.width, this._effectiveThumbThickness);\r\n                } else {\r\n                    context.fillRect(this._currentMeasure.left + thumbPosition, this._currentMeasure.top, this._effectiveThumbThickness, this._currentMeasure.height);\r\n                }\r\n                if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n                    context.shadowBlur = 0;\r\n                    context.shadowOffsetX = 0;\r\n                    context.shadowOffsetY = 0;\r\n                }\r\n                context.strokeStyle = this._borderColor;\r\n                if (this.isVertical) {\r\n                    context.strokeRect(left - this._effectiveBarOffset, this._currentMeasure.top + thumbPosition, this._currentMeasure.width, this._effectiveThumbThickness);\r\n                } else {\r\n                    context.strokeRect(this._currentMeasure.left + thumbPosition, this._currentMeasure.top, this._effectiveThumbThickness, this._currentMeasure.height);\r\n                }\r\n            }\r\n        }\r\n        context.restore();\r\n    }\r\n\r\n    public override serialize(serializationObject: any) {\r\n        super.serialize(serializationObject);\r\n\r\n        if (this.backgroundGradient) {\r\n            serializationObject.backgroundGradient = {};\r\n            this.backgroundGradient.serialize(serializationObject.backgroundGradient);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture) {\r\n        super._parseFromContent(serializedObject, host);\r\n\r\n        if (serializedObject.backgroundGradient) {\r\n            const className = Tools.Instantiate(\"BABYLON.GUI.\" + serializedObject.backgroundGradient.className);\r\n            this.backgroundGradient = new className();\r\n            this.backgroundGradient!.parse(serializedObject.backgroundGradient);\r\n        }\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Slider\", Slider);\r\n", "import { Rectangle } from \"./rectangle\";\r\nimport { StackPanel } from \"./stackPanel\";\r\nimport { Control } from \"./control\";\r\nimport { TextBlock } from \"./textBlock\";\r\nimport { Checkbox } from \"./checkbox\";\r\nimport { RadioButton } from \"./radioButton\";\r\nimport { Slider } from \"./sliders/slider\";\r\nimport { Container } from \"./container\";\r\n\r\n/** Class used to create a RadioGroup\r\n * which contains groups of radio buttons\r\n */\r\nexport class SelectorGroup {\r\n    private _groupPanel = new StackPanel();\r\n    private _selectors: StackPanel[] = new Array();\r\n    private _groupHeader: TextBlock;\r\n\r\n    /**\r\n     * Creates a new SelectorGroup\r\n     * @param name of group, used as a group heading\r\n     */\r\n    constructor(\r\n        /** name of SelectorGroup */\r\n        public name: string\r\n    ) {\r\n        this._groupPanel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this._groupPanel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this._groupHeader = this._addGroupHeader(name);\r\n    }\r\n\r\n    /** Gets the groupPanel of the SelectorGroup  */\r\n    public get groupPanel(): StackPanel {\r\n        return this._groupPanel;\r\n    }\r\n\r\n    /** Gets the selectors array */\r\n    public get selectors(): StackPanel[] {\r\n        return this._selectors;\r\n    }\r\n\r\n    /** Gets and sets the group header */\r\n    public get header() {\r\n        return this._groupHeader.text;\r\n    }\r\n\r\n    public set header(label: string) {\r\n        if (this._groupHeader.text === \"label\") {\r\n            return;\r\n        }\r\n\r\n        this._groupHeader.text = label;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _addGroupHeader(text: string): TextBlock {\r\n        const groupHeading = new TextBlock(\"groupHead\", text);\r\n        groupHeading.width = 0.9;\r\n        groupHeading.height = \"30px\";\r\n        groupHeading.textWrapping = true;\r\n        groupHeading.color = \"black\";\r\n        groupHeading.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        groupHeading.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        groupHeading.left = \"2px\";\r\n        this._groupPanel.addControl(groupHeading);\r\n        return groupHeading;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getSelector(selectorNb: number) {\r\n        if (selectorNb < 0 || selectorNb >= this._selectors.length) {\r\n            return;\r\n        }\r\n        return this._selectors[selectorNb];\r\n    }\r\n\r\n    /** Removes the selector at the given position\r\n     * @param selectorNb the position of the selector within the group\r\n     */\r\n    public removeSelector(selectorNb: number) {\r\n        if (selectorNb < 0 || selectorNb >= this._selectors.length) {\r\n            return;\r\n        }\r\n        this._groupPanel.removeControl(this._selectors[selectorNb]);\r\n        this._selectors.splice(selectorNb, 1);\r\n    }\r\n}\r\n\r\n/** Class used to create a CheckboxGroup\r\n * which contains groups of checkbox buttons\r\n */\r\nexport class CheckboxGroup extends SelectorGroup {\r\n    /** Adds a checkbox as a control\r\n     * @param text is the label for the selector\r\n     * @param func is the function called when the Selector is checked\r\n     * @param checked is true when Selector is checked\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addCheckbox(text: string, func = (s: boolean) => {}, checked: boolean = false): void {\r\n        checked = checked || false;\r\n        const button = new Checkbox();\r\n        button.width = \"20px\";\r\n        button.height = \"20px\";\r\n        button.color = \"#364249\";\r\n        button.background = \"#CCCCCC\";\r\n        button.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n\r\n        button.onIsCheckedChangedObservable.add(function (state) {\r\n            func(state);\r\n        });\r\n\r\n        const _selector = Control.AddHeader(button, text, \"200px\", { isHorizontal: true, controlFirst: true });\r\n        _selector.height = \"30px\";\r\n        _selector.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        _selector.left = \"4px\";\r\n\r\n        this.groupPanel.addControl(_selector);\r\n        this.selectors.push(_selector);\r\n        button.isChecked = checked;\r\n\r\n        if (this.groupPanel.parent && this.groupPanel.parent.parent) {\r\n            button.color = (<SelectionPanel>this.groupPanel.parent.parent).buttonColor;\r\n            button.background = (<SelectionPanel>this.groupPanel.parent.parent).buttonBackground;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorLabel(selectorNb: number, label: string) {\r\n        (<TextBlock>this.selectors[selectorNb].children[1]).text = label;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorLabelColor(selectorNb: number, color: string) {\r\n        (<TextBlock>this.selectors[selectorNb].children[1]).color = color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorButtonColor(selectorNb: number, color: string) {\r\n        this.selectors[selectorNb].children[0].color = color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorButtonBackground(selectorNb: number, color: string) {\r\n        (<Checkbox>this.selectors[selectorNb].children[0]).background = color;\r\n    }\r\n}\r\n\r\n/** Class used to create a RadioGroup\r\n * which contains groups of radio buttons\r\n */\r\nexport class RadioGroup extends SelectorGroup {\r\n    private _selectNb = 0;\r\n\r\n    /** Adds a radio button as a control\r\n     * @param label is the label for the selector\r\n     * @param func is the function called when the Selector is checked\r\n     * @param checked is true when Selector is checked\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addRadio(label: string, func = (n: number) => {}, checked = false): void {\r\n        const nb = this._selectNb++;\r\n        const button = new RadioButton();\r\n        button.name = label;\r\n        button.width = \"20px\";\r\n        button.height = \"20px\";\r\n        button.color = \"#364249\";\r\n        button.background = \"#CCCCCC\";\r\n        button.group = this.name;\r\n        button.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n\r\n        button.onIsCheckedChangedObservable.add(function (state) {\r\n            if (state) {\r\n                func(nb);\r\n            }\r\n        });\r\n\r\n        const _selector = Control.AddHeader(button, label, \"200px\", { isHorizontal: true, controlFirst: true });\r\n        _selector.height = \"30px\";\r\n        _selector.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        _selector.left = \"4px\";\r\n        this.groupPanel.addControl(_selector);\r\n        this.selectors.push(_selector);\r\n        button.isChecked = checked;\r\n\r\n        if (this.groupPanel.parent && this.groupPanel.parent.parent) {\r\n            button.color = (<SelectionPanel>this.groupPanel.parent.parent).buttonColor;\r\n            button.background = (<SelectionPanel>this.groupPanel.parent.parent).buttonBackground;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorLabel(selectorNb: number, label: string) {\r\n        (<TextBlock>this.selectors[selectorNb].children[1]).text = label;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorLabelColor(selectorNb: number, color: string) {\r\n        (<TextBlock>this.selectors[selectorNb].children[1]).color = color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorButtonColor(selectorNb: number, color: string) {\r\n        this.selectors[selectorNb].children[0].color = color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorButtonBackground(selectorNb: number, color: string) {\r\n        (<RadioButton>this.selectors[selectorNb].children[0]).background = color;\r\n    }\r\n}\r\n\r\n/** Class used to create a SliderGroup\r\n * which contains groups of slider buttons\r\n */\r\nexport class SliderGroup extends SelectorGroup {\r\n    /**\r\n     * Adds a slider to the SelectorGroup\r\n     * @param label is the label for the SliderBar\r\n     * @param func is the function called when the Slider moves\r\n     * @param unit is a string describing the units used, eg degrees or metres\r\n     * @param min is the minimum value for the Slider\r\n     * @param max is the maximum value for the Slider\r\n     * @param value is the start value for the Slider between min and max\r\n     * @param onValueChange is the function used to format the value displayed, eg radians to degrees\r\n     */\r\n    public addSlider(\r\n        label: string,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        func = (v: number) => {},\r\n        unit: string = \"Units\",\r\n        min: number = 0,\r\n        max: number = 0,\r\n        value: number = 0,\r\n        onValueChange = (v: number) => {\r\n            return v | 0;\r\n        }\r\n    ): void {\r\n        const button = new Slider();\r\n        button.name = unit;\r\n        button.value = value;\r\n        button.minimum = min;\r\n        button.maximum = max;\r\n        button.width = 0.9;\r\n        button.height = \"20px\";\r\n        button.color = \"#364249\";\r\n        button.background = \"#CCCCCC\";\r\n        button.borderColor = \"black\";\r\n        button.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        button.left = \"4px\";\r\n        button.paddingBottom = \"4px\";\r\n\r\n        button.onValueChangedObservable.add(function (value) {\r\n            (<TextBlock>button.parent!.children[0]).text = button.parent!.children[0].name + \": \" + onValueChange(value) + \" \" + button.name;\r\n            func(value);\r\n        });\r\n\r\n        const _selector = Control.AddHeader(button, label + \": \" + onValueChange(value) + \" \" + unit, \"30px\", { isHorizontal: false, controlFirst: false });\r\n        _selector.height = \"60px\";\r\n        _selector.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        _selector.left = \"4px\";\r\n        _selector.children[0].name = label;\r\n        this.groupPanel.addControl(_selector);\r\n        this.selectors.push(_selector);\r\n\r\n        if (this.groupPanel.parent && this.groupPanel.parent.parent) {\r\n            button.color = (<SelectionPanel>this.groupPanel.parent.parent).buttonColor;\r\n            button.background = (<SelectionPanel>this.groupPanel.parent.parent).buttonBackground;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorLabel(selectorNb: number, label: string) {\r\n        this.selectors[selectorNb].children[0].name = label;\r\n        (<TextBlock>this.selectors[selectorNb].children[0]).text =\r\n            label + \": \" + (<Slider>this.selectors[selectorNb].children[1]).value + \" \" + this.selectors[selectorNb].children[1].name;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorLabelColor(selectorNb: number, color: string) {\r\n        (<TextBlock>this.selectors[selectorNb].children[0]).color = color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorButtonColor(selectorNb: number, color: string) {\r\n        this.selectors[selectorNb].children[1].color = color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setSelectorButtonBackground(selectorNb: number, color: string) {\r\n        (<Slider>this.selectors[selectorNb].children[1]).background = color;\r\n    }\r\n}\r\n\r\n/** Class used to hold the controls for the checkboxes, radio buttons and sliders\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/selector\r\n */\r\nexport class SelectionPanel extends Rectangle {\r\n    private _panel: StackPanel;\r\n    private _buttonColor: string = \"#364249\";\r\n    private _buttonBackground: string = \"#CCCCCC\";\r\n    private _headerColor: string = \"black\";\r\n    private _barColor: string = \"white\";\r\n    private _barHeight: string = \"2px\";\r\n    private _spacerHeight: string = \"20px\";\r\n    private _labelColor: string;\r\n    private _groups: SelectorGroup[];\r\n    private _bars: any[] = new Array();\r\n\r\n    /**\r\n     * Creates a new SelectionPanel\r\n     * @param name of SelectionPanel\r\n     * @param groups is an array of SelectionGroups\r\n     */\r\n    constructor(\r\n        /** name of SelectionPanel */\r\n        public override name: string,\r\n        /** an array of SelectionGroups */\r\n        public groups: SelectorGroup[] = []\r\n    ) {\r\n        super(name);\r\n        this._groups = groups;\r\n        this.thickness = 2;\r\n        this._panel = new StackPanel();\r\n        this._panel.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this._panel.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this._panel.top = 5;\r\n        this._panel.left = 5;\r\n        this._panel.width = 0.95;\r\n        if (groups.length > 0) {\r\n            for (let i = 0; i < groups.length - 1; i++) {\r\n                this._panel.addControl(groups[i].groupPanel);\r\n                this._addSpacer();\r\n            }\r\n            this._panel.addControl(groups[groups.length - 1].groupPanel);\r\n        }\r\n        this.addControl(this._panel);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"SelectionPanel\";\r\n    }\r\n\r\n    /** Gets the (stack) panel of the SelectionPanel  */\r\n    public get panel(): StackPanel {\r\n        return this._panel;\r\n    }\r\n\r\n    /** Gets or sets the headerColor */\r\n    public get headerColor(): string {\r\n        return this._headerColor;\r\n    }\r\n\r\n    public set headerColor(color: string) {\r\n        if (this._headerColor === color) {\r\n            return;\r\n        }\r\n        this._headerColor = color;\r\n        this._setHeaderColor();\r\n    }\r\n\r\n    private _setHeaderColor() {\r\n        for (let i = 0; i < this._groups.length; i++) {\r\n            this._groups[i].groupPanel.children[0].color = this._headerColor;\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the button color */\r\n    public get buttonColor(): string {\r\n        return this._buttonColor;\r\n    }\r\n\r\n    public set buttonColor(color: string) {\r\n        if (this._buttonColor === color) {\r\n            return;\r\n        }\r\n\r\n        this._buttonColor = color;\r\n        this._setbuttonColor();\r\n    }\r\n\r\n    private _setbuttonColor() {\r\n        for (let i = 0; i < this._groups.length; i++) {\r\n            for (let j = 0; j < this._groups[i].selectors.length; j++) {\r\n                (<CheckboxGroup | RadioGroup | SliderGroup>this._groups[i])._setSelectorButtonColor(j, this._buttonColor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the label color */\r\n    public get labelColor(): string {\r\n        return this._labelColor;\r\n    }\r\n\r\n    public set labelColor(color: string) {\r\n        if (this._labelColor === color) {\r\n            return;\r\n        }\r\n        this._labelColor = color;\r\n        this._setLabelColor();\r\n    }\r\n\r\n    private _setLabelColor() {\r\n        for (let i = 0; i < this._groups.length; i++) {\r\n            for (let j = 0; j < this._groups[i].selectors.length; j++) {\r\n                (<CheckboxGroup | RadioGroup | SliderGroup>this._groups[i])._setSelectorLabelColor(j, this._labelColor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the button background */\r\n    public get buttonBackground(): string {\r\n        return this._buttonBackground;\r\n    }\r\n\r\n    public set buttonBackground(color: string) {\r\n        if (this._buttonBackground === color) {\r\n            return;\r\n        }\r\n\r\n        this._buttonBackground = color;\r\n        this._setButtonBackground();\r\n    }\r\n\r\n    private _setButtonBackground() {\r\n        for (let i = 0; i < this._groups.length; i++) {\r\n            for (let j = 0; j < this._groups[i].selectors.length; j++) {\r\n                (<CheckboxGroup | RadioGroup | SliderGroup>this._groups[i])._setSelectorButtonBackground(j, this._buttonBackground);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the color of separator bar */\r\n    public get barColor(): string {\r\n        return this._barColor;\r\n    }\r\n\r\n    public set barColor(color: string) {\r\n        if (this._barColor === color) {\r\n            return;\r\n        }\r\n\r\n        this._barColor = color;\r\n        this._setBarColor();\r\n    }\r\n\r\n    private _setBarColor() {\r\n        for (let i = 0; i < this._bars.length; i++) {\r\n            this._bars[i].children[0].background = this._barColor;\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the height of separator bar */\r\n    public get barHeight(): string {\r\n        return this._barHeight;\r\n    }\r\n\r\n    public set barHeight(value: string) {\r\n        if (this._barHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._barHeight = value;\r\n        this._setBarHeight();\r\n    }\r\n\r\n    private _setBarHeight() {\r\n        for (let i = 0; i < this._bars.length; i++) {\r\n            this._bars[i].children[0].height = this._barHeight;\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the height of spacers*/\r\n    public get spacerHeight(): string {\r\n        return this._spacerHeight;\r\n    }\r\n\r\n    public set spacerHeight(value: string) {\r\n        if (this._spacerHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._spacerHeight = value;\r\n        this._setSpacerHeight();\r\n    }\r\n\r\n    private _setSpacerHeight() {\r\n        for (let i = 0; i < this._bars.length; i++) {\r\n            this._bars[i].height = this._spacerHeight;\r\n        }\r\n    }\r\n\r\n    /** Adds a bar between groups */\r\n    private _addSpacer(): void {\r\n        const separator = new Container();\r\n        separator.width = 1;\r\n        separator.height = this._spacerHeight;\r\n        separator.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n\r\n        const bar = new Rectangle();\r\n        bar.width = 1;\r\n        bar.height = this._barHeight;\r\n        bar.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        bar.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n        bar.background = this._barColor;\r\n        bar.color = \"transparent\";\r\n        separator.addControl(bar);\r\n\r\n        this._panel.addControl(separator);\r\n        this._bars.push(separator);\r\n    }\r\n\r\n    /** Add a group to the selection panel\r\n     * @param group is the selector group to add\r\n     */\r\n    public addGroup(group: SelectorGroup): void {\r\n        if (this._groups.length > 0) {\r\n            this._addSpacer();\r\n        }\r\n        this._panel.addControl(group.groupPanel);\r\n        this._groups.push(group);\r\n        group.groupPanel.children[0].color = this._headerColor;\r\n        for (let j = 0; j < group.selectors.length; j++) {\r\n            (<CheckboxGroup | RadioGroup | SliderGroup>group)._setSelectorButtonColor(j, this._buttonColor);\r\n            (<CheckboxGroup | RadioGroup | SliderGroup>group)._setSelectorButtonBackground(j, this._buttonBackground);\r\n        }\r\n    }\r\n\r\n    /** Remove the group from the given position\r\n     * @param groupNb is the position of the group in the list\r\n     */\r\n    public removeGroup(groupNb: number): void {\r\n        if (groupNb < 0 || groupNb >= this._groups.length) {\r\n            return;\r\n        }\r\n        const group = this._groups[groupNb];\r\n        this._panel.removeControl(group.groupPanel);\r\n        this._groups.splice(groupNb, 1);\r\n        if (groupNb < this._bars.length) {\r\n            this._panel.removeControl(this._bars[groupNb]);\r\n            this._bars.splice(groupNb, 1);\r\n        }\r\n    }\r\n\r\n    /** Change a group header label\r\n     * @param label is the new group header label\r\n     * @param groupNb is the number of the group to relabel\r\n     * */\r\n    public setHeaderName(label: string, groupNb: number) {\r\n        if (groupNb < 0 || groupNb >= this._groups.length) {\r\n            return;\r\n        }\r\n        const group = this._groups[groupNb];\r\n        (<TextBlock>group.groupPanel.children[0]).text = label;\r\n    }\r\n\r\n    /** Change selector label to the one given\r\n     * @param label is the new selector label\r\n     * @param groupNb is the number of the groupcontaining the selector\r\n     * @param selectorNb is the number of the selector within a group to relabel\r\n     * */\r\n    public relabel(label: string, groupNb: number, selectorNb: number): void {\r\n        if (groupNb < 0 || groupNb >= this._groups.length) {\r\n            return;\r\n        }\r\n        const group = this._groups[groupNb];\r\n        if (selectorNb < 0 || selectorNb >= group.selectors.length) {\r\n            return;\r\n        }\r\n        (<CheckboxGroup | RadioGroup | SliderGroup>group)._setSelectorLabel(selectorNb, label);\r\n    }\r\n\r\n    /** For a given group position remove the selector at the given position\r\n     * @param groupNb is the number of the group to remove the selector from\r\n     * @param selectorNb is the number of the selector within the group\r\n     */\r\n    public removeFromGroupSelector(groupNb: number, selectorNb: number): void {\r\n        if (groupNb < 0 || groupNb >= this._groups.length) {\r\n            return;\r\n        }\r\n        const group = this._groups[groupNb];\r\n        if (selectorNb < 0 || selectorNb >= group.selectors.length) {\r\n            return;\r\n        }\r\n        group.removeSelector(selectorNb);\r\n    }\r\n\r\n    /** For a given group position of correct type add a checkbox button\r\n     * @param groupNb is the number of the group to remove the selector from\r\n     * @param label is the label for the selector\r\n     * @param func is the function called when the Selector is checked\r\n     * @param checked is true when Selector is checked\r\n     */\r\n    public addToGroupCheckbox(groupNb: number, label: string, func = () => {}, checked: boolean = false): void {\r\n        if (groupNb < 0 || groupNb >= this._groups.length) {\r\n            return;\r\n        }\r\n        const group = this._groups[groupNb];\r\n        (<CheckboxGroup>group).addCheckbox(label, func, checked);\r\n    }\r\n\r\n    /** For a given group position of correct type add a radio button\r\n     * @param groupNb is the number of the group to remove the selector from\r\n     * @param label is the label for the selector\r\n     * @param func is the function called when the Selector is checked\r\n     * @param checked is true when Selector is checked\r\n     */\r\n    public addToGroupRadio(groupNb: number, label: string, func = () => {}, checked: boolean = false): void {\r\n        if (groupNb < 0 || groupNb >= this._groups.length) {\r\n            return;\r\n        }\r\n        const group = this._groups[groupNb];\r\n        (<RadioGroup>group).addRadio(label, func, checked);\r\n    }\r\n\r\n    /**\r\n     * For a given slider group add a slider\r\n     * @param groupNb is the number of the group to add the slider to\r\n     * @param label is the label for the Slider\r\n     * @param func is the function called when the Slider moves\r\n     * @param unit is a string describing the units used, eg degrees or metres\r\n     * @param min is the minimum value for the Slider\r\n     * @param max is the maximum value for the Slider\r\n     * @param value is the start value for the Slider between min and max\r\n     * @param onVal is the function used to format the value displayed, eg radians to degrees\r\n     */\r\n    public addToGroupSlider(\r\n        groupNb: number,\r\n        label: string,\r\n        func = () => {},\r\n        unit: string = \"Units\",\r\n        min: number = 0,\r\n        max: number = 0,\r\n        value: number = 0,\r\n        onVal = (v: number) => {\r\n            return v | 0;\r\n        }\r\n    ): void {\r\n        if (groupNb < 0 || groupNb >= this._groups.length) {\r\n            return;\r\n        }\r\n        const group = this._groups[groupNb];\r\n        (<SliderGroup>group).addSlider(label, func, unit, min, max, value, onVal);\r\n    }\r\n}\r\n", "import { Measure } from \"../../measure\";\r\nimport { Container } from \"../container\";\r\nimport { ValueAndUnit } from \"../../valueAndUnit\";\r\nimport { Control } from \"../control\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to hold a the container for ScrollViewer\r\n * @internal\r\n */\r\nexport class _ScrollViewerWindow extends Container {\r\n    public parentClientWidth: number;\r\n    public parentClientHeight: number;\r\n\r\n    private _freezeControls = false;\r\n    private _parentMeasure: Measure;\r\n    private _oldLeft: number | null;\r\n    private _oldTop: number | null;\r\n\r\n    public get freezeControls(): boolean {\r\n        return this._freezeControls;\r\n    }\r\n\r\n    public set freezeControls(value: boolean) {\r\n        if (this._freezeControls === value) {\r\n            return;\r\n        }\r\n\r\n        if (!value) {\r\n            this._restoreMeasures();\r\n        }\r\n\r\n        // trigger a full normal layout calculation to be sure all children have their measures up to date\r\n        this._freezeControls = false;\r\n\r\n        const textureSize = this.host.getSize();\r\n        const renderWidth = textureSize.width;\r\n        const renderHeight = textureSize.height;\r\n\r\n        const context = this.host.getContext();\r\n\r\n        const measure = new Measure(0, 0, renderWidth, renderHeight);\r\n\r\n        this.host._numLayoutCalls = 0;\r\n\r\n        this.host._rootContainer._layout(measure, context);\r\n\r\n        // in freeze mode, prepare children measures accordingly\r\n        if (value) {\r\n            this._updateMeasures();\r\n            if (this._useBuckets()) {\r\n                this._makeBuckets();\r\n            }\r\n        }\r\n\r\n        this._freezeControls = value;\r\n\r\n        this.host.markAsDirty(); // redraw with the (new) current settings\r\n    }\r\n\r\n    private _bucketWidth: number = 0;\r\n    private _bucketHeight: number = 0;\r\n    private _buckets: { [key: number]: Array<Control> } = {};\r\n    private _bucketLen: number;\r\n\r\n    public get bucketWidth(): number {\r\n        return this._bucketWidth;\r\n    }\r\n\r\n    public get bucketHeight(): number {\r\n        return this._bucketHeight;\r\n    }\r\n\r\n    public setBucketSizes(width: number, height: number): void {\r\n        this._bucketWidth = width;\r\n        this._bucketHeight = height;\r\n\r\n        if (this._useBuckets()) {\r\n            if (this._freezeControls) {\r\n                this._makeBuckets();\r\n            }\r\n        } else {\r\n            this._buckets = {};\r\n        }\r\n    }\r\n\r\n    private _useBuckets(): boolean {\r\n        return this._bucketWidth > 0 && this._bucketHeight > 0;\r\n    }\r\n\r\n    private _makeBuckets(): void {\r\n        this._buckets = {};\r\n        this._bucketLen = Math.ceil(this.widthInPixels / this._bucketWidth);\r\n        this._dispatchInBuckets(this._children);\r\n        this._oldLeft = null;\r\n        this._oldTop = null;\r\n    }\r\n\r\n    private _dispatchInBuckets(children: Control[]): void {\r\n        for (let i = 0; i < children.length; ++i) {\r\n            const child = children[i];\r\n\r\n            const bStartX = Math.max(0, Math.floor((child._customData._origLeft - this._customData.origLeft) / this._bucketWidth)),\r\n                bEndX = Math.floor((child._customData._origLeft - this._customData.origLeft + child._currentMeasure.width - 1) / this._bucketWidth),\r\n                bEndY = Math.floor((child._customData._origTop - this._customData.origTop + child._currentMeasure.height - 1) / this._bucketHeight);\r\n            let bStartY = Math.max(0, Math.floor((child._customData._origTop - this._customData.origTop) / this._bucketHeight));\r\n\r\n            while (bStartY <= bEndY) {\r\n                for (let x = bStartX; x <= bEndX; ++x) {\r\n                    const bucket = bStartY * this._bucketLen + x;\r\n                    let lstc = this._buckets[bucket];\r\n\r\n                    if (!lstc) {\r\n                        lstc = [];\r\n                        this._buckets[bucket] = lstc;\r\n                    }\r\n\r\n                    lstc.push(child);\r\n                }\r\n                bStartY++;\r\n            }\r\n\r\n            if (child instanceof Container && child._children.length > 0) {\r\n                this._dispatchInBuckets(child._children);\r\n            }\r\n        }\r\n    }\r\n\r\n    // reset left and top measures for the window and all its children\r\n    private _updateMeasures(): void {\r\n        const left = this.leftInPixels | 0,\r\n            top = this.topInPixels | 0;\r\n\r\n        this._measureForChildren.left -= left;\r\n        this._measureForChildren.top -= top;\r\n        this._currentMeasure.left -= left;\r\n        this._currentMeasure.top -= top;\r\n\r\n        this._customData.origLeftForChildren = this._measureForChildren.left;\r\n        this._customData.origTopForChildren = this._measureForChildren.top;\r\n        this._customData.origLeft = this._currentMeasure.left;\r\n        this._customData.origTop = this._currentMeasure.top;\r\n\r\n        this._updateChildrenMeasures(this._children, left, top);\r\n    }\r\n\r\n    private _updateChildrenMeasures(children: Control[], left: number, top: number): void {\r\n        for (let i = 0; i < children.length; ++i) {\r\n            const child = children[i];\r\n\r\n            child._currentMeasure.left -= left;\r\n            child._currentMeasure.top -= top;\r\n\r\n            child._customData._origLeft = child._currentMeasure.left; // save the original left and top values for each child\r\n            child._customData._origTop = child._currentMeasure.top;\r\n\r\n            if (child instanceof Container && child._children.length > 0) {\r\n                this._updateChildrenMeasures(child._children, left, top);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _restoreMeasures(): void {\r\n        const left = this.leftInPixels | 0,\r\n            top = this.topInPixels | 0;\r\n\r\n        this._measureForChildren.left = this._customData.origLeftForChildren + left;\r\n        this._measureForChildren.top = this._customData.origTopForChildren + top;\r\n        this._currentMeasure.left = this._customData.origLeft + left;\r\n        this._currentMeasure.top = this._customData.origTop + top;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ScrollViewerWindow\r\n     * @param name of ScrollViewerWindow\r\n     */\r\n    constructor(name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"ScrollViewerWindow\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._additionalProcessing(parentMeasure, context);\r\n\r\n        this._parentMeasure = parentMeasure;\r\n\r\n        this._measureForChildren.left = this._currentMeasure.left;\r\n        this._measureForChildren.top = this._currentMeasure.top;\r\n\r\n        this._measureForChildren.width = parentMeasure.width;\r\n        this._measureForChildren.height = parentMeasure.height;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _layout(parentMeasure: Measure, context: ICanvasRenderingContext): boolean {\r\n        if (this._freezeControls) {\r\n            this.invalidateRect(); // will trigger a redraw of the window\r\n            return false;\r\n        }\r\n\r\n        return super._layout(parentMeasure, context);\r\n    }\r\n\r\n    private _scrollChildren(children: Control[], left: number, top: number): void {\r\n        for (let i = 0; i < children.length; ++i) {\r\n            const child = children[i];\r\n\r\n            child._currentMeasure.left = child._customData._origLeft + left;\r\n            child._currentMeasure.top = child._customData._origTop + top;\r\n            child._isClipped = false; // clipping will be handled by _draw and the call to _intersectsRect()\r\n\r\n            if (child instanceof Container && child._children.length > 0) {\r\n                this._scrollChildren(child._children, left, top);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _scrollChildrenWithBuckets(left: number, top: number, scrollLeft: number, scrollTop: number): void {\r\n        const bStartX = Math.max(0, Math.floor(-left / this._bucketWidth)),\r\n            bEndX = Math.floor((-left + this._parentMeasure.width - 1) / this._bucketWidth),\r\n            bEndY = Math.floor((-top + this._parentMeasure.height - 1) / this._bucketHeight);\r\n        let bStartY = Math.max(0, Math.floor(-top / this._bucketHeight));\r\n\r\n        while (bStartY <= bEndY) {\r\n            for (let x = bStartX; x <= bEndX; ++x) {\r\n                const bucket = bStartY * this._bucketLen + x,\r\n                    lstc = this._buckets[bucket];\r\n\r\n                if (lstc) {\r\n                    for (let i = 0; i < lstc.length; ++i) {\r\n                        const child = lstc[i];\r\n                        child._currentMeasure.left = child._customData._origLeft + scrollLeft;\r\n                        child._currentMeasure.top = child._customData._origTop + scrollTop;\r\n                        child._isClipped = false; // clipping will be handled by _draw and the call to _intersectsRect()\r\n                    }\r\n                }\r\n            }\r\n            bStartY++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(context: ICanvasRenderingContext, invalidatedRectangle?: Measure): void {\r\n        if (!this._freezeControls) {\r\n            super._draw(context, invalidatedRectangle);\r\n            return;\r\n        }\r\n\r\n        this._localDraw(context);\r\n\r\n        if (this.clipChildren) {\r\n            this._clipForChildren(context);\r\n        }\r\n\r\n        const left = this.leftInPixels | 0,\r\n            top = this.topInPixels | 0;\r\n\r\n        if (this._useBuckets()) {\r\n            if (this._oldLeft !== null && this._oldTop !== null) {\r\n                this._scrollChildrenWithBuckets(this._oldLeft, this._oldTop, left, top);\r\n                this._scrollChildrenWithBuckets(left, top, left, top);\r\n            } else {\r\n                this._scrollChildren(this._children, left, top);\r\n            }\r\n        } else {\r\n            this._scrollChildren(this._children, left, top);\r\n        }\r\n\r\n        this._oldLeft = left;\r\n        this._oldTop = top;\r\n\r\n        for (const child of this._children) {\r\n            if (!child._intersectsRect(this._parentMeasure)) {\r\n                continue;\r\n            }\r\n            child._render(context, this._parentMeasure);\r\n        }\r\n    }\r\n\r\n    protected override _postMeasure(): void {\r\n        if (this._freezeControls) {\r\n            super._postMeasure();\r\n            return;\r\n        }\r\n\r\n        let maxWidth = this.parentClientWidth;\r\n        let maxHeight = this.parentClientHeight;\r\n        for (const child of this.children) {\r\n            if (!child.isVisible || child.notRenderable) {\r\n                continue;\r\n            }\r\n\r\n            if (child.horizontalAlignment === Control.HORIZONTAL_ALIGNMENT_CENTER) {\r\n                child._offsetLeft(this._currentMeasure.left - child._currentMeasure.left);\r\n            }\r\n\r\n            if (child.verticalAlignment === Control.VERTICAL_ALIGNMENT_CENTER) {\r\n                child._offsetTop(this._currentMeasure.top - child._currentMeasure.top);\r\n            }\r\n\r\n            maxWidth = Math.max(maxWidth, child._currentMeasure.left - this._currentMeasure.left + child._currentMeasure.width + child.paddingRightInPixels);\r\n            maxHeight = Math.max(maxHeight, child._currentMeasure.top - this._currentMeasure.top + child._currentMeasure.height + child.paddingBottomInPixels);\r\n        }\r\n\r\n        if (this._currentMeasure.width !== maxWidth) {\r\n            this._width.updateInPlace(maxWidth, ValueAndUnit.UNITMODE_PIXEL);\r\n            this._currentMeasure.width = maxWidth;\r\n            this._rebuildLayout = true;\r\n            this._isDirty = true;\r\n        }\r\n\r\n        if (this._currentMeasure.height !== maxHeight) {\r\n            this._height.updateInPlace(maxHeight, ValueAndUnit.UNITMODE_PIXEL);\r\n            this._currentMeasure.height = maxHeight;\r\n            this._rebuildLayout = true;\r\n            this._isDirty = true;\r\n        }\r\n\r\n        super._postMeasure();\r\n    }\r\n}\r\n", "import type { Vector2 } from \"core/Maths/math.vector\";\r\nimport { BaseSlider } from \"./baseSlider\";\r\nimport type { Control } from \"../control\";\r\nimport { Measure } from \"../../measure\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { BaseGradient } from \"../gradient/BaseGradient\";\r\nimport type { AdvancedDynamicTexture } from \"gui/2D/advancedDynamicTexture\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\n/**\r\n * Class used to create slider controls\r\n */\r\nexport class ScrollBar extends BaseSlider {\r\n    private _background = \"black\";\r\n    private _borderColor = \"white\";\r\n    private _tempMeasure = new Measure(0, 0, 0, 0);\r\n    private _invertScrollDirection = false;\r\n    private _backgroundGradient: Nullable<BaseGradient> = null;\r\n\r\n    /** Gets or sets border color */\r\n    @serialize()\r\n    public get borderColor(): string {\r\n        return this._borderColor;\r\n    }\r\n\r\n    public set borderColor(value: string) {\r\n        if (this._borderColor === value) {\r\n            return;\r\n        }\r\n\r\n        this._borderColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background color */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background gradient. Takes precedence over gradient. */\r\n    public get backgroundGradient(): Nullable<BaseGradient> {\r\n        return this._backgroundGradient;\r\n    }\r\n\r\n    public set backgroundGradient(value: Nullable<BaseGradient>) {\r\n        if (this._backgroundGradient === value) {\r\n            return;\r\n        }\r\n\r\n        this._backgroundGradient = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Inverts the scrolling direction (default: false) */\r\n    @serialize()\r\n    public get invertScrollDirection() {\r\n        return this._invertScrollDirection;\r\n    }\r\n\r\n    public set invertScrollDirection(invert: boolean) {\r\n        this._invertScrollDirection = invert;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Slider\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"Scrollbar\";\r\n    }\r\n\r\n    protected override _getThumbThickness(): number {\r\n        let thumbThickness = 0;\r\n        if (this._thumbWidth.isPixel) {\r\n            thumbThickness = this._thumbWidth.getValue(this._host);\r\n        } else {\r\n            thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);\r\n        }\r\n        return thumbThickness;\r\n    }\r\n\r\n    private _getBackgroundColor(context: ICanvasRenderingContext) {\r\n        return this._backgroundGradient ? this._backgroundGradient.getCanvasGradient(context) : this._background;\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n        this._prepareRenderingData(\"rectangle\");\r\n        const left = this._renderLeft;\r\n\r\n        const thumbPosition = this._getThumbPosition();\r\n        context.fillStyle = this._getBackgroundColor(context);\r\n\r\n        context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n\r\n        // Value bar\r\n        context.fillStyle = this._getColor(context);\r\n\r\n        // Thumb\r\n        if (this.isVertical) {\r\n            this._tempMeasure.left = left - this._effectiveBarOffset;\r\n            this._tempMeasure.top = this._currentMeasure.top + thumbPosition;\r\n            this._tempMeasure.width = this._currentMeasure.width;\r\n            this._tempMeasure.height = this._effectiveThumbThickness;\r\n        } else {\r\n            this._tempMeasure.left = this._currentMeasure.left + thumbPosition;\r\n            this._tempMeasure.top = this._currentMeasure.top;\r\n            this._tempMeasure.width = this._effectiveThumbThickness;\r\n            this._tempMeasure.height = this._currentMeasure.height;\r\n        }\r\n\r\n        context.fillRect(this._tempMeasure.left, this._tempMeasure.top, this._tempMeasure.width, this._tempMeasure.height);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    private _first: boolean;\r\n    private _originX: number;\r\n    private _originY: number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _updateValueFromPointer(x: number, y: number): void {\r\n        if (this.rotation != 0) {\r\n            this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);\r\n            x = this._transformedPosition.x;\r\n            y = this._transformedPosition.y;\r\n        }\r\n\r\n        const sign = this._invertScrollDirection ? -1 : 1;\r\n\r\n        if (this._first) {\r\n            this._first = false;\r\n            this._originX = x;\r\n            this._originY = y;\r\n\r\n            // Check if move is required\r\n            if (\r\n                x < this._tempMeasure.left ||\r\n                x > this._tempMeasure.left + this._tempMeasure.width ||\r\n                y < this._tempMeasure.top ||\r\n                y > this._tempMeasure.top + this._tempMeasure.height\r\n            ) {\r\n                if (this.isVertical) {\r\n                    this.value = this.minimum + (1 - (y - this._currentMeasure.top) / this._currentMeasure.height) * (this.maximum - this.minimum);\r\n                } else {\r\n                    this.value = this.minimum + ((x - this._currentMeasure.left) / this._currentMeasure.width) * (this.maximum - this.minimum);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Delta mode\r\n        let delta = 0;\r\n        if (this.isVertical) {\r\n            delta = -((y - this._originY) / (this._currentMeasure.height - this._effectiveThumbThickness));\r\n        } else {\r\n            delta = (x - this._originX) / (this._currentMeasure.width - this._effectiveThumbThickness);\r\n        }\r\n\r\n        this.value += sign * delta * (this.maximum - this.minimum);\r\n\r\n        this._originX = x;\r\n        this._originY = y;\r\n    }\r\n\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        this._first = true;\r\n\r\n        return super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi);\r\n    }\r\n\r\n    public override serialize(serializationObject: any) {\r\n        super.serialize(serializationObject);\r\n\r\n        if (this.backgroundGradient) {\r\n            serializationObject.backgroundGradient = {};\r\n            this.backgroundGradient.serialize(serializationObject.backgroundGradient);\r\n        }\r\n    }\r\n\r\n    public override _parseFromContent(serializationObject: any, host: AdvancedDynamicTexture) {\r\n        super._parseFromContent(serializationObject, host);\r\n\r\n        if (serializationObject.backgroundGradient) {\r\n            const className = Tools.Instantiate(\"BABYLON.GUI.\" + serializationObject.backgroundGradient.className);\r\n            this.backgroundGradient = new className();\r\n            this.backgroundGradient!.parse(serializationObject.backgroundGradient);\r\n        }\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.Scrollbar\", ScrollBar);\r\n", "import type { Vector2 } from \"core/Maths/math.vector\";\r\nimport { BaseSlider } from \"./baseSlider\";\r\nimport type { Control } from \"../control\";\r\nimport type { Image } from \"../image\";\r\nimport { Measure } from \"../../measure\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Class used to create slider controls\r\n */\r\nexport class ImageScrollBar extends BaseSlider {\r\n    private _backgroundBaseImage: Image;\r\n    private _backgroundImage: Image;\r\n    private _thumbImage: Image;\r\n    private _thumbBaseImage: Image;\r\n    private _thumbLength: number = 0.5;\r\n    private _thumbHeight: number = 1;\r\n    private _barImageHeight: number = 1;\r\n    private _tempMeasure = new Measure(0, 0, 0, 0);\r\n    private _invertScrollDirection = false;\r\n\r\n    /** Number of 90° rotation to apply on the images when in vertical mode */\r\n    @serialize()\r\n    public num90RotationInVerticalMode = 1;\r\n\r\n    /** Inverts the scrolling direction (default: false) */\r\n    @serialize()\r\n    public get invertScrollDirection() {\r\n        return this._invertScrollDirection;\r\n    }\r\n\r\n    public set invertScrollDirection(invert: boolean) {\r\n        this._invertScrollDirection = invert;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the image used to render the background for horizontal bar\r\n     */\r\n    public get backgroundImage(): Image {\r\n        return this._backgroundBaseImage;\r\n    }\r\n\r\n    public set backgroundImage(value: Image) {\r\n        if (this._backgroundBaseImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._backgroundBaseImage = value;\r\n\r\n        if (this.isVertical && this.num90RotationInVerticalMode !== 0) {\r\n            if (!value.isLoaded) {\r\n                value.onImageLoadedObservable.addOnce(() => {\r\n                    const rotatedValue = value._rotate90(this.num90RotationInVerticalMode, true);\r\n                    this._backgroundImage = rotatedValue;\r\n                    if (!rotatedValue.isLoaded) {\r\n                        rotatedValue.onImageLoadedObservable.addOnce(() => {\r\n                            this._markAsDirty();\r\n                        });\r\n                    }\r\n                    this._markAsDirty();\r\n                });\r\n            } else {\r\n                this._backgroundImage = value._rotate90(this.num90RotationInVerticalMode, true);\r\n                this._markAsDirty();\r\n            }\r\n        } else {\r\n            this._backgroundImage = value;\r\n            if (value && !value.isLoaded) {\r\n                value.onImageLoadedObservable.addOnce(() => {\r\n                    this._markAsDirty();\r\n                });\r\n            }\r\n\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the image used to render the thumb\r\n     */\r\n    public get thumbImage(): Image {\r\n        return this._thumbBaseImage;\r\n    }\r\n\r\n    public set thumbImage(value: Image) {\r\n        if (this._thumbBaseImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._thumbBaseImage = value;\r\n\r\n        if (this.isVertical && this.num90RotationInVerticalMode !== 0) {\r\n            if (!value.isLoaded) {\r\n                value.onImageLoadedObservable.addOnce(() => {\r\n                    const rotatedValue = value._rotate90(-this.num90RotationInVerticalMode, true);\r\n                    this._thumbImage = rotatedValue;\r\n                    if (!rotatedValue.isLoaded) {\r\n                        rotatedValue.onImageLoadedObservable.addOnce(() => {\r\n                            this._markAsDirty();\r\n                        });\r\n                    }\r\n                    this._markAsDirty();\r\n                });\r\n            } else {\r\n                this._thumbImage = value._rotate90(-this.num90RotationInVerticalMode, true);\r\n                this._markAsDirty();\r\n            }\r\n        } else {\r\n            this._thumbImage = value;\r\n            if (value && !value.isLoaded) {\r\n                value.onImageLoadedObservable.addOnce(() => {\r\n                    this._markAsDirty();\r\n                });\r\n            }\r\n\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the length of the thumb\r\n     */\r\n    public get thumbLength(): number {\r\n        return this._thumbLength;\r\n    }\r\n\r\n    public set thumbLength(value: number) {\r\n        if (this._thumbLength === value) {\r\n            return;\r\n        }\r\n\r\n        this._thumbLength = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the height of the thumb\r\n     */\r\n    public get thumbHeight(): number {\r\n        return this._thumbHeight;\r\n    }\r\n\r\n    public set thumbHeight(value: number) {\r\n        if (this._thumbLength === value) {\r\n            return;\r\n        }\r\n\r\n        this._thumbHeight = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the height of the bar image\r\n     */\r\n    public get barImageHeight(): number {\r\n        return this._barImageHeight;\r\n    }\r\n\r\n    public set barImageHeight(value: number) {\r\n        if (this._barImageHeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._barImageHeight = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new ImageScrollBar\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"ImageScrollBar\";\r\n    }\r\n\r\n    protected override _getThumbThickness(): number {\r\n        let thumbThickness = 0;\r\n        if (this._thumbWidth.isPixel) {\r\n            thumbThickness = this._thumbWidth.getValue(this._host);\r\n        } else {\r\n            thumbThickness = this._backgroundBoxThickness * this._thumbWidth.getValue(this._host);\r\n        }\r\n        return thumbThickness;\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        this._prepareRenderingData(\"rectangle\");\r\n        const thumbPosition = this._getThumbPosition();\r\n        const left = this._renderLeft;\r\n        const top = this._renderTop;\r\n        const width = this._renderWidth;\r\n        const height = this._renderHeight;\r\n\r\n        // Background\r\n        if (this._backgroundImage) {\r\n            this._tempMeasure.copyFromFloats(left, top, width, height);\r\n            if (this.isVertical) {\r\n                this._tempMeasure.copyFromFloats(left + width * (1 - this._barImageHeight) * 0.5, this._currentMeasure.top, width * this._barImageHeight, height);\r\n                this._tempMeasure.height += this._effectiveThumbThickness;\r\n                this._backgroundImage._currentMeasure.copyFrom(this._tempMeasure);\r\n            } else {\r\n                this._tempMeasure.copyFromFloats(this._currentMeasure.left, top + height * (1 - this._barImageHeight) * 0.5, width, height * this._barImageHeight);\r\n                this._tempMeasure.width += this._effectiveThumbThickness;\r\n                this._backgroundImage._currentMeasure.copyFrom(this._tempMeasure);\r\n            }\r\n            this._backgroundImage._draw(context);\r\n        }\r\n\r\n        // Thumb\r\n        if (this.isVertical) {\r\n            this._tempMeasure.copyFromFloats(\r\n                left - this._effectiveBarOffset + this._currentMeasure.width * (1 - this._thumbHeight) * 0.5,\r\n                this._currentMeasure.top + thumbPosition,\r\n                this._currentMeasure.width * this._thumbHeight,\r\n                this._effectiveThumbThickness\r\n            );\r\n        } else {\r\n            this._tempMeasure.copyFromFloats(\r\n                this._currentMeasure.left + thumbPosition,\r\n                this._currentMeasure.top + this._currentMeasure.height * (1 - this._thumbHeight) * 0.5,\r\n                this._effectiveThumbThickness,\r\n                this._currentMeasure.height * this._thumbHeight\r\n            );\r\n        }\r\n\r\n        if (this._thumbImage) {\r\n            this._thumbImage._currentMeasure.copyFrom(this._tempMeasure);\r\n            this._thumbImage._draw(context);\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    private _first: boolean;\r\n    private _originX: number;\r\n    private _originY: number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _updateValueFromPointer(x: number, y: number): void {\r\n        if (this.rotation != 0) {\r\n            this._invertTransformMatrix.transformCoordinates(x, y, this._transformedPosition);\r\n            x = this._transformedPosition.x;\r\n            y = this._transformedPosition.y;\r\n        }\r\n\r\n        const sign = this._invertScrollDirection ? -1 : 1;\r\n\r\n        if (this._first) {\r\n            this._first = false;\r\n            this._originX = x;\r\n            this._originY = y;\r\n\r\n            // Check if move is required\r\n            if (\r\n                x < this._tempMeasure.left ||\r\n                x > this._tempMeasure.left + this._tempMeasure.width ||\r\n                y < this._tempMeasure.top ||\r\n                y > this._tempMeasure.top + this._tempMeasure.height\r\n            ) {\r\n                if (this.isVertical) {\r\n                    this.value = this.minimum + (1 - (y - this._currentMeasure.top) / this._currentMeasure.height) * (this.maximum - this.minimum);\r\n                } else {\r\n                    this.value = this.minimum + ((x - this._currentMeasure.left) / this._currentMeasure.width) * (this.maximum - this.minimum);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Delta mode\r\n        let delta = 0;\r\n        if (this.isVertical) {\r\n            delta = -((y - this._originY) / (this._currentMeasure.height - this._effectiveThumbThickness));\r\n        } else {\r\n            delta = (x - this._originX) / (this._currentMeasure.width - this._effectiveThumbThickness);\r\n        }\r\n\r\n        this.value += sign * delta * (this.maximum - this.minimum);\r\n\r\n        this._originX = x;\r\n        this._originY = y;\r\n    }\r\n\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        this._first = true;\r\n\r\n        return super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi);\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math\";\r\nimport { Rectangle } from \"../rectangle\";\r\nimport { Grid } from \"../grid\";\r\nimport type { Image } from \"../image\";\r\nimport { Control } from \"../control\";\r\nimport type { Container } from \"../container\";\r\nimport type { Measure } from \"../../measure\";\r\nimport type { AdvancedDynamicTexture } from \"../../advancedDynamicTexture\";\r\nimport { _ScrollViewerWindow } from \"./scrollViewerWindow\";\r\nimport { ScrollBar } from \"../sliders/scrollBar\";\r\nimport { ImageScrollBar } from \"../sliders/imageScrollBar\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * Class used to hold a viewer window and sliders in a grid\r\n */\r\nexport class ScrollViewer extends Rectangle {\r\n    private _grid: Grid;\r\n    private _horizontalBarSpace: Rectangle;\r\n    private _verticalBarSpace: Rectangle;\r\n    private _dragSpace: Rectangle;\r\n    private _horizontalBar: ScrollBar | ImageScrollBar;\r\n    private _verticalBar: ScrollBar | ImageScrollBar;\r\n    private _barColor: string;\r\n    private _barBackground: string;\r\n    private _barImage: Image;\r\n    private _horizontalBarImage: Image;\r\n    private _verticalBarImage: Image;\r\n    private _barBackgroundImage: Image;\r\n    private _horizontalBarBackgroundImage: Image;\r\n    private _verticalBarBackgroundImage: Image;\r\n    private _barSize: number = 20;\r\n    private _window: _ScrollViewerWindow;\r\n    private _pointerIsOver: Boolean = false;\r\n    private _wheelPrecision: number = 0.05;\r\n    private _onWheelObserver: Nullable<Observer<Vector2>>;\r\n    private _clientWidth: number;\r\n    private _clientHeight: number;\r\n    private _useImageBar: Boolean;\r\n    private _thumbLength: number = 0.5;\r\n    private _thumbHeight: number = 1;\r\n    private _barImageHeight: number = 1;\r\n    private _horizontalBarImageHeight: number = 1;\r\n    private _verticalBarImageHeight: number = 1;\r\n    private _oldWindowContentsWidth: number = 0;\r\n    private _oldWindowContentsHeight: number = 0;\r\n\r\n    /**\r\n     * Gets the horizontal scrollbar\r\n     */\r\n    public get horizontalBar(): ScrollBar | ImageScrollBar {\r\n        return this._horizontalBar;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertical scrollbar\r\n     */\r\n    public get verticalBar(): ScrollBar | ImageScrollBar {\r\n        return this._verticalBar;\r\n    }\r\n\r\n    /**\r\n     * Adds a new control to the current container\r\n     * @param control defines the control to add\r\n     * @returns the current container\r\n     */\r\n    public override addControl(control: Nullable<Control>): Container {\r\n        if (!control) {\r\n            return this;\r\n        }\r\n\r\n        this._window.addControl(control);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a control from the current container\r\n     * @param control defines the control to remove\r\n     * @returns the current container\r\n     */\r\n    public override removeControl(control: Control): Container {\r\n        this._window.removeControl(control);\r\n        return this;\r\n    }\r\n\r\n    /** Gets the list of children */\r\n    public override get children(): Control[] {\r\n        return this._window.children;\r\n    }\r\n\r\n    public override _flagDescendantsAsMatrixDirty(): void {\r\n        for (const child of this._children) {\r\n            child._markMatrixAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Freezes or unfreezes the controls in the window.\r\n     * When controls are frozen, the scroll viewer can render a lot more quickly but updates to positions/sizes of controls\r\n     * are not taken into account. If you want to change positions/sizes, unfreeze, perform the changes then freeze again\r\n     */\r\n    public get freezeControls(): boolean {\r\n        return this._window.freezeControls;\r\n    }\r\n\r\n    public set freezeControls(value: boolean) {\r\n        this._window.freezeControls = value;\r\n    }\r\n\r\n    /** Gets the bucket width */\r\n    public get bucketWidth(): number {\r\n        return this._window.bucketWidth;\r\n    }\r\n\r\n    /** Gets the bucket height */\r\n    public get bucketHeight(): number {\r\n        return this._window.bucketHeight;\r\n    }\r\n\r\n    /**\r\n     * Sets the bucket sizes.\r\n     * When freezeControls is true, setting a non-zero bucket size will improve performances by updating only\r\n     * controls that are visible. The bucket sizes is used to subdivide (internally) the window area to smaller areas into which\r\n     * controls are dispatched. So, the size should be roughly equals to the mean size of all the controls of\r\n     * the window. To disable the usage of buckets, sets either width or height (or both) to 0.\r\n     * Please note that using this option will raise the memory usage (the higher the bucket sizes, the less memory\r\n     * used), that's why it is not enabled by default.\r\n     * @param width width of the bucket\r\n     * @param height height of the bucket\r\n     */\r\n    public setBucketSizes(width: number, height: number): void {\r\n        this._window.setBucketSizes(width, height);\r\n    }\r\n\r\n    private _forceHorizontalBar: boolean = false;\r\n    private _forceVerticalBar: boolean = false;\r\n\r\n    /**\r\n     * Forces the horizontal scroll bar to be displayed\r\n     */\r\n    public get forceHorizontalBar(): boolean {\r\n        return this._forceHorizontalBar;\r\n    }\r\n\r\n    public set forceHorizontalBar(value: boolean) {\r\n        this._grid.setRowDefinition(1, value ? this._barSize : 0, true);\r\n        this._horizontalBar.isVisible = value;\r\n        this._forceHorizontalBar = value;\r\n    }\r\n\r\n    /**\r\n     * Forces the vertical scroll bar to be displayed\r\n     */\r\n    public get forceVerticalBar(): boolean {\r\n        return this._forceVerticalBar;\r\n    }\r\n\r\n    public set forceVerticalBar(value: boolean) {\r\n        this._grid.setColumnDefinition(1, value ? this._barSize : 0, true);\r\n        this._verticalBar.isVisible = value;\r\n        this._forceVerticalBar = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ScrollViewer\r\n     * @param name of ScrollViewer\r\n     * @param isImageBased\r\n     */\r\n    constructor(name?: string, isImageBased?: boolean) {\r\n        super(name);\r\n\r\n        this._useImageBar = isImageBased ? isImageBased : false;\r\n\r\n        this.onDirtyObservable.add(() => {\r\n            this._horizontalBarSpace.color = this.color;\r\n            this._verticalBarSpace.color = this.color;\r\n            this._dragSpace.color = this.color;\r\n        });\r\n\r\n        this.onPointerEnterObservable.add(() => {\r\n            this._pointerIsOver = true;\r\n        });\r\n\r\n        this.onPointerOutObservable.add(() => {\r\n            this._pointerIsOver = false;\r\n        });\r\n\r\n        this._grid = new Grid();\r\n        if (this._useImageBar) {\r\n            this._horizontalBar = new ImageScrollBar();\r\n            this._verticalBar = new ImageScrollBar();\r\n        } else {\r\n            this._horizontalBar = new ScrollBar();\r\n            this._verticalBar = new ScrollBar();\r\n        }\r\n\r\n        this._window = new _ScrollViewerWindow(\"scrollViewer_window\");\r\n        this._window.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this._window.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n\r\n        this._grid.addColumnDefinition(1);\r\n        this._grid.addColumnDefinition(0, true);\r\n        this._grid.addRowDefinition(1);\r\n        this._grid.addRowDefinition(0, true);\r\n\r\n        super.addControl(this._grid);\r\n        this._grid.addControl(this._window, 0, 0);\r\n\r\n        this._verticalBarSpace = new Rectangle();\r\n        this._verticalBarSpace.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this._verticalBarSpace.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this._verticalBarSpace.thickness = 1;\r\n        this._grid.addControl(this._verticalBarSpace, 0, 1);\r\n        this._addBar(this._verticalBar, this._verticalBarSpace, true, Math.PI);\r\n\r\n        this._horizontalBarSpace = new Rectangle();\r\n        this._horizontalBarSpace.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this._horizontalBarSpace.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this._horizontalBarSpace.thickness = 1;\r\n        this._grid.addControl(this._horizontalBarSpace, 1, 0);\r\n        this._addBar(this._horizontalBar, this._horizontalBarSpace, false, 0);\r\n\r\n        this._dragSpace = new Rectangle();\r\n        this._dragSpace.thickness = 1;\r\n        this._grid.addControl(this._dragSpace, 1, 1);\r\n\r\n        this._grid.clipChildren = false;\r\n\r\n        // Colors\r\n        if (!this._useImageBar) {\r\n            this.barColor = \"grey\";\r\n            this.barBackground = \"transparent\";\r\n        }\r\n    }\r\n\r\n    /** Reset the scroll viewer window to initial size */\r\n    public resetWindow() {\r\n        this._window.width = \"100%\";\r\n        this._window.height = \"100%\";\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"ScrollViewer\";\r\n    }\r\n\r\n    private _buildClientSizes() {\r\n        const ratio = this.host.idealRatio;\r\n\r\n        this._window.parentClientWidth = this._currentMeasure.width - (this._verticalBar.isVisible || this.forceVerticalBar ? this._barSize * ratio : 0) - 2 * this.thickness;\r\n        this._window.parentClientHeight = this._currentMeasure.height - (this._horizontalBar.isVisible || this.forceHorizontalBar ? this._barSize * ratio : 0) - 2 * this.thickness;\r\n\r\n        this._clientWidth = this._window.parentClientWidth;\r\n        this._clientHeight = this._window.parentClientHeight;\r\n    }\r\n\r\n    protected override _additionalProcessing(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._additionalProcessing(parentMeasure, context);\r\n\r\n        this._buildClientSizes();\r\n    }\r\n\r\n    protected override _postMeasure(): void {\r\n        super._postMeasure();\r\n\r\n        this._updateScroller();\r\n\r\n        this._setWindowPosition(false);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the mouse wheel precision\r\n     * from 0 to 1 with a default value of 0.05\r\n     * */\r\n    @serialize()\r\n    public get wheelPrecision(): number {\r\n        return this._wheelPrecision;\r\n    }\r\n\r\n    public set wheelPrecision(value: number) {\r\n        if (this._wheelPrecision === value) {\r\n            return;\r\n        }\r\n\r\n        if (value < 0) {\r\n            value = 0;\r\n        }\r\n\r\n        if (value > 1) {\r\n            value = 1;\r\n        }\r\n\r\n        this._wheelPrecision = value;\r\n    }\r\n\r\n    /** Gets or sets the scroll bar container background color */\r\n    @serialize()\r\n    public get scrollBackground(): string {\r\n        return this._horizontalBarSpace.background;\r\n    }\r\n\r\n    public set scrollBackground(color: string) {\r\n        if (this._horizontalBarSpace.background === color) {\r\n            return;\r\n        }\r\n        this._horizontalBarSpace.background = color;\r\n        this._verticalBarSpace.background = color;\r\n    }\r\n\r\n    /** Gets or sets the bar color */\r\n    @serialize()\r\n    public get barColor(): string {\r\n        return this._barColor;\r\n    }\r\n\r\n    public set barColor(color: string) {\r\n        if (this._barColor === color) {\r\n            return;\r\n        }\r\n\r\n        this._barColor = color;\r\n        this._horizontalBar.color = color;\r\n        this._verticalBar.color = color;\r\n    }\r\n\r\n    /** Gets or sets the bar image */\r\n    public get thumbImage(): Image {\r\n        return this._barImage;\r\n    }\r\n\r\n    public set thumbImage(value: Image) {\r\n        if (this._barImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._barImage = value;\r\n        const hb = <ImageScrollBar>this._horizontalBar;\r\n        const vb = <ImageScrollBar>this._verticalBar;\r\n        hb.thumbImage = value;\r\n        vb.thumbImage = value;\r\n    }\r\n\r\n    /** Gets or sets the horizontal bar image */\r\n    public get horizontalThumbImage(): Image {\r\n        return this._horizontalBarImage;\r\n    }\r\n\r\n    public set horizontalThumbImage(value: Image) {\r\n        if (this._horizontalBarImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._horizontalBarImage = value;\r\n        const hb = <ImageScrollBar>this._horizontalBar;\r\n        hb.thumbImage = value;\r\n    }\r\n\r\n    /** Gets or sets the vertical bar image */\r\n    public get verticalThumbImage(): Image {\r\n        return this._verticalBarImage;\r\n    }\r\n\r\n    public set verticalThumbImage(value: Image) {\r\n        if (this._verticalBarImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._verticalBarImage = value;\r\n        const vb = <ImageScrollBar>this._verticalBar;\r\n        vb.thumbImage = value;\r\n    }\r\n\r\n    /** Gets or sets the size of the bar */\r\n    @serialize()\r\n    public get barSize(): number {\r\n        return this._barSize;\r\n    }\r\n\r\n    public set barSize(value: number) {\r\n        if (this._barSize === value) {\r\n            return;\r\n        }\r\n\r\n        this._barSize = value;\r\n        this._markAsDirty();\r\n\r\n        if (this._horizontalBar.isVisible) {\r\n            this._grid.setRowDefinition(1, this._barSize, true);\r\n        }\r\n        if (this._verticalBar.isVisible) {\r\n            this._grid.setColumnDefinition(1, this._barSize, true);\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the length of the thumb */\r\n    public get thumbLength(): number {\r\n        return this._thumbLength;\r\n    }\r\n\r\n    public set thumbLength(value: number) {\r\n        if (this._thumbLength === value) {\r\n            return;\r\n        }\r\n        if (value <= 0) {\r\n            value = 0.1;\r\n        }\r\n        if (value > 1) {\r\n            value = 1;\r\n        }\r\n        this._thumbLength = value;\r\n        const hb = <ImageScrollBar>this._horizontalBar;\r\n        const vb = <ImageScrollBar>this._verticalBar;\r\n        hb.thumbLength = value;\r\n        vb.thumbLength = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the height of the thumb */\r\n    public get thumbHeight(): number {\r\n        return this._thumbHeight;\r\n    }\r\n\r\n    public set thumbHeight(value: number) {\r\n        if (this._thumbHeight === value) {\r\n            return;\r\n        }\r\n        if (value <= 0) {\r\n            value = 0.1;\r\n        }\r\n        if (value > 1) {\r\n            value = 1;\r\n        }\r\n        this._thumbHeight = value;\r\n        const hb = <ImageScrollBar>this._horizontalBar;\r\n        const vb = <ImageScrollBar>this._verticalBar;\r\n        hb.thumbHeight = value;\r\n        vb.thumbHeight = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the height of the bar image */\r\n    public get barImageHeight(): number {\r\n        return this._barImageHeight;\r\n    }\r\n\r\n    public set barImageHeight(value: number) {\r\n        if (this._barImageHeight === value) {\r\n            return;\r\n        }\r\n        if (value <= 0) {\r\n            value = 0.1;\r\n        }\r\n        if (value > 1) {\r\n            value = 1;\r\n        }\r\n        this._barImageHeight = value;\r\n        const hb = <ImageScrollBar>this._horizontalBar;\r\n        const vb = <ImageScrollBar>this._verticalBar;\r\n        hb.barImageHeight = value;\r\n        vb.barImageHeight = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the height of the horizontal bar image */\r\n    public get horizontalBarImageHeight(): number {\r\n        return this._horizontalBarImageHeight;\r\n    }\r\n\r\n    public set horizontalBarImageHeight(value: number) {\r\n        if (this._horizontalBarImageHeight === value) {\r\n            return;\r\n        }\r\n        if (value <= 0) {\r\n            value = 0.1;\r\n        }\r\n        if (value > 1) {\r\n            value = 1;\r\n        }\r\n        this._horizontalBarImageHeight = value;\r\n        const hb = <ImageScrollBar>this._horizontalBar;\r\n        hb.barImageHeight = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the height of the vertical bar image */\r\n    public get verticalBarImageHeight(): number {\r\n        return this._verticalBarImageHeight;\r\n    }\r\n\r\n    public set verticalBarImageHeight(value: number) {\r\n        if (this._verticalBarImageHeight === value) {\r\n            return;\r\n        }\r\n        if (value <= 0) {\r\n            value = 0.1;\r\n        }\r\n        if (value > 1) {\r\n            value = 1;\r\n        }\r\n        this._verticalBarImageHeight = value;\r\n        const vb = <ImageScrollBar>this._verticalBar;\r\n        vb.barImageHeight = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the bar background */\r\n    @serialize()\r\n    public get barBackground(): string {\r\n        return this._barBackground;\r\n    }\r\n\r\n    public set barBackground(color: string) {\r\n        if (this._barBackground === color) {\r\n            return;\r\n        }\r\n\r\n        this._barBackground = color;\r\n        const hb = <ScrollBar>this._horizontalBar;\r\n        const vb = <ScrollBar>this._verticalBar;\r\n        hb.background = color;\r\n        vb.background = color;\r\n        this._dragSpace.background = color;\r\n    }\r\n\r\n    /** Gets or sets the bar background image */\r\n    public get barImage(): Image {\r\n        return this._barBackgroundImage;\r\n    }\r\n\r\n    public set barImage(value: Image) {\r\n        this._barBackgroundImage = value;\r\n        const hb = <ImageScrollBar>this._horizontalBar;\r\n        const vb = <ImageScrollBar>this._verticalBar;\r\n        hb.backgroundImage = value;\r\n        vb.backgroundImage = value;\r\n    }\r\n\r\n    /** Gets or sets the horizontal bar background image */\r\n    public get horizontalBarImage(): Image {\r\n        return this._horizontalBarBackgroundImage;\r\n    }\r\n\r\n    public set horizontalBarImage(value: Image) {\r\n        this._horizontalBarBackgroundImage = value;\r\n        const hb = <ImageScrollBar>this._horizontalBar;\r\n        hb.backgroundImage = value;\r\n    }\r\n\r\n    /** Gets or sets the vertical bar background image */\r\n    public get verticalBarImage(): Image {\r\n        return this._verticalBarBackgroundImage;\r\n    }\r\n\r\n    public set verticalBarImage(value: Image) {\r\n        this._verticalBarBackgroundImage = value;\r\n        const vb = <ImageScrollBar>this._verticalBar;\r\n        vb.backgroundImage = value;\r\n    }\r\n\r\n    private _setWindowPosition(force = true): void {\r\n        const ratio = this.host.idealRatio;\r\n        const windowContentsWidth = this._window._currentMeasure.width;\r\n        const windowContentsHeight = this._window._currentMeasure.height;\r\n\r\n        if (!force && this._oldWindowContentsWidth === windowContentsWidth && this._oldWindowContentsHeight === windowContentsHeight) {\r\n            return;\r\n        }\r\n\r\n        this._oldWindowContentsWidth = windowContentsWidth;\r\n        this._oldWindowContentsHeight = windowContentsHeight;\r\n\r\n        const _endLeft = this._clientWidth - windowContentsWidth;\r\n        const _endTop = this._clientHeight - windowContentsHeight;\r\n\r\n        const newLeft = (this._horizontalBar.value / ratio) * _endLeft + \"px\";\r\n        const newTop = (this._verticalBar.value / ratio) * _endTop + \"px\";\r\n\r\n        if (newLeft !== this._window.left) {\r\n            this._window.left = newLeft;\r\n            if (!this.freezeControls) {\r\n                this._rebuildLayout = true;\r\n            }\r\n        }\r\n\r\n        if (newTop !== this._window.top) {\r\n            this._window.top = newTop;\r\n            if (!this.freezeControls) {\r\n                this._rebuildLayout = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    private _updateScroller(): void {\r\n        const windowContentsWidth = this._window._currentMeasure.width;\r\n        const windowContentsHeight = this._window._currentMeasure.height;\r\n\r\n        if (this._horizontalBar.isVisible && windowContentsWidth <= this._clientWidth && !this.forceHorizontalBar) {\r\n            this._grid.setRowDefinition(1, 0, true);\r\n            this._horizontalBar.isVisible = false;\r\n            this._horizontalBar.value = 0;\r\n            this._rebuildLayout = true;\r\n        } else if (!this._horizontalBar.isVisible && (windowContentsWidth > this._clientWidth || this.forceHorizontalBar)) {\r\n            this._grid.setRowDefinition(1, this._barSize, true);\r\n            this._horizontalBar.isVisible = true;\r\n            this._rebuildLayout = true;\r\n        }\r\n\r\n        if (this._verticalBar.isVisible && windowContentsHeight <= this._clientHeight && !this.forceVerticalBar) {\r\n            this._grid.setColumnDefinition(1, 0, true);\r\n            this._verticalBar.isVisible = false;\r\n            this._verticalBar.value = 0;\r\n            this._rebuildLayout = true;\r\n        } else if (!this._verticalBar.isVisible && (windowContentsHeight > this._clientHeight || this.forceVerticalBar)) {\r\n            this._grid.setColumnDefinition(1, this._barSize, true);\r\n            this._verticalBar.isVisible = true;\r\n            this._rebuildLayout = true;\r\n        }\r\n\r\n        this._buildClientSizes();\r\n\r\n        const ratio = this.host.idealRatio;\r\n\r\n        this._horizontalBar.thumbWidth = this._thumbLength * 0.9 * (this._clientWidth / ratio) + \"px\";\r\n        this._verticalBar.thumbWidth = this._thumbLength * 0.9 * (this._clientHeight / ratio) + \"px\";\r\n    }\r\n\r\n    public override _link(host: AdvancedDynamicTexture): void {\r\n        super._link(host);\r\n\r\n        this._attachWheel();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _addBar(barControl: ScrollBar | ImageScrollBar, barContainer: Rectangle, isVertical: boolean, rotation: number) {\r\n        barControl.paddingLeft = 0;\r\n        barControl.width = \"100%\";\r\n        barControl.height = \"100%\";\r\n        barControl.barOffset = 0;\r\n        barControl.value = 0;\r\n        barControl.maximum = 1;\r\n        barControl.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n        barControl.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n        barControl.isVertical = isVertical;\r\n        barControl.rotation = rotation;\r\n        barControl.isVisible = false;\r\n\r\n        barContainer.addControl(barControl);\r\n\r\n        barControl.onValueChangedObservable.add(() => {\r\n            this._setWindowPosition();\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    private _attachWheel() {\r\n        if (!this._host || this._onWheelObserver) {\r\n            return;\r\n        }\r\n\r\n        this._onWheelObserver = this.onWheelObservable.add((pi) => {\r\n            if (!this._pointerIsOver || this.isReadOnly) {\r\n                return;\r\n            }\r\n            if (this._verticalBar.isVisible == true) {\r\n                if (pi.y < 0 && this._verticalBar.value > 0) {\r\n                    this._verticalBar.value -= this._wheelPrecision;\r\n                } else if (pi.y > 0 && this._verticalBar.value < this._verticalBar.maximum) {\r\n                    this._verticalBar.value += this._wheelPrecision;\r\n                }\r\n            }\r\n            if (this._horizontalBar.isVisible == true) {\r\n                if (pi.x < 0 && this._horizontalBar.value < this._horizontalBar.maximum) {\r\n                    this._horizontalBar.value += this._wheelPrecision;\r\n                } else if (pi.x > 0 && this._horizontalBar.value > 0) {\r\n                    this._horizontalBar.value -= this._wheelPrecision;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public override _renderHighlightSpecific(context: ICanvasRenderingContext): void {\r\n        if (!this.isHighlighted) {\r\n            return;\r\n        }\r\n\r\n        super._renderHighlightSpecific(context);\r\n\r\n        this._grid._renderHighlightSpecific(context);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    /** Releases associated resources */\r\n    public override dispose() {\r\n        this.onWheelObservable.remove(this._onWheelObserver);\r\n        this._onWheelObserver = null;\r\n        super.dispose();\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.ScrollViewer\", ScrollViewer);\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Vector2 } from \"core/Maths/math.vector\";\r\n\r\nimport { Rectangle } from \"./rectangle\";\r\nimport type { Control } from \"./control\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { PointerInfoBase } from \"core/Events/pointerEvents\";\r\n\r\n/**\r\n * Class used to create toggle buttons\r\n * @since 5.0.0\r\n */\r\nexport class ToggleButton extends Rectangle {\r\n    /**\r\n     * Function called to generate the toActive animation\r\n     */\r\n    public toActiveAnimation: () => void;\r\n\r\n    /**\r\n     * Function called to generate the toInactive animation\r\n     */\r\n    public toInactiveAnimation: () => void;\r\n\r\n    /**\r\n     * Function called to generate a pointer enter animation when the toggle button is active.\r\n     */\r\n    public pointerEnterActiveAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer out animation when the toggle button is active.\r\n     */\r\n    public pointerOutActiveAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer down animation when the toggle button is active.\r\n     */\r\n    public pointerDownActiveAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer up animation when the toggle button is active.\r\n     */\r\n    public pointerUpActiveAnimation: () => void;\r\n\r\n    /**\r\n     * Function called to generate a pointer enter animation when the toggle button is inactive.\r\n     */\r\n    public pointerEnterInactiveAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer out animation when the toggle button is inactive.\r\n     */\r\n    public pointerOutInactiveAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer down animation when the toggle button is inactive.\r\n     */\r\n    public pointerDownInactiveAnimation: () => void;\r\n    /**\r\n     * Function called to generate a pointer up animation when the toggle button is inactive.\r\n     */\r\n    public pointerUpInactiveAnimation: () => void;\r\n\r\n    /** Observable raised when isActive is changed */\r\n    public onIsActiveChangedObservable = new Observable<boolean>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the toggle button will let internal controls handle picking instead of doing it directly using its bounding info\r\n     */\r\n    public override delegatePickingToChildren = false;\r\n\r\n    private _group: string;\r\n    /** Gets or sets group name this toggle button belongs to */\r\n    public get group(): string {\r\n        return this._group;\r\n    }\r\n    public set group(value: string) {\r\n        if (this._group === value) {\r\n            return;\r\n        }\r\n\r\n        this._group = value;\r\n    }\r\n\r\n    private _isActive = false;\r\n    /** Gets or sets a boolean indicating if the toggle button is active or not */\r\n    public get isActive(): boolean {\r\n        return this._isActive;\r\n    }\r\n    public set isActive(value: boolean) {\r\n        // Function modeled after radioButton.ts\r\n        if (this._isActive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isActive = value;\r\n\r\n        // Update the visual state based on the new value\r\n        if (this._isActive) {\r\n            this.toActiveAnimation?.();\r\n        } else {\r\n            this.toInactiveAnimation?.();\r\n        }\r\n\r\n        this._markAsDirty();\r\n\r\n        this.onIsActiveChangedObservable.notifyObservers(value);\r\n\r\n        if (this._isActive && this._host && this._group) {\r\n            // A toggle button in a group can only have 1 active element at a given time.\r\n            // If this toggle button has a group, set other toggle buttons in the group to inactive.\r\n            this._host.executeOnAllControls((control) => {\r\n                // Check for control type ToggleButton\r\n                if (control.typeName === \"ToggleButton\") {\r\n                    // Don't do anything to this toggle button\r\n                    if (control === this) {\r\n                        return;\r\n                    }\r\n\r\n                    const childToggle = <ToggleButton>control;\r\n                    // If toggle button is in same group, set isActive to false\r\n                    if (childToggle.group === this.group) {\r\n                        childToggle.isActive = false;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new ToggleButton\r\n     * @param name defines the control name\r\n     * @param group defines the toggle group this toggle belongs to\r\n     */\r\n    constructor(\r\n        public override name?: string,\r\n        group?: string\r\n    ) {\r\n        super(name);\r\n        this.group = group ?? \"\";\r\n\r\n        this.thickness = 0;\r\n        this.isPointerBlocker = true;\r\n\r\n        let alphaStore: Nullable<number> = null;\r\n\r\n        this.toActiveAnimation = () => {\r\n            this.thickness = 1;\r\n        };\r\n        this.toInactiveAnimation = () => {\r\n            this.thickness = 0;\r\n        };\r\n\r\n        this.pointerEnterActiveAnimation = () => {\r\n            alphaStore = this.alpha;\r\n            this.alpha -= 0.1;\r\n        };\r\n\r\n        this.pointerOutActiveAnimation = () => {\r\n            if (alphaStore !== null) {\r\n                this.alpha = alphaStore;\r\n            }\r\n        };\r\n\r\n        this.pointerDownActiveAnimation = () => {\r\n            this.scaleX -= 0.05;\r\n            this.scaleY -= 0.05;\r\n        };\r\n\r\n        this.pointerUpActiveAnimation = () => {\r\n            this.scaleX += 0.05;\r\n            this.scaleY += 0.05;\r\n        };\r\n\r\n        this.pointerEnterInactiveAnimation = () => {\r\n            alphaStore = this.alpha;\r\n            this.alpha -= 0.1;\r\n        };\r\n\r\n        this.pointerOutInactiveAnimation = () => {\r\n            if (alphaStore !== null) {\r\n                this.alpha = alphaStore;\r\n            }\r\n        };\r\n\r\n        this.pointerDownInactiveAnimation = () => {\r\n            this.scaleX -= 0.05;\r\n            this.scaleY -= 0.05;\r\n        };\r\n\r\n        this.pointerUpInactiveAnimation = () => {\r\n            this.scaleX += 0.05;\r\n            this.scaleY += 0.05;\r\n        };\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"ToggleButton\";\r\n    }\r\n\r\n    // While being a container, the toggle button behaves like a control.\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _processPicking(x: number, y: number, pi: PointerInfoBase, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): boolean {\r\n        if (!this._isEnabled || !this.isHitTestVisible || !this.isVisible || this.notRenderable) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.contains(x, y)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.delegatePickingToChildren) {\r\n            let contains = false;\r\n            for (let index = this._children.length - 1; index >= 0; index--) {\r\n                const child = this._children[index];\r\n                if (child.isEnabled && child.isHitTestVisible && child.isVisible && !child.notRenderable && child.contains(x, y)) {\r\n                    contains = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!contains) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        this._processObservables(type, x, y, pi, pointerId, buttonIndex, deltaX, deltaY);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerEnter(target: Control, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerEnter(target, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        if (this._isActive) {\r\n            if (this.pointerEnterActiveAnimation) {\r\n                this.pointerEnterActiveAnimation();\r\n            }\r\n        } else {\r\n            if (this.pointerEnterInactiveAnimation) {\r\n                this.pointerEnterInactiveAnimation();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerOut(target: Control, pi: PointerInfoBase, force = false): void {\r\n        if (!this.isReadOnly) {\r\n            if (this._isActive) {\r\n                if (this.pointerOutActiveAnimation) {\r\n                    this.pointerOutActiveAnimation();\r\n                }\r\n            } else {\r\n                if (this.pointerOutInactiveAnimation) {\r\n                    this.pointerOutInactiveAnimation();\r\n                }\r\n            }\r\n        }\r\n\r\n        super._onPointerOut(target, pi, force);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerDown(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, pi: PointerInfoBase): boolean {\r\n        if (!super._onPointerDown(target, coordinates, pointerId, buttonIndex, pi)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.isReadOnly) {\r\n            return true;\r\n        }\r\n\r\n        if (this._isActive) {\r\n            if (this.pointerDownActiveAnimation) {\r\n                this.pointerDownActiveAnimation();\r\n            }\r\n        } else {\r\n            if (this.pointerDownInactiveAnimation) {\r\n                this.pointerDownInactiveAnimation();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _onPointerUp(target: Control, coordinates: Vector2, pointerId: number, buttonIndex: number, notifyClick: boolean, pi: PointerInfoBase): void {\r\n        if (!this.isReadOnly) {\r\n            if (this._isActive) {\r\n                if (this.pointerUpActiveAnimation) {\r\n                    this.pointerUpActiveAnimation();\r\n                }\r\n            } else {\r\n                if (this.pointerUpInactiveAnimation) {\r\n                    this.pointerUpInactiveAnimation();\r\n                }\r\n            }\r\n        }\r\n\r\n        super._onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick, pi);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GUI.ToggleButton\", ToggleButton);\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\n\r\nimport { StackPanel } from \"./stackPanel\";\r\nimport { Button } from \"./button\";\r\nimport type { Container } from \"./container\";\r\nimport type { TextBlock } from \"./textBlock\";\r\nimport type { InputText } from \"./inputText\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport { InputTextArea } from \"./inputTextArea\";\r\nimport type { Control } from \"./control\";\r\n\r\n/**\r\n * Class used to store key control properties\r\n */\r\nexport class KeyPropertySet {\r\n    /** Width */\r\n    width?: string;\r\n    /** Height */\r\n    height?: string;\r\n    /** Left padding */\r\n    paddingLeft?: string;\r\n    /** Right padding */\r\n    paddingRight?: string;\r\n    /** Top padding */\r\n    paddingTop?: string;\r\n    /** Bottom padding */\r\n    paddingBottom?: string;\r\n    /** Foreground color */\r\n    color?: string;\r\n    /** Background color */\r\n    background?: string;\r\n}\r\n\r\ntype ConnectedInputText = {\r\n    input: InputText;\r\n    onFocusObserver: Nullable<Observer<Control>>;\r\n    onBlurObserver: Nullable<Observer<Control>>;\r\n};\r\n\r\n/**\r\n * Class used to create virtual keyboard\r\n */\r\nexport class VirtualKeyboard extends StackPanel {\r\n    /** Observable raised when a key is pressed */\r\n    public onKeyPressObservable = new Observable<string>();\r\n\r\n    /** Gets or sets default key button width */\r\n    public defaultButtonWidth = \"40px\";\r\n    /** Gets or sets default key button height */\r\n    public defaultButtonHeight = \"40px\";\r\n\r\n    /** Gets or sets default key button left padding */\r\n    public defaultButtonPaddingLeft = \"2px\";\r\n    /** Gets or sets default key button right padding */\r\n    public defaultButtonPaddingRight = \"2px\";\r\n    /** Gets or sets default key button top padding */\r\n    public defaultButtonPaddingTop = \"2px\";\r\n    /** Gets or sets default key button bottom padding */\r\n    public defaultButtonPaddingBottom = \"2px\";\r\n\r\n    /** Gets or sets default key button foreground color */\r\n    public defaultButtonColor = \"#DDD\";\r\n    /** Gets or sets default key button background color */\r\n    public defaultButtonBackground = \"#070707\";\r\n\r\n    /** Gets or sets shift button foreground color */\r\n    public shiftButtonColor = \"#7799FF\";\r\n    /** Gets or sets shift button thickness*/\r\n    public selectedShiftThickness = 1;\r\n\r\n    /** Gets shift key state */\r\n    public shiftState = 0;\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"VirtualKeyboard\";\r\n    }\r\n\r\n    private _createKey(key: string, propertySet: Nullable<KeyPropertySet>) {\r\n        const button = Button.CreateSimpleButton(key, key);\r\n\r\n        button.width = propertySet && propertySet.width ? propertySet.width : this.defaultButtonWidth;\r\n        button.height = propertySet && propertySet.height ? propertySet.height : this.defaultButtonHeight;\r\n        button.color = propertySet && propertySet.color ? propertySet.color : this.defaultButtonColor;\r\n        button.background = propertySet && propertySet.background ? propertySet.background : this.defaultButtonBackground;\r\n        button.paddingLeft = propertySet && propertySet.paddingLeft ? propertySet.paddingLeft : this.defaultButtonPaddingLeft;\r\n        button.paddingRight = propertySet && propertySet.paddingRight ? propertySet.paddingRight : this.defaultButtonPaddingRight;\r\n        button.paddingTop = propertySet && propertySet.paddingTop ? propertySet.paddingTop : this.defaultButtonPaddingTop;\r\n        button.paddingBottom = propertySet && propertySet.paddingBottom ? propertySet.paddingBottom : this.defaultButtonPaddingBottom;\r\n\r\n        button.thickness = 0;\r\n        button.isFocusInvisible = true;\r\n\r\n        button.shadowColor = this.shadowColor;\r\n        button.shadowBlur = this.shadowBlur;\r\n        button.shadowOffsetX = this.shadowOffsetX;\r\n        button.shadowOffsetY = this.shadowOffsetY;\r\n\r\n        button.onPointerUpObservable.add(() => {\r\n            this.onKeyPressObservable.notifyObservers(key);\r\n        });\r\n\r\n        return button;\r\n    }\r\n\r\n    /**\r\n     * Adds a new row of keys\r\n     * @param keys defines the list of keys to add\r\n     * @param propertySets defines the associated property sets\r\n     */\r\n    public addKeysRow(keys: Array<string>, propertySets?: Array<KeyPropertySet>): void {\r\n        const panel = new StackPanel();\r\n        panel.isVertical = false;\r\n        panel.isFocusInvisible = true;\r\n\r\n        let maxKey: Nullable<Button> = null;\r\n        for (let i = 0; i < keys.length; i++) {\r\n            let properties = null;\r\n\r\n            if (propertySets && propertySets.length === keys.length) {\r\n                properties = propertySets[i];\r\n            }\r\n\r\n            const key = this._createKey(keys[i], properties);\r\n            if (!maxKey || key.heightInPixels > maxKey.heightInPixels) {\r\n                maxKey = key;\r\n            }\r\n\r\n            panel.addControl(key);\r\n        }\r\n\r\n        panel.height = maxKey ? maxKey.height : this.defaultButtonHeight;\r\n\r\n        this.addControl(panel);\r\n    }\r\n\r\n    /**\r\n     * Set the shift key to a specific state\r\n     * @param shiftState defines the new shift state\r\n     */\r\n    public applyShiftState(shiftState: number): void {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < this.children.length; i++) {\r\n            const row = this.children[i];\r\n            if (!row || !(<Container>row).children) {\r\n                continue;\r\n            }\r\n\r\n            const rowContainer = <Container>row;\r\n            for (let j = 0; j < rowContainer.children.length; j++) {\r\n                const button = rowContainer.children[j] as Button;\r\n\r\n                if (!button || !button.children[0]) {\r\n                    continue;\r\n                }\r\n\r\n                const button_tblock = button.children[0] as TextBlock;\r\n\r\n                if (button_tblock.text === \"\\u21E7\") {\r\n                    button.color = shiftState ? this.shiftButtonColor : this.defaultButtonColor;\r\n                    button.thickness = shiftState > 1 ? this.selectedShiftThickness : 0;\r\n                }\r\n\r\n                button_tblock.text = shiftState > 0 ? button_tblock.text.toUpperCase() : button_tblock.text.toLowerCase();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _currentlyConnectedInputText: Nullable<InputText | InputTextArea> = null;\r\n    private _connectedInputTexts: ConnectedInputText[] = [];\r\n    private _onKeyPressObserver: Nullable<Observer<string>> = null;\r\n\r\n    /** Gets the input text control currently attached to the keyboard */\r\n    public get connectedInputText(): Nullable<InputText | InputTextArea> {\r\n        return this._currentlyConnectedInputText;\r\n    }\r\n\r\n    /**\r\n     * Connects the keyboard with an input text control\r\n     *\r\n     * @param input defines the target control\r\n     */\r\n    public connect(input: InputText): void {\r\n        const inputTextAlreadyConnected = this._connectedInputTexts.some((a) => a.input === input);\r\n        if (inputTextAlreadyConnected) {\r\n            return;\r\n        }\r\n\r\n        if (this._onKeyPressObserver === null) {\r\n            this._onKeyPressObserver = this.onKeyPressObservable.add((key) => {\r\n                if (!this._currentlyConnectedInputText) {\r\n                    return;\r\n                }\r\n\r\n                this._currentlyConnectedInputText._host.focusedControl = this._currentlyConnectedInputText;\r\n\r\n                switch (key) {\r\n                    case \"\\u21E7\":\r\n                        this.shiftState++;\r\n                        if (this.shiftState > 2) {\r\n                            this.shiftState = 0;\r\n                        }\r\n                        this.applyShiftState(this.shiftState);\r\n                        return;\r\n                    case \"\\u2190\":\r\n                        if (this._currentlyConnectedInputText instanceof InputTextArea) {\r\n                            this._currentlyConnectedInputText.alternativeProcessKey(\"Backspace\");\r\n                        } else {\r\n                            this._currentlyConnectedInputText.processKey(8);\r\n                        }\r\n                        return;\r\n                    case \"\\u21B5\":\r\n                        if (this._currentlyConnectedInputText instanceof InputTextArea) {\r\n                            this._currentlyConnectedInputText.alternativeProcessKey(\"Enter\");\r\n                        } else {\r\n                            this._currentlyConnectedInputText.processKey(13);\r\n                        }\r\n                        return;\r\n                }\r\n                if (this._currentlyConnectedInputText instanceof InputTextArea) {\r\n                    this._currentlyConnectedInputText.alternativeProcessKey(\"\", this.shiftState ? key.toUpperCase() : key);\r\n                } else {\r\n                    this._currentlyConnectedInputText.processKey(-1, this.shiftState ? key.toUpperCase() : key);\r\n                }\r\n\r\n                if (this.shiftState === 1) {\r\n                    this.shiftState = 0;\r\n                    this.applyShiftState(this.shiftState);\r\n                }\r\n            });\r\n        }\r\n\r\n        this.isVisible = false;\r\n        this._currentlyConnectedInputText = input;\r\n        input._connectedVirtualKeyboard = this;\r\n\r\n        // Events hooking\r\n        const onFocusObserver: Nullable<Observer<Control>> = input.onFocusObservable.add(() => {\r\n            this._currentlyConnectedInputText = input;\r\n            input._connectedVirtualKeyboard = this;\r\n            this.isVisible = true;\r\n        });\r\n\r\n        const onBlurObserver: Nullable<Observer<Control>> = input.onBlurObservable.add(() => {\r\n            input._connectedVirtualKeyboard = null;\r\n            this._currentlyConnectedInputText = null;\r\n            this.isVisible = false;\r\n        });\r\n\r\n        this._connectedInputTexts.push({\r\n            input,\r\n            onBlurObserver,\r\n            onFocusObserver,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disconnects the keyboard from connected InputText controls\r\n     *\r\n     * @param input optionally defines a target control, otherwise all are disconnected\r\n     */\r\n    public disconnect(input?: InputText): void {\r\n        if (input) {\r\n            // .find not available on IE\r\n            const filtered = this._connectedInputTexts.filter((a) => a.input === input);\r\n            if (filtered.length === 1) {\r\n                this._removeConnectedInputObservables(filtered[0]);\r\n\r\n                this._connectedInputTexts = this._connectedInputTexts.filter((a) => a.input !== input);\r\n                if (this._currentlyConnectedInputText === input) {\r\n                    this._currentlyConnectedInputText = null;\r\n                }\r\n            }\r\n        } else {\r\n            this._connectedInputTexts.forEach((connectedInputText: ConnectedInputText) => {\r\n                this._removeConnectedInputObservables(connectedInputText);\r\n            });\r\n            this._connectedInputTexts.length = 0;\r\n        }\r\n\r\n        if (this._connectedInputTexts.length === 0) {\r\n            this._currentlyConnectedInputText = null;\r\n            this.onKeyPressObservable.remove(this._onKeyPressObserver);\r\n            this._onKeyPressObserver = null;\r\n        }\r\n    }\r\n\r\n    private _removeConnectedInputObservables(connectedInputText: ConnectedInputText): void {\r\n        connectedInputText.input._connectedVirtualKeyboard = null;\r\n        connectedInputText.input.onFocusObservable.remove(connectedInputText.onFocusObserver);\r\n        connectedInputText.input.onBlurObservable.remove(connectedInputText.onBlurObserver);\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        this.disconnect();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new keyboard using a default layout\r\n     *\r\n     * @param name defines control name\r\n     * @returns a new VirtualKeyboard\r\n     */\r\n    public static CreateDefaultLayout(name?: string): VirtualKeyboard {\r\n        const returnValue = new VirtualKeyboard(name);\r\n\r\n        returnValue.addKeysRow([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\", \"\\u2190\"]);\r\n        returnValue.addKeysRow([\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\"]);\r\n        returnValue.addKeysRow([\"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \";\", \"'\", \"\\u21B5\"]);\r\n        returnValue.addKeysRow([\"\\u21E7\", \"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\", \",\", \".\", \"/\"]);\r\n        returnValue.addKeysRow([\" \"], [{ width: \"200px\" }]);\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture) {\r\n        super._parseFromContent(serializedObject, host);\r\n        for (const row of this.children) {\r\n            if (row.getClassName() === \"StackPanel\") {\r\n                const stackPanel = row as StackPanel;\r\n                for (const key of stackPanel.children) {\r\n                    if (key.getClassName() === \"Button\" && key.name) {\r\n                        key.onPointerUpObservable.add(() => {\r\n                            this.onKeyPressObservable.notifyObservers(key.name as string);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GUI.VirtualKeyboard\", VirtualKeyboard);\r\n", "import { Control } from \"./control\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/** Class used to render a grid  */\r\nexport class DisplayGrid extends Control {\r\n    private _cellWidth = 20;\r\n    private _cellHeight = 20;\r\n\r\n    private _minorLineTickness = 1;\r\n    private _minorLineColor = \"DarkGray\";\r\n\r\n    private _majorLineTickness = 2;\r\n    private _majorLineColor = \"White\";\r\n\r\n    private _majorLineFrequency = 5;\r\n\r\n    private _background = \"Black\";\r\n\r\n    private _displayMajorLines = true;\r\n    private _displayMinorLines = true;\r\n\r\n    /** Gets or sets a boolean indicating if minor lines must be rendered (true by default)) */\r\n    @serialize()\r\n    public get displayMinorLines(): boolean {\r\n        return this._displayMinorLines;\r\n    }\r\n\r\n    public set displayMinorLines(value: boolean) {\r\n        if (this._displayMinorLines === value) {\r\n            return;\r\n        }\r\n\r\n        this._displayMinorLines = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if major lines must be rendered (true by default)) */\r\n    @serialize()\r\n    public get displayMajorLines(): boolean {\r\n        return this._displayMajorLines;\r\n    }\r\n\r\n    public set displayMajorLines(value: boolean) {\r\n        if (this._displayMajorLines === value) {\r\n            return;\r\n        }\r\n\r\n        this._displayMajorLines = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets background color (Black by default) */\r\n    @serialize()\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n\r\n        this._background = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the width of each cell (20 by default) */\r\n    @serialize()\r\n    public get cellWidth(): number {\r\n        return this._cellWidth;\r\n    }\r\n\r\n    public set cellWidth(value: number) {\r\n        this._cellWidth = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the height of each cell (20 by default) */\r\n    @serialize()\r\n    public get cellHeight(): number {\r\n        return this._cellHeight;\r\n    }\r\n\r\n    public set cellHeight(value: number) {\r\n        this._cellHeight = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the tickness of minor lines (1 by default) */\r\n    @serialize()\r\n    public get minorLineTickness(): number {\r\n        return this._minorLineTickness;\r\n    }\r\n\r\n    public set minorLineTickness(value: number) {\r\n        this._minorLineTickness = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the color of minor lines (DarkGray by default) */\r\n    @serialize()\r\n    public get minorLineColor(): string {\r\n        return this._minorLineColor;\r\n    }\r\n\r\n    public set minorLineColor(value: string) {\r\n        this._minorLineColor = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the tickness of major lines (2 by default) */\r\n    @serialize()\r\n    public get majorLineTickness(): number {\r\n        return this._majorLineTickness;\r\n    }\r\n\r\n    public set majorLineTickness(value: number) {\r\n        this._majorLineTickness = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the color of major lines (White by default) */\r\n    @serialize()\r\n    public get majorLineColor(): string {\r\n        return this._majorLineColor;\r\n    }\r\n\r\n    public set majorLineColor(value: string) {\r\n        this._majorLineColor = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /** Gets or sets the frequency of major lines (default is 1 every 5 minor lines)*/\r\n    @serialize()\r\n    public get majorLineFrequency(): number {\r\n        return this._majorLineFrequency;\r\n    }\r\n\r\n    public set majorLineFrequency(value: number) {\r\n        this._majorLineFrequency = value;\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new GridDisplayRectangle\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        if (this._isEnabled) {\r\n            if (this._background) {\r\n                context.fillStyle = this._background;\r\n                context.fillRect(this._currentMeasure.left, this._currentMeasure.top, this._currentMeasure.width, this._currentMeasure.height);\r\n            }\r\n\r\n            const cellCountX = this._currentMeasure.width / this._cellWidth;\r\n            const cellCountY = this._currentMeasure.height / this._cellHeight;\r\n\r\n            // Minor lines\r\n            const left = this._currentMeasure.left + this._currentMeasure.width / 2;\r\n            const top = this._currentMeasure.top + this._currentMeasure.height / 2;\r\n\r\n            if (this._displayMinorLines) {\r\n                context.strokeStyle = this._minorLineColor;\r\n                context.lineWidth = this._minorLineTickness;\r\n\r\n                for (let x = -cellCountX / 2 + 1; x < cellCountX / 2; x++) {\r\n                    const cellX = left + x * this.cellWidth;\r\n\r\n                    context.beginPath();\r\n                    context.moveTo(cellX, this._currentMeasure.top);\r\n                    context.lineTo(cellX, this._currentMeasure.top + this._currentMeasure.height);\r\n\r\n                    context.stroke();\r\n                }\r\n\r\n                for (let y = -cellCountY / 2 + 1; y < cellCountY / 2; y++) {\r\n                    const cellY = top + y * this.cellHeight;\r\n\r\n                    context.beginPath();\r\n                    context.moveTo(this._currentMeasure.left, cellY);\r\n                    context.lineTo(this._currentMeasure.left + this._currentMeasure.width, cellY);\r\n                    context.stroke();\r\n                }\r\n            }\r\n\r\n            // Major lines\r\n            if (this._displayMajorLines) {\r\n                context.strokeStyle = this._majorLineColor;\r\n                context.lineWidth = this._majorLineTickness;\r\n\r\n                for (let x = -cellCountX / 2 + this._majorLineFrequency; x < cellCountX / 2; x += this._majorLineFrequency) {\r\n                    const cellX = left + x * this.cellWidth;\r\n\r\n                    context.beginPath();\r\n                    context.moveTo(cellX, this._currentMeasure.top);\r\n                    context.lineTo(cellX, this._currentMeasure.top + this._currentMeasure.height);\r\n                    context.stroke();\r\n                }\r\n\r\n                for (let y = -cellCountY / 2 + this._majorLineFrequency; y < cellCountY / 2; y += this._majorLineFrequency) {\r\n                    const cellY = top + y * this.cellHeight;\r\n                    context.moveTo(this._currentMeasure.left, cellY);\r\n                    context.lineTo(this._currentMeasure.left + this._currentMeasure.width, cellY);\r\n                    context.closePath();\r\n                    context.stroke();\r\n                }\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"DisplayGrid\";\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.DisplayGrid\", DisplayGrid);\r\n", "import { BaseSlider } from \"./baseSlider\";\r\nimport { Measure } from \"../../measure\";\r\nimport { Image } from \"../image\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport type { AdvancedDynamicTexture } from \"../../advancedDynamicTexture\";\r\n\r\n/**\r\n * Class used to create slider controls based on images\r\n */\r\nexport class ImageBasedSlider extends BaseSlider {\r\n    private _backgroundImage: Image;\r\n    private _thumbImage: Image;\r\n    private _valueBarImage: Image;\r\n    private _tempMeasure = new Measure(0, 0, 0, 0);\r\n\r\n    @serialize()\r\n    public override get displayThumb(): boolean {\r\n        return this._displayThumb && this.thumbImage != null;\r\n    }\r\n\r\n    public override set displayThumb(value: boolean) {\r\n        if (this._displayThumb === value) {\r\n            return;\r\n        }\r\n\r\n        this._displayThumb = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the image used to render the background\r\n     */\r\n    public get backgroundImage(): Image {\r\n        return this._backgroundImage;\r\n    }\r\n\r\n    public set backgroundImage(value: Image) {\r\n        if (this._backgroundImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._backgroundImage = value;\r\n\r\n        if (value && !value.isLoaded) {\r\n            value.onImageLoadedObservable.addOnce(() => this._markAsDirty());\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the image used to render the value bar\r\n     */\r\n    public get valueBarImage(): Image {\r\n        return this._valueBarImage;\r\n    }\r\n\r\n    public set valueBarImage(value: Image) {\r\n        if (this._valueBarImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._valueBarImage = value;\r\n\r\n        if (value && !value.isLoaded) {\r\n            value.onImageLoadedObservable.addOnce(() => this._markAsDirty());\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the image used to render the thumb\r\n     */\r\n    public get thumbImage(): Image {\r\n        return this._thumbImage;\r\n    }\r\n\r\n    public set thumbImage(value: Image) {\r\n        if (this._thumbImage === value) {\r\n            return;\r\n        }\r\n\r\n        this._thumbImage = value;\r\n\r\n        if (value && !value.isLoaded) {\r\n            value.onImageLoadedObservable.addOnce(() => this._markAsDirty());\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new ImageBasedSlider\r\n     * @param name defines the control name\r\n     */\r\n    constructor(public override name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"ImageBasedSlider\";\r\n    }\r\n\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        this._prepareRenderingData(\"rectangle\");\r\n        const thumbPosition = this._getThumbPosition();\r\n        const left = this._renderLeft;\r\n        const top = this._renderTop;\r\n        const width = this._renderWidth;\r\n        const height = this._renderHeight;\r\n\r\n        // Background\r\n        if (this._backgroundImage) {\r\n            this._tempMeasure.copyFromFloats(left, top, width, height);\r\n            if (this.isThumbClamped && this.displayThumb) {\r\n                if (this.isVertical) {\r\n                    this._tempMeasure.height += this._effectiveThumbThickness;\r\n                } else {\r\n                    this._tempMeasure.width += this._effectiveThumbThickness;\r\n                }\r\n            }\r\n            this._backgroundImage._currentMeasure.copyFrom(this._tempMeasure);\r\n            this._backgroundImage._draw(context);\r\n        }\r\n\r\n        // Bar\r\n        if (this._valueBarImage) {\r\n            if (this.isVertical) {\r\n                if (this.isThumbClamped && this.displayThumb) {\r\n                    this._tempMeasure.copyFromFloats(left, top + thumbPosition, width, height - thumbPosition + this._effectiveThumbThickness);\r\n                } else {\r\n                    this._tempMeasure.copyFromFloats(left, top + thumbPosition, width, height - thumbPosition);\r\n                }\r\n            } else {\r\n                if (this.isThumbClamped && this.displayThumb) {\r\n                    this._tempMeasure.copyFromFloats(left, top, thumbPosition + this._effectiveThumbThickness / 2, height);\r\n                } else {\r\n                    this._tempMeasure.copyFromFloats(left, top, thumbPosition, height);\r\n                }\r\n            }\r\n            this._valueBarImage._currentMeasure.copyFrom(this._tempMeasure);\r\n            this._valueBarImage._draw(context);\r\n        }\r\n\r\n        // Thumb\r\n        if (this.displayThumb) {\r\n            if (this.isVertical) {\r\n                this._tempMeasure.copyFromFloats(\r\n                    left - this._effectiveBarOffset,\r\n                    this._currentMeasure.top + thumbPosition,\r\n                    this._currentMeasure.width,\r\n                    this._effectiveThumbThickness\r\n                );\r\n            } else {\r\n                this._tempMeasure.copyFromFloats(this._currentMeasure.left + thumbPosition, this._currentMeasure.top, this._effectiveThumbThickness, this._currentMeasure.height);\r\n            }\r\n\r\n            this._thumbImage._currentMeasure.copyFrom(this._tempMeasure);\r\n            this._thumbImage._draw(context);\r\n        }\r\n\r\n        context.restore();\r\n    }\r\n\r\n    /**\r\n     * Serializes the current control\r\n     * @param serializationObject defined the JSON serialized object\r\n     */\r\n    public override serialize(serializationObject: any) {\r\n        super.serialize(serializationObject);\r\n        const backgroundImage = {};\r\n        const thumbImage = {};\r\n        const valueBarImage = {};\r\n        this.backgroundImage.serialize(backgroundImage);\r\n        this.thumbImage.serialize(thumbImage);\r\n        this.valueBarImage.serialize(valueBarImage);\r\n        serializationObject.backgroundImage = backgroundImage;\r\n        serializationObject.thumbImage = thumbImage;\r\n        serializationObject.valueBarImage = valueBarImage;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _parseFromContent(serializedObject: any, host: AdvancedDynamicTexture) {\r\n        super._parseFromContent(serializedObject, host);\r\n        this.backgroundImage = Image.Parse(serializedObject.backgroundImage, host) as Image;\r\n        this.thumbImage = Image.Parse(serializedObject.thumbImage, host) as Image;\r\n        this.valueBarImage = Image.Parse(serializedObject.valueBarImage, host) as Image;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.ImageBasedSlider\", ImageBasedSlider);\r\n", "import { Control } from \"./control\";\r\nimport { StackPanel } from \"./stackPanel\";\r\nimport { TextBlock } from \"./textBlock\";\r\n\r\n/**\r\n * Forcing an export so that this code will execute\r\n * @internal\r\n */\r\nconst name = \"Statics\";\r\n\r\nexport { name };\r\n\r\n/**\r\n * Creates a stack panel that can be used to render headers\r\n * @param control defines the control to associate with the header\r\n * @param text defines the text of the header\r\n * @param size defines the size of the header\r\n * @param options defines options used to configure the header\r\n * @param options.isHorizontal\r\n * @param options.controlFirst\r\n * @returns a new StackPanel\r\n */\r\nControl.AddHeader = function (control: Control, text: string, size: string | number, options: { isHorizontal: boolean; controlFirst: boolean }): StackPanel {\r\n    const panel = new StackPanel(\"panel\");\r\n    const isHorizontal = options ? options.isHorizontal : true;\r\n    const controlFirst = options ? options.controlFirst : true;\r\n\r\n    panel.isVertical = !isHorizontal;\r\n\r\n    const header = new TextBlock(\"header\");\r\n    header.text = text;\r\n    header.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n    if (isHorizontal) {\r\n        header.width = size;\r\n    } else {\r\n        header.height = size;\r\n    }\r\n\r\n    if (controlFirst) {\r\n        panel.addControl(control);\r\n        panel.addControl(header);\r\n        header.paddingLeft = \"5px\";\r\n    } else {\r\n        panel.addControl(header);\r\n        panel.addControl(control);\r\n        header.paddingRight = \"5px\";\r\n    }\r\n\r\n    header.shadowBlur = control.shadowBlur;\r\n    header.shadowColor = control.shadowColor;\r\n    header.shadowOffsetX = control.shadowOffsetX;\r\n    header.shadowOffsetY = control.shadowOffsetY;\r\n\r\n    return panel;\r\n};\r\n", "/*\r\n * Base Gradient class. Should not be used directly.\r\n */\r\n\r\nimport type { ICanvasGradient, ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\n\r\n/**\r\n * Type that represents a single stop on the gradient.\r\n */\r\nexport type GradientColorStop = {\r\n    /**\r\n     * Offset from the start where the color will be applied.\r\n     */\r\n    offset: number;\r\n    /**\r\n     * Color to be applied.\r\n     */\r\n    color: string;\r\n};\r\n\r\n/**\r\n * Class that serves as a base for all the gradients created from context.\r\n */\r\nexport abstract class BaseGradient {\r\n    private _colorStops: GradientColorStop[] = [];\r\n\r\n    private _canvasGradient: CanvasGradient;\r\n    private _context: ICanvasRenderingContext;\r\n    private _gradientDirty: boolean = true;\r\n\r\n    /**\r\n     * Overwritten by child classes to create the canvas gradient.\r\n     * @param context\r\n     */\r\n    protected abstract _createCanvasGradient(context: ICanvasRenderingContext): ICanvasGradient;\r\n\r\n    private _addColorStopsToCanvasGradient() {\r\n        for (const stop of this._colorStops) {\r\n            this._canvasGradient.addColorStop(stop.offset, stop.color);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If there are any changes or the context changed, regenerate the canvas gradient object. Else,\r\n     * reuse the existing gradient.\r\n     * @param context the context to create the gradient from\r\n     * @returns the canvas gradient\r\n     */\r\n    public getCanvasGradient(context: ICanvasRenderingContext) {\r\n        if (this._gradientDirty || this._context !== context) {\r\n            this._context = context;\r\n            this._canvasGradient = this._createCanvasGradient(context);\r\n            this._addColorStopsToCanvasGradient();\r\n            this._gradientDirty = false;\r\n        }\r\n        return this._canvasGradient;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color stop to the gradient.\r\n     * @param offset the offset of the stop on the gradient. Should be between 0 and 1\r\n     * @param color the color of the stop\r\n     */\r\n    public addColorStop(offset: number, color: string) {\r\n        this._colorStops.push({ offset, color });\r\n        this._gradientDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Removes an existing color stop with the specified offset from the gradient\r\n     * @param offset the offset of the stop to be removed\r\n     */\r\n    public removeColorStop(offset: number) {\r\n        this._colorStops = this._colorStops.filter((colorStop) => colorStop.offset !== offset);\r\n        this._gradientDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Removes all color stops from the gradient\r\n     */\r\n    public clearColorStops() {\r\n        this._colorStops = [];\r\n        this._gradientDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Color stops of the gradient\r\n     */\r\n    public get colorStops() {\r\n        return this._colorStops;\r\n    }\r\n\r\n    /**\r\n     * @returns Type of the gradient\r\n     */\r\n    public getClassName() {\r\n        return \"BaseGradient\";\r\n    }\r\n\r\n    /**\r\n     * Serialize into a json object\r\n     * @param serializationObject object to serialize into\r\n     */\r\n    public serialize(serializationObject: any) {\r\n        serializationObject.colorStops = this._colorStops;\r\n        serializationObject.className = this.getClassName();\r\n    }\r\n\r\n    /**\r\n     * Parse from json object\r\n     * @param serializationObject object to parse from\r\n     */\r\n    public parse(serializationObject: any) {\r\n        this._colorStops = serializationObject.colorStops;\r\n    }\r\n}\r\n", "import type { ICanvasGradient, ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { BaseGradient } from \"./BaseGradient\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\n/**\r\n * Gradient along a line that connects two coordinates.\r\n * These coordinates are relative to the canvas' space, not to any control's space.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createLinearGradient\r\n */\r\nexport class LinearGradient extends BaseGradient {\r\n    private _x0: number;\r\n    private _y0: number;\r\n    private _x1: number;\r\n    private _y1: number;\r\n\r\n    /**\r\n     * Creates a new linear gradient\r\n     * @param x0\r\n     * @param y0\r\n     * @param x1\r\n     * @param y1\r\n     */\r\n    constructor(x0?: number, y0?: number, x1?: number, y1?: number) {\r\n        super();\r\n        this._x0 = x0 ?? 0;\r\n        this._y0 = y0 ?? 0;\r\n        this._x1 = x1 ?? 0;\r\n        this._y1 = y1 ?? 0;\r\n    }\r\n\r\n    protected _createCanvasGradient(context: ICanvasRenderingContext): ICanvasGradient {\r\n        return context.createLinearGradient(this._x0, this._y0, this._x1, this._y1);\r\n    }\r\n\r\n    /** X axis coordinate of the starting point in the line */\r\n    public get x0() {\r\n        return this._x0;\r\n    }\r\n\r\n    /** X axis coordinate of the ending point in the line */\r\n    public get x1() {\r\n        return this._x1;\r\n    }\r\n\r\n    /** Y axis coordinate of the starting point in the line */\r\n    public get y0() {\r\n        return this._y0;\r\n    }\r\n\r\n    /** Y axis coordinate of the ending point in the line */\r\n    public get y1() {\r\n        return this._y1;\r\n    }\r\n\r\n    /**\r\n     * Class name of the gradient\r\n     * @returns the class name of the gradient\r\n     */\r\n    public override getClassName(): string {\r\n        return \"LinearGradient\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this gradient\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.x0 = this._x0;\r\n        serializationObject.y0 = this._y0;\r\n        serializationObject.x1 = this._x1;\r\n        serializationObject.y1 = this._y1;\r\n    }\r\n\r\n    /**\r\n     * Parses a gradient from a serialization object\r\n     * @param serializationObject the object to parse from\r\n     */\r\n    public override parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this._x0 = serializationObject.x0;\r\n        this._y0 = serializationObject.y0;\r\n        this._x1 = serializationObject.x1;\r\n        this._y1 = serializationObject.y1;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.LinearGradient\", LinearGradient);\r\n", "import type { ICanvasGradient, ICanvasRenderingContext } from \"core/Engines/ICanvas\";\r\nimport { BaseGradient } from \"./BaseGradient\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\n/**\r\n * Gradient formed from two circles with their own centers and radius.\r\n * The coordinates of the circles centers are relative to the canvas' space, not to any control's space.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createRadialGradient\r\n */\r\nexport class RadialGradient extends BaseGradient {\r\n    private _x0: number;\r\n    private _y0: number;\r\n    private _r0: number;\r\n    private _x1: number;\r\n    private _y1: number;\r\n    private _r1: number;\r\n\r\n    /**\r\n     * Creates a new radial gradient\r\n     * @param x0 x coordinate of the first circle's center\r\n     * @param y0 y coordinate of the first circle's center\r\n     * @param r0 radius of the first circle\r\n     * @param x1 x coordinate of the second circle's center\r\n     * @param y1 y coordinate of the second circle's center\r\n     * @param r1 radius of the second circle\r\n     */\r\n    constructor(x0?: number, y0?: number, r0?: number, x1?: number, y1?: number, r1?: number) {\r\n        super();\r\n        this._x0 = x0 ?? 0;\r\n        this._y0 = y0 ?? 0;\r\n        this._r0 = r0 ?? 0;\r\n        this._x1 = x1 ?? 0;\r\n        this._y1 = y1 ?? 0;\r\n        this._r1 = r1 ?? 0;\r\n    }\r\n\r\n    protected _createCanvasGradient(context: ICanvasRenderingContext): ICanvasGradient {\r\n        return context.createRadialGradient(this._x0, this._y0, this._r0, this._x1, this._y1, this._r1);\r\n    }\r\n\r\n    /** x coordinate of the first circle's center */\r\n    public get x0() {\r\n        return this._x0;\r\n    }\r\n\r\n    /** x coordinate of the second circle's center */\r\n    public get x1() {\r\n        return this._x1;\r\n    }\r\n\r\n    /** y coordinate of the first circle's center */\r\n    public get y0() {\r\n        return this._y0;\r\n    }\r\n\r\n    /** y coordinate of the second circle's center */\r\n    public get y1() {\r\n        return this._y1;\r\n    }\r\n\r\n    /** radius of the first circle */\r\n    public get r0() {\r\n        return this._r0;\r\n    }\r\n\r\n    /** radius of the second circle */\r\n    public get r1() {\r\n        return this._r1;\r\n    }\r\n\r\n    /**\r\n     * Class name of the gradient\r\n     * @returns the class name of the gradient\r\n     */\r\n    public override getClassName() {\r\n        return \"RadialGradient\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this gradient\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.x0 = this._x0;\r\n        serializationObject.y0 = this._y0;\r\n        serializationObject.r0 = this._r0;\r\n        serializationObject.x1 = this._x1;\r\n        serializationObject.y1 = this._y1;\r\n        serializationObject.r1 = this._r1;\r\n    }\r\n\r\n    /**\r\n     * Parses a gradient from a serialization object\r\n     * @param serializationObject the object to parse from\r\n     */\r\n    public override parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this._x0 = serializationObject.x0;\r\n        this._y0 = serializationObject.y0;\r\n        this._r0 = serializationObject.r0;\r\n        this._x1 = serializationObject.x1;\r\n        this._y1 = serializationObject.y1;\r\n        this._r1 = serializationObject.r1;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.RadialGradient\", RadialGradient);\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { IDisposable } from \"core/scene\";\r\nimport type { AdvancedDynamicTexture } from \"./advancedDynamicTexture\";\r\nimport { ValueAndUnit } from \"./valueAndUnit\";\r\n\r\n/**\r\n * Define a style used by control to automatically setup properties based on a template.\r\n * Only support font related properties so far\r\n */\r\nexport class Style implements IDisposable {\r\n    private _fontFamily = \"Arial\";\r\n    private _fontStyle = \"\";\r\n    private _fontWeight = \"\";\r\n    /** @internal */\r\n    public _host: AdvancedDynamicTexture;\r\n    /** @internal */\r\n    public _fontSize = new ValueAndUnit(18, ValueAndUnit.UNITMODE_PIXEL, false);\r\n\r\n    /**\r\n     * Observable raised when the style values are changed\r\n     */\r\n    public onChangedObservable = new Observable<Style>();\r\n\r\n    /**\r\n     * Creates a new style object\r\n     * @param host defines the AdvancedDynamicTexture which hosts this style\r\n     */\r\n    public constructor(host: AdvancedDynamicTexture) {\r\n        this._host = host;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the font size\r\n     */\r\n    public get fontSize(): string | number {\r\n        return this._fontSize.toString(this._host);\r\n    }\r\n\r\n    public set fontSize(value: string | number) {\r\n        if (this._fontSize.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._fontSize.fromString(value)) {\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the font family\r\n     */\r\n    public get fontFamily(): string {\r\n        return this._fontFamily;\r\n    }\r\n\r\n    public set fontFamily(value: string) {\r\n        if (this._fontFamily === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontFamily = value;\r\n        this.onChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the font style\r\n     */\r\n    public get fontStyle(): string {\r\n        return this._fontStyle;\r\n    }\r\n\r\n    public set fontStyle(value: string) {\r\n        if (this._fontStyle === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontStyle = value;\r\n        this.onChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /** Gets or sets font weight */\r\n    public get fontWeight(): string {\r\n        return this._fontWeight;\r\n    }\r\n\r\n    public set fontWeight(value: string) {\r\n        if (this._fontWeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontWeight = value;\r\n        this.onChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /** Dispose all associated resources */\r\n    public dispose() {\r\n        this.onChangedObservable.clear();\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector2, Vector3, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { PointerInfoPre, PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport { ClipboardEventTypes, ClipboardInfo } from \"core/Events/clipboardEvents\";\r\nimport type { KeyboardInfoPre } from \"core/Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"core/Events/keyboardEvents\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IDynamicTextureOptions } from \"core/Materials/Textures/dynamicTexture\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Layer } from \"core/Layers/layer\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Container } from \"./controls/container\";\r\nimport { Control } from \"./controls/control\";\r\nimport { Style } from \"./style\";\r\nimport { Measure } from \"./measure\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Viewport } from \"core/Maths/math.viewport\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IPointerEvent, IWheelEvent } from \"core/Events/deviceInputEvents\";\r\nimport { RandomGUID } from \"core/Misc/guid\";\r\nimport { GetClass } from \"core/Misc/typeStore\";\r\nimport { DecodeBase64ToBinary } from \"core/Misc/stringTools\";\r\n\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Interface used to define options to create an AdvancedDynamicTexture\r\n */\r\nexport interface IAdvancedDynamicTextureOptions extends IDynamicTextureOptions {\r\n    /**\r\n     * Indicates whether the ADT will be used autonomously. In this mode:\r\n     * - _checkUpdate() is not called\r\n     * - the layer is not rendered (so, the ADT is not visible)\r\n     * It's up to the user to perform the required calls manually to update the ADT.\r\n     */\r\n    useStandalone?: boolean;\r\n}\r\n\r\n/**\r\n * Class used to create texture to support 2D GUI elements\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui\r\n */\r\nexport class AdvancedDynamicTexture extends DynamicTexture {\r\n    /** Define the url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Indicates if some optimizations can be performed in GUI GPU management (the downside is additional memory/GPU texture memory used) */\r\n    public static AllowGPUOptimizations = true;\r\n\r\n    /** Indicates whether the ADT is used autonomously */\r\n    public readonly useStandalone: boolean = false;\r\n\r\n    /** Snippet ID if the content was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /** Observable that fires when the GUI is ready */\r\n    public onGuiReadyObservable = new Observable<AdvancedDynamicTexture>();\r\n\r\n    private _isDirty = false;\r\n    private _renderObserver: Nullable<Observer<Camera>>;\r\n    private _resizeObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _preKeyboardObserver: Nullable<Observer<KeyboardInfoPre>>;\r\n    private _prePointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>>;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _canvasPointerOutObserver: Nullable<Observer<PointerEvent>>;\r\n    private _canvasBlurObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _controlAddedObserver: Nullable<Observer<Nullable<Control>>>;\r\n    private _controlRemovedObserver: Nullable<Observer<Nullable<Control>>>;\r\n    private _background: string;\r\n    /** @internal */\r\n    public _rootContainer = new Container(\"root\");\r\n    /** @internal */\r\n    public _lastPickedControl: Control;\r\n    /** @internal */\r\n    public _lastControlOver: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _lastControlDown: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _capturingControl: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _shouldBlockPointer: boolean;\r\n    /** @internal */\r\n    public _layerToDispose: Nullable<Layer>;\r\n    /** @internal */\r\n    public _linkedControls = new Array<Control>();\r\n    /** @internal */\r\n    public _isFullscreen = false;\r\n    private _fullscreenViewport = new Viewport(0, 0, 1, 1);\r\n    private _idealWidth = 0;\r\n    private _idealHeight = 0;\r\n    private _useSmallestIdeal: boolean = false;\r\n    private _renderAtIdealSize = false;\r\n    private _focusedControl: Nullable<Control>;\r\n    private _blockNextFocusCheck = false;\r\n    private _renderScale = 1;\r\n    private _rootElement: Nullable<HTMLElement>;\r\n    private _cursorChanged = false;\r\n    private _defaultMousePointerId = 0;\r\n    private _rootChildrenHaveChanged: boolean = false;\r\n    private _adjustToEngineHardwareScalingLevel = false;\r\n\r\n    /** @internal */\r\n    public _capturedPointerIds = new Set<number>();\r\n\r\n    /** @internal */\r\n    public _numLayoutCalls = 0;\r\n    /** Gets the number of layout calls made the last time the ADT has been rendered */\r\n    public get numLayoutCalls(): number {\r\n        return this._numLayoutCalls;\r\n    }\r\n\r\n    /** @internal */\r\n    public _numRenderCalls = 0;\r\n    /** Gets the number of render calls made the last time the ADT has been rendered */\r\n    public get numRenderCalls(): number {\r\n        return this._numRenderCalls;\r\n    }\r\n\r\n    /**\r\n     * Define type to string to ensure compatibility across browsers\r\n     * Safari doesn't support DataTransfer constructor\r\n     */\r\n    private _clipboardData: string = \"\";\r\n    /**\r\n     * Observable event triggered each time an clipboard event is received from the rendering canvas\r\n     */\r\n    public onClipboardObservable = new Observable<ClipboardInfo>();\r\n    /**\r\n     * Observable event triggered each time a pointer down is intercepted by a control\r\n     */\r\n    public onControlPickedObservable = new Observable<Control>();\r\n    /**\r\n     * Observable event triggered before layout is evaluated\r\n     */\r\n    public onBeginLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the layout was evaluated\r\n     */\r\n    public onEndLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered before the texture is rendered\r\n     */\r\n    public onBeginRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the texture was rendered\r\n     */\r\n    public onEndRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Gets or sets a boolean defining if alpha is stored as premultiplied\r\n     */\r\n    public premulAlpha = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the canvas must be reverted on Y when updating the texture\r\n     */\r\n    public applyYInversionOnUpdate = true;\r\n\r\n    /**\r\n     * A boolean indicating whether or not the elements can be navigated to using the tab key.\r\n     * Defaults to false.\r\n     */\r\n    public disableTabNavigation = false;\r\n\r\n    /**\r\n     * A boolean indicating whether controls can be picked/clicked on or not. Defaults to false.\r\n     */\r\n    public disablePicking = false;\r\n\r\n    /**\r\n     * If set to true, the POINTERTAP event type will be used for \"click\", instead of POINTERUP\r\n     */\r\n    public usePointerTapForClickEvent = false;\r\n\r\n    /**\r\n     * If set to true, the renderScale will be adjusted automatically to the engine's hardware scaling\r\n     * If this is set to true, manually setting the renderScale will be ignored\r\n     * This is useful when the engine's hardware scaling is set to a value other than 1\r\n     */\r\n    public get adjustToEngineHardwareScalingLevel(): boolean {\r\n        return this._adjustToEngineHardwareScalingLevel;\r\n    }\r\n\r\n    public set adjustToEngineHardwareScalingLevel(value: boolean) {\r\n        if (this._adjustToEngineHardwareScalingLevel === value) {\r\n            return;\r\n        }\r\n        this._adjustToEngineHardwareScalingLevel = value;\r\n        this._onResize();\r\n    }\r\n    /**\r\n     * Gets or sets a number used to scale rendering size (2 means that the texture will be twice bigger).\r\n     * Useful when you want more antialiasing\r\n     */\r\n    public get renderScale(): number {\r\n        return this._renderScale;\r\n    }\r\n    public set renderScale(value: number) {\r\n        if (value === this._renderScale) {\r\n            return;\r\n        }\r\n        this._renderScale = value;\r\n        this._onResize();\r\n    }\r\n    /** Gets or sets the background color */\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n        this._background = value;\r\n        this.markAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal width used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get idealWidth(): number {\r\n        return this._idealWidth;\r\n    }\r\n    public set idealWidth(value: number) {\r\n        if (this._idealWidth === value) {\r\n            return;\r\n        }\r\n        this._idealWidth = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal height used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get idealHeight(): number {\r\n        return this._idealHeight;\r\n    }\r\n    public set idealHeight(value: number) {\r\n        if (this._idealHeight === value) {\r\n            return;\r\n        }\r\n        this._idealHeight = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the smallest ideal value must be used if idealWidth and idealHeight are both set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get useSmallestIdeal(): boolean {\r\n        return this._useSmallestIdeal;\r\n    }\r\n    public set useSmallestIdeal(value: boolean) {\r\n        if (this._useSmallestIdeal === value) {\r\n            return;\r\n        }\r\n        this._useSmallestIdeal = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if adaptive scaling must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get renderAtIdealSize(): boolean {\r\n        return this._renderAtIdealSize;\r\n    }\r\n    public set renderAtIdealSize(value: boolean) {\r\n        if (this._renderAtIdealSize === value) {\r\n            return;\r\n        }\r\n        this._renderAtIdealSize = value;\r\n        this._onResize();\r\n    }\r\n\r\n    /**\r\n     * Gets the ratio used when in \"ideal mode\"\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     * */\r\n    public get idealRatio(): number {\r\n        let rwidth: number = 0;\r\n        let rheight: number = 0;\r\n\r\n        if (this._idealWidth) {\r\n            rwidth = this.getSize().width / this._idealWidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            rheight = this.getSize().height / this._idealHeight;\r\n        }\r\n\r\n        if (this._useSmallestIdeal && this._idealWidth && this._idealHeight) {\r\n            return window.innerWidth < window.innerHeight ? rwidth : rheight;\r\n        }\r\n\r\n        if (this._idealWidth) {\r\n            // horizontal\r\n            return rwidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            // vertical\r\n            return rheight;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying layer used to render the texture when in fullscreen mode\r\n     */\r\n    public get layer(): Nullable<Layer> {\r\n        return this._layerToDispose;\r\n    }\r\n    /**\r\n     * Gets the root container control\r\n     */\r\n    public get rootContainer(): Container {\r\n        return this._rootContainer;\r\n    }\r\n    /**\r\n     * Returns an array containing the root container.\r\n     * This is mostly used to let the Inspector introspects the ADT\r\n     * @returns an array containing the rootContainer\r\n     */\r\n    public getChildren(): Array<Container> {\r\n        return [this._rootContainer];\r\n    }\r\n    /**\r\n     * Will return all controls that are inside this texture\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns all child controls\r\n     */\r\n    public getDescendants(directDescendantsOnly?: boolean, predicate?: (control: Control) => boolean): Control[] {\r\n        return this._rootContainer.getDescendants(directDescendantsOnly, predicate);\r\n    }\r\n\r\n    /**\r\n     * Will return all controls with the given type name\r\n     * @param typeName defines the type name to search for\r\n     * @returns an array of all controls found\r\n     */\r\n    public getControlsByType(typeName: string): Control[] {\r\n        return this._rootContainer.getDescendants(false, (control) => control.typeName === typeName);\r\n    }\r\n\r\n    /**\r\n     * Will return the first control with the given name\r\n     * @param name defines the name to search for\r\n     * @returns the first control found or null\r\n     */\r\n    public getControlByName(name: string): Nullable<Control> {\r\n        return this._getControlByKey(\"name\", name);\r\n    }\r\n\r\n    private _getControlByKey(key: string, value: any): Nullable<Control> {\r\n        return this._rootContainer.getDescendants().find((control) => control[key as keyof Control] === value) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current focused control\r\n     */\r\n    public get focusedControl(): Nullable<Control> {\r\n        return this._focusedControl;\r\n    }\r\n    public set focusedControl(control: Nullable<Control>) {\r\n        if (this._focusedControl == control) {\r\n            return;\r\n        }\r\n        if (this._focusedControl) {\r\n            this._focusedControl.onBlur();\r\n        }\r\n        if (control) {\r\n            control.onFocus();\r\n        }\r\n        this._focusedControl = control;\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the texture must be rendered in background or foreground when in fullscreen mode\r\n     */\r\n    public get isForeground(): boolean {\r\n        if (!this.layer) {\r\n            return true;\r\n        }\r\n        return !this.layer.isBackground;\r\n    }\r\n    public set isForeground(value: boolean) {\r\n        if (!this.layer) {\r\n            return;\r\n        }\r\n        if (this.layer.isBackground === !value) {\r\n            return;\r\n        }\r\n        this.layer.isBackground = !value;\r\n    }\r\n    /**\r\n     * Gets or set information about clipboardData\r\n     */\r\n    public get clipboardData(): string {\r\n        return this._clipboardData;\r\n    }\r\n    public set clipboardData(value: string) {\r\n        this._clipboardData = value;\r\n    }\r\n\r\n    /**\r\n     * If this is set, even when a control is pointer blocker, some events can still be passed through to the scene.\r\n     * Options from values are PointerEventTypes\r\n     * POINTERDOWN, POINTERUP, POINTERMOVE, POINTERWHEEL, POINTERPICK, POINTERTAP, POINTERDOUBLETAP\r\n     */\r\n    public skipBlockEvents = 0;\r\n\r\n    /**\r\n     * If set to true, every scene render will trigger a pointer event for the GUI\r\n     * if it is linked to a mesh or has controls linked to a mesh. This will allow\r\n     * you to catch the pointer moving around the GUI due to camera or mesh movements,\r\n     * but it has a performance cost.\r\n     */\r\n    public checkPointerEveryFrame = false;\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options The options to be used when constructing the ADT\r\n     */\r\n    constructor(name: string, options?: IAdvancedDynamicTextureOptions);\r\n\r\n    constructor(name: string, width?: number, height?: number, scene?: Nullable<Scene>, generateMipMaps?: boolean, samplingMode?: number, invertY?: boolean);\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        widthOrOptions?: number | IAdvancedDynamicTextureOptions,\r\n        _height = 0,\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        samplingMode = Texture.NEAREST_SAMPLINGMODE,\r\n        invertY = true\r\n    ) {\r\n        widthOrOptions = widthOrOptions ?? 0;\r\n\r\n        const width = typeof widthOrOptions === \"object\" && widthOrOptions !== undefined ? (widthOrOptions.width ?? 0) : (widthOrOptions ?? 0);\r\n        const height = typeof widthOrOptions === \"object\" && widthOrOptions !== undefined ? (widthOrOptions.height ?? 0) : _height;\r\n\r\n        super(\r\n            name,\r\n            { width, height },\r\n            typeof widthOrOptions === \"object\" && widthOrOptions !== undefined ? widthOrOptions : scene,\r\n            generateMipMaps,\r\n            samplingMode,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            invertY\r\n        );\r\n\r\n        scene = this.getScene();\r\n        if (!scene || !this._texture) {\r\n            return;\r\n        }\r\n        this.applyYInversionOnUpdate = invertY;\r\n        this._rootElement = scene.getEngine().getInputElement();\r\n\r\n        const adtOptions = widthOrOptions as IAdvancedDynamicTextureOptions;\r\n\r\n        this.useStandalone = !!adtOptions?.useStandalone;\r\n\r\n        if (!this.useStandalone) {\r\n            this._renderObserver = scene.onBeforeCameraRenderObservable.add((camera: Camera) => this._checkUpdate(camera));\r\n        }\r\n\r\n        /** Whenever a control is added or removed to the root, we have to recheck the camera projection as it can have changed  */\r\n        this._controlAddedObserver = this._rootContainer.onControlAddedObservable.add((control) => {\r\n            if (control) {\r\n                this._rootChildrenHaveChanged = true;\r\n            }\r\n        });\r\n        this._controlRemovedObserver = this._rootContainer.onControlRemovedObservable.add((control) => {\r\n            if (control) {\r\n                this._rootChildrenHaveChanged = true;\r\n            }\r\n        });\r\n        this._preKeyboardObserver = scene.onPreKeyboardObservable.add((info) => {\r\n            // check if tab is pressed\r\n            if (!this.disableTabNavigation && info.type === KeyboardEventTypes.KEYDOWN && info.event.code === \"Tab\") {\r\n                const forward = !info.event.shiftKey;\r\n                if (\r\n                    (forward && this._focusProperties.index === this._focusProperties.total - 1) ||\r\n                    (!forward && this._focusProperties.index === 0 && this._focusProperties.total > 0)\r\n                ) {\r\n                    this.focusedControl = null;\r\n                    this._focusProperties.index = 0;\r\n                    this._focusProperties.total = -1;\r\n                    return;\r\n                }\r\n                this._focusNextElement(forward);\r\n                info.event.preventDefault();\r\n                return;\r\n            }\r\n            if (!this._focusedControl) {\r\n                return;\r\n            }\r\n            if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                this._focusedControl.processKeyboard(info.event);\r\n            }\r\n            info.skipOnPointerObservable = true;\r\n        });\r\n        this._rootContainer._link(this);\r\n        this.hasAlpha = true;\r\n        if (!width || !height) {\r\n            this._resizeObserver = scene.getEngine().onResizeObservable.add(() => this._onResize());\r\n            this._onResize();\r\n        }\r\n        this._texture.isReady = true;\r\n    }\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"AdvancedDynamicTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"AdvancedDynamicTexture\";\r\n    }\r\n    /**\r\n     * Function used to execute a function on all controls\r\n     * @param func defines the function to execute\r\n     * @param container defines the container where controls belong. If null the root container will be used\r\n     */\r\n    public executeOnAllControls(func: (control: Control) => void, container?: Container) {\r\n        if (!container) {\r\n            container = this._rootContainer;\r\n        }\r\n        func(container);\r\n        for (const child of container.children) {\r\n            if ((<any>child).children) {\r\n                this.executeOnAllControls(func, <Container>child);\r\n                continue;\r\n            }\r\n            func(child);\r\n        }\r\n    }\r\n\r\n    private _useInvalidateRectOptimization = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the InvalidateRect optimization should be turned on\r\n     */\r\n    public get useInvalidateRectOptimization(): boolean {\r\n        return this._useInvalidateRectOptimization;\r\n    }\r\n\r\n    public set useInvalidateRectOptimization(value: boolean) {\r\n        this._useInvalidateRectOptimization = value;\r\n    }\r\n\r\n    // Invalidated rectangle which is the combination of all invalidated controls after they have been rotated into absolute position\r\n    private _invalidatedRectangle: Nullable<Measure> = null;\r\n    /**\r\n     * Invalidates a rectangle area on the gui texture\r\n     * @param invalidMinX left most position of the rectangle to invalidate in the texture\r\n     * @param invalidMinY top most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxX right most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxY bottom most position of the rectangle to invalidate in the texture\r\n     */\r\n    public invalidateRect(invalidMinX: number, invalidMinY: number, invalidMaxX: number, invalidMaxY: number) {\r\n        if (!this._useInvalidateRectOptimization) {\r\n            return;\r\n        }\r\n        if (!this._invalidatedRectangle) {\r\n            this._invalidatedRectangle = new Measure(invalidMinX, invalidMinY, invalidMaxX - invalidMinX + 1, invalidMaxY - invalidMinY + 1);\r\n        } else {\r\n            // Compute intersection\r\n            const maxX = Math.ceil(Math.max(this._invalidatedRectangle.left + this._invalidatedRectangle.width - 1, invalidMaxX));\r\n            const maxY = Math.ceil(Math.max(this._invalidatedRectangle.top + this._invalidatedRectangle.height - 1, invalidMaxY));\r\n            this._invalidatedRectangle.left = Math.floor(Math.min(this._invalidatedRectangle.left, invalidMinX));\r\n            this._invalidatedRectangle.top = Math.floor(Math.min(this._invalidatedRectangle.top, invalidMinY));\r\n            this._invalidatedRectangle.width = maxX - this._invalidatedRectangle.left + 1;\r\n            this._invalidatedRectangle.height = maxY - this._invalidatedRectangle.top + 1;\r\n        }\r\n    }\r\n    /**\r\n     * Marks the texture as dirty forcing a complete update\r\n     */\r\n    public markAsDirty() {\r\n        this._isDirty = true;\r\n    }\r\n    /**\r\n     * Helper function used to create a new style\r\n     * @returns a new style\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#styles\r\n     */\r\n    public createStyle(): Style {\r\n        return new Style(this);\r\n    }\r\n    /**\r\n     * Adds a new control to the root container\r\n     * @param control defines the control to add\r\n     * @returns the current texture\r\n     */\r\n    public addControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.addControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a control from the root container\r\n     * @param control defines the control to remove\r\n     * @returns the current texture\r\n     */\r\n    public removeControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.removeControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Moves overlapped controls towards a position where it is not overlapping anymore.\r\n     * Please note that this method alters linkOffsetXInPixels and linkOffsetYInPixels.\r\n     * @param overlapGroup the overlap group which will be processed or undefined to process all overlap groups\r\n     * @param deltaStep the step size (speed) to reach the target non overlapping position (default 0.1)\r\n     * @param repelFactor how much is the control repelled by other controls\r\n     */\r\n    public moveToNonOverlappedPosition(overlapGroup?: number | Control[], deltaStep = 1, repelFactor = 1) {\r\n        let controlsForGroup: Control[];\r\n        if (Array.isArray(overlapGroup)) {\r\n            controlsForGroup = overlapGroup;\r\n        } else {\r\n            const descendants = this.getDescendants(true);\r\n            // get only the controls with an overlapGroup property set\r\n            // if the overlapGroup parameter is set, filter the controls and get only the controls belonging to that overlapGroup\r\n            controlsForGroup = overlapGroup === undefined ? descendants.filter((c) => c.overlapGroup !== undefined) : descendants.filter((c) => c.overlapGroup === overlapGroup);\r\n        }\r\n\r\n        controlsForGroup.forEach((control1) => {\r\n            let velocity = Vector2.Zero();\r\n            const center = new Vector2(control1.centerX, control1.centerY);\r\n\r\n            controlsForGroup.forEach((control2) => {\r\n                if (control1 !== control2 && AdvancedDynamicTexture._Overlaps(control1, control2)) {\r\n                    // if the two controls overlaps get a direction vector from one control's center to another control's center\r\n                    const diff = center.subtract(new Vector2(control2.centerX, control2.centerY));\r\n                    const diffLength = diff.length();\r\n\r\n                    if (diffLength > 0) {\r\n                        // calculate the velocity\r\n                        velocity = velocity.add(diff.normalize().scale(repelFactor / diffLength));\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (velocity.length() > 0) {\r\n                // move the control along the direction vector away from the overlapping control\r\n                velocity = velocity.normalize().scale(deltaStep * (control1.overlapDeltaMultiplier ?? 1));\r\n                control1.linkOffsetXInPixels += velocity.x;\r\n                control1.linkOffsetYInPixels += velocity.y;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public override dispose(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._rootElement = null;\r\n        scene.onBeforeCameraRenderObservable.remove(this._renderObserver);\r\n        if (this._resizeObserver) {\r\n            scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n        }\r\n        if (this._prePointerObserver) {\r\n            scene.onPrePointerObservable.remove(this._prePointerObserver);\r\n        }\r\n        if (this._sceneRenderObserver) {\r\n            scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._preKeyboardObserver) {\r\n            scene.onPreKeyboardObservable.remove(this._preKeyboardObserver);\r\n        }\r\n        if (this._canvasPointerOutObserver) {\r\n            scene.getEngine().onCanvasPointerOutObservable.remove(this._canvasPointerOutObserver);\r\n        }\r\n        if (this._canvasBlurObserver) {\r\n            scene.getEngine().onCanvasBlurObservable.remove(this._canvasBlurObserver);\r\n        }\r\n        if (this._controlAddedObserver) {\r\n            this._rootContainer.onControlAddedObservable.remove(this._controlAddedObserver);\r\n        }\r\n        if (this._controlRemovedObserver) {\r\n            this._rootContainer.onControlRemovedObservable.remove(this._controlRemovedObserver);\r\n        }\r\n        if (this._layerToDispose) {\r\n            this._layerToDispose.texture = null;\r\n            this._layerToDispose.dispose();\r\n            this._layerToDispose = null;\r\n        }\r\n        this._rootContainer.dispose();\r\n        this.onClipboardObservable.clear();\r\n        this.onControlPickedObservable.clear();\r\n        this.onBeginRenderObservable.clear();\r\n        this.onEndRenderObservable.clear();\r\n        this.onBeginLayoutObservable.clear();\r\n        this.onEndLayoutObservable.clear();\r\n        this.onGuiReadyObservable.clear();\r\n        super.dispose();\r\n    }\r\n    private _onResize(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        // Check size\r\n        const engine = scene.getEngine();\r\n        if (this.adjustToEngineHardwareScalingLevel) {\r\n            // force the renderScale to the engine's hardware scaling level\r\n            this._renderScale = engine.getHardwareScalingLevel();\r\n        }\r\n        const textureSize = this.getSize();\r\n        let renderWidth = engine.getRenderWidth() * this._renderScale;\r\n        let renderHeight = engine.getRenderHeight() * this._renderScale;\r\n\r\n        if (this._renderAtIdealSize) {\r\n            if (this._idealWidth) {\r\n                renderHeight = (renderHeight * this._idealWidth) / renderWidth;\r\n                renderWidth = this._idealWidth;\r\n            } else if (this._idealHeight) {\r\n                renderWidth = (renderWidth * this._idealHeight) / renderHeight;\r\n                renderHeight = this._idealHeight;\r\n            }\r\n        }\r\n        if (textureSize.width !== renderWidth || textureSize.height !== renderHeight) {\r\n            this.scaleTo(renderWidth, renderHeight);\r\n            this.markAsDirty();\r\n            if (this._idealWidth || this._idealHeight) {\r\n                this._rootContainer._markAllAsDirty();\r\n            }\r\n        }\r\n        this.invalidateRect(0, 0, textureSize.width - 1, textureSize.height - 1);\r\n    }\r\n    /** @internal */\r\n    public _getGlobalViewport(): Viewport {\r\n        const size = this.getSize();\r\n        const globalViewPort = this._fullscreenViewport.toGlobal(size.width, size.height);\r\n\r\n        const targetX = Math.round(globalViewPort.width * (1 / this.rootContainer.scaleX));\r\n        const targetY = Math.round(globalViewPort.height * (1 / this.rootContainer.scaleY));\r\n\r\n        globalViewPort.x += (globalViewPort.width - targetX) / 2;\r\n        globalViewPort.y += (globalViewPort.height - targetY) / 2;\r\n\r\n        globalViewPort.width = targetX;\r\n        globalViewPort.height = targetY;\r\n\r\n        return globalViewPort;\r\n    }\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position\r\n     */\r\n    public getProjectedPosition(position: Vector3, worldMatrix: Matrix): Vector2 {\r\n        const result = this.getProjectedPositionWithZ(position, worldMatrix);\r\n        return new Vector2(result.x, result.y);\r\n    }\r\n\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position with Z\r\n     */\r\n    public getProjectedPositionWithZ(position: Vector3, worldMatrix: Matrix): Vector3 {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return Vector3.Zero();\r\n        }\r\n        const globalViewport = this._getGlobalViewport();\r\n        const projectedPosition = Vector3.Project(position, worldMatrix, scene.getTransformMatrix(), globalViewport);\r\n        return new Vector3(projectedPosition.x, projectedPosition.y, projectedPosition.z);\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkUpdate(camera: Nullable<Camera>, skipUpdate?: boolean): void {\r\n        if (this._layerToDispose && camera) {\r\n            if ((camera.layerMask & this._layerToDispose.layerMask) === 0) {\r\n                return;\r\n            }\r\n        }\r\n        if (this._isFullscreen && this._linkedControls.length) {\r\n            const scene = this.getScene();\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            const globalViewport = this._getGlobalViewport();\r\n            for (const control of this._linkedControls) {\r\n                if (!control.isVisible) {\r\n                    continue;\r\n                }\r\n                const mesh = control._linkedMesh as AbstractMesh;\r\n                if (!mesh || mesh.isDisposed()) {\r\n                    Tools.SetImmediate(() => {\r\n                        control.linkWithMesh(null);\r\n                    });\r\n                    continue;\r\n                }\r\n                const position = mesh.getBoundingInfo ? mesh.getBoundingInfo().boundingSphere.center : (Vector3.ZeroReadOnly as Vector3);\r\n                const projectedPosition = Vector3.Project(position, mesh.getWorldMatrix(), scene.getTransformMatrix(), globalViewport);\r\n                if (projectedPosition.z < 0 || projectedPosition.z > 1) {\r\n                    control.notRenderable = true;\r\n                    continue;\r\n                }\r\n                control.notRenderable = false;\r\n                if (this.useInvalidateRectOptimization) {\r\n                    control.invalidateRect();\r\n                }\r\n\r\n                control._moveToProjectedPosition(projectedPosition);\r\n            }\r\n        }\r\n        if (!this._isDirty && !this._rootContainer.isDirty) {\r\n            return;\r\n        }\r\n        this._isDirty = false;\r\n        this._render(skipUpdate);\r\n        if (!skipUpdate) {\r\n            this.update(this.applyYInversionOnUpdate, this.premulAlpha, AdvancedDynamicTexture.AllowGPUOptimizations);\r\n        }\r\n    }\r\n\r\n    private _clearMeasure = new Measure(0, 0, 0, 0);\r\n\r\n    private _render(skipRender?: boolean): void {\r\n        const textureSize = this.getSize();\r\n        const renderWidth = textureSize.width;\r\n        const renderHeight = textureSize.height;\r\n\r\n        const context = this.getContext();\r\n        context.font = \"18px Arial\";\r\n        context.strokeStyle = \"white\";\r\n\r\n        if (this.onGuiReadyObservable.hasObservers()) {\r\n            this._checkGuiIsReady();\r\n        }\r\n\r\n        /** We have to recheck the camera projection in the case the root control's children have changed  */\r\n        if (this._rootChildrenHaveChanged) {\r\n            const camera = this.getScene()?.activeCamera;\r\n            if (camera) {\r\n                this._rootChildrenHaveChanged = false;\r\n                this._checkUpdate(camera, true);\r\n            }\r\n        }\r\n\r\n        // Layout\r\n        this.onBeginLayoutObservable.notifyObservers(this);\r\n        const measure = new Measure(0, 0, renderWidth, renderHeight);\r\n        this._numLayoutCalls = 0;\r\n        this._rootContainer._layout(measure, context);\r\n        this.onEndLayoutObservable.notifyObservers(this);\r\n        this._isDirty = false; // Restoring the dirty state that could have been set by controls during layout processing\r\n\r\n        if (skipRender) {\r\n            return;\r\n        }\r\n\r\n        // Clear\r\n        if (this._invalidatedRectangle) {\r\n            this._clearMeasure.copyFrom(this._invalidatedRectangle);\r\n        } else {\r\n            this._clearMeasure.copyFromFloats(0, 0, renderWidth, renderHeight);\r\n        }\r\n        context.clearRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n        if (this._background) {\r\n            context.save();\r\n            context.fillStyle = this._background;\r\n            context.fillRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n            context.restore();\r\n        }\r\n\r\n        // Render\r\n        this.onBeginRenderObservable.notifyObservers(this);\r\n        this._numRenderCalls = 0;\r\n        this._rootContainer._render(context, this._invalidatedRectangle);\r\n        this.onEndRenderObservable.notifyObservers(this);\r\n        this._invalidatedRectangle = null;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _changeCursor(cursor: string) {\r\n        if (this._rootElement) {\r\n            this._rootElement.style.cursor = cursor;\r\n            this._cursorChanged = true;\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerLastControlDown(control: Control, pointerId: number) {\r\n        this._lastControlDown[pointerId] = control;\r\n        this.onControlPickedObservable.notifyObservers(control);\r\n    }\r\n    private _doPicking(x: number, y: number, pi: Nullable<PointerInfoBase>, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): void {\r\n        const scene = this.getScene();\r\n        if (!scene || this.disablePicking) {\r\n            return;\r\n        }\r\n        const engine = scene.getEngine();\r\n        const textureSize = this.getSize();\r\n        if (this._isFullscreen) {\r\n            const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n            const viewport = camera.viewport;\r\n            x = x * (textureSize.width / (engine.getRenderWidth() * viewport.width));\r\n            y = y * (textureSize.height / (engine.getRenderHeight() * viewport.height));\r\n        }\r\n        if (this._capturingControl[pointerId]) {\r\n            if (this._capturingControl[pointerId].isPointerBlocker) {\r\n                this._shouldBlockPointer = true;\r\n            }\r\n            this._capturingControl[pointerId]._processObservables(type, x, y, pi, pointerId, buttonIndex);\r\n            return;\r\n        }\r\n\r\n        this._cursorChanged = false;\r\n        if (!this._rootContainer._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\r\n            if (!scene.doNotHandleCursors) {\r\n                this._changeCursor(\"\");\r\n            }\r\n            if (type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi);\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this._cursorChanged && !scene.doNotHandleCursors) {\r\n            this._changeCursor(\"\");\r\n        }\r\n        this._manageFocus();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cleanControlAfterRemovalFromList(list: { [pointerId: number]: Control }, control: Control) {\r\n        for (const pointerId in list) {\r\n            if (!Object.prototype.hasOwnProperty.call(list, pointerId)) {\r\n                continue;\r\n            }\r\n            const lastControlOver = list[pointerId];\r\n            if (lastControlOver === control) {\r\n                delete list[pointerId];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cleanControlAfterRemoval(control: Control) {\r\n        this._cleanControlAfterRemovalFromList(this._lastControlDown, control);\r\n        this._cleanControlAfterRemovalFromList(this._lastControlOver, control);\r\n    }\r\n\r\n    /**\r\n     * This function will run a pointer event on this ADT and will trigger any pointer events on any controls\r\n     * This will work on a fullscreen ADT only. For mesh based ADT, simulate pointer events using the scene directly.\r\n     * @param x pointer X on the canvas for the picking\r\n     * @param y pointer Y on the canvas for the picking\r\n     * @param pi optional pointer information\r\n     */\r\n    public pick(x: number, y: number, pi: Nullable<PointerInfoPre> = null) {\r\n        if (this._isFullscreen && this._scene) {\r\n            this._translateToPicking(this._scene, new Viewport(0, 0, 0, 0), pi, x, y);\r\n        }\r\n    }\r\n\r\n    private _translateToPicking(scene: Scene, tempViewport: Viewport, pi: Nullable<PointerInfoPre>, x: number = scene.pointerX, y: number = scene.pointerY) {\r\n        const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n        const engine = scene.getEngine();\r\n        const originalCameraToUseForPointers = scene.cameraToUseForPointers;\r\n\r\n        if (!camera) {\r\n            tempViewport.x = 0;\r\n            tempViewport.y = 0;\r\n            tempViewport.width = engine.getRenderWidth();\r\n            tempViewport.height = engine.getRenderHeight();\r\n        } else {\r\n            if (camera.rigCameras.length) {\r\n                // rig camera - we need to find the camera to use for this event\r\n                const rigViewport = new Viewport(0, 0, 1, 1);\r\n                camera.rigCameras.forEach((rigCamera) => {\r\n                    // generate the viewport of this camera\r\n                    rigCamera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), rigViewport);\r\n                    const transformedX = x / engine.getHardwareScalingLevel() - rigViewport.x;\r\n                    const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - rigViewport.y - rigViewport.height);\r\n                    // check if the pointer is in the camera's viewport\r\n                    if (transformedX < 0 || transformedY < 0 || x > rigViewport.width || y > rigViewport.height) {\r\n                        // out of viewport - don't use this camera\r\n                        return;\r\n                    }\r\n                    // set the camera to use for pointers until this pointer loop is over\r\n                    scene.cameraToUseForPointers = rigCamera;\r\n                    // set the viewport\r\n                    tempViewport.x = rigViewport.x;\r\n                    tempViewport.y = rigViewport.y;\r\n                    tempViewport.width = rigViewport.width;\r\n                    tempViewport.height = rigViewport.height;\r\n                });\r\n            } else {\r\n                camera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), tempViewport);\r\n            }\r\n        }\r\n\r\n        const transformedX = x / engine.getHardwareScalingLevel() - tempViewport.x;\r\n        const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - tempViewport.y - tempViewport.height);\r\n        this._shouldBlockPointer = false;\r\n        // Do picking modifies _shouldBlockPointer\r\n        if (pi) {\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            this._doPicking(transformedX, transformedY, pi, pi.type, pointerId, pi.event.button, (<IWheelEvent>pi.event).deltaX, (<IWheelEvent>pi.event).deltaY);\r\n            // Avoid overwriting a true skipOnPointerObservable to false\r\n            if ((this._shouldBlockPointer && !(pi.type & this.skipBlockEvents)) || this._capturingControl[pointerId]) {\r\n                pi.skipOnPointerObservable = true;\r\n            }\r\n        } else {\r\n            this._doPicking(transformedX, transformedY, null, PointerEventTypes.POINTERMOVE, this._defaultMousePointerId, 0);\r\n        }\r\n        // if overridden by a rig camera - reset back to the original value\r\n        scene.cameraToUseForPointers = originalCameraToUseForPointers;\r\n    }\r\n\r\n    /** Attach to all scene events required to support pointer events */\r\n    public attach(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const tempViewport = new Viewport(0, 0, 0, 0);\r\n\r\n        this._prePointerObserver = scene.onPrePointerObservable.add((pi) => {\r\n            if (\r\n                scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId) &&\r\n                pi.type === PointerEventTypes.POINTERUP &&\r\n                !this._capturedPointerIds.has((pi.event as IPointerEvent).pointerId)\r\n            ) {\r\n                return;\r\n            }\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL &&\r\n                pi.type !== PointerEventTypes.POINTERTAP\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                // Avoid pointerMove events firing while the pointer is captured by the scene\r\n                if (scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId)) {\r\n                    return;\r\n                }\r\n                if ((pi.event as IPointerEvent).pointerId) {\r\n                    this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n                }\r\n            }\r\n            this._translateToPicking(scene, tempViewport, pi);\r\n        });\r\n        this._attachPickingToSceneRender(scene, () => this._translateToPicking(scene, tempViewport, null), false);\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n\r\n    private _focusProperties: { index: number; total: number } = { index: 0, total: -1 };\r\n\r\n    private _focusNextElement(forward: boolean = true): void {\r\n        // generate the order of tab-able controls\r\n        const sortedTabbableControls: Control[] = [];\r\n        this.executeOnAllControls((control) => {\r\n            if (control.isFocusInvisible || !control.isVisible || control.tabIndex < 0) {\r\n                return;\r\n            }\r\n            sortedTabbableControls.push(control);\r\n        });\r\n        // if no control is tab-able, return\r\n        if (sortedTabbableControls.length === 0) {\r\n            return;\r\n        }\r\n        sortedTabbableControls.sort((a, b) => {\r\n            // if tabIndex is 0, put it in the end of the list, otherwise sort by tabIndex\r\n            return a.tabIndex === 0 ? 1 : b.tabIndex === 0 ? -1 : a.tabIndex - b.tabIndex;\r\n        });\r\n        this._focusProperties.total = sortedTabbableControls.length;\r\n        // if no control is focused, focus the first one\r\n        let nextIndex = -1;\r\n        if (!this._focusedControl) {\r\n            nextIndex = forward ? 0 : sortedTabbableControls.length - 1;\r\n        } else {\r\n            const currentIndex = sortedTabbableControls.indexOf(this._focusedControl);\r\n            nextIndex = currentIndex + (forward ? 1 : -1);\r\n            if (nextIndex < 0) {\r\n                nextIndex = sortedTabbableControls.length - 1;\r\n            } else if (nextIndex >= sortedTabbableControls.length) {\r\n                nextIndex = 0;\r\n            }\r\n        }\r\n        sortedTabbableControls[nextIndex].focus();\r\n        this._focusProperties.index = nextIndex;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardCopy = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.COPY, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardCut = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.CUT, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardPaste = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.PASTE, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * Register the clipboard Events onto the canvas\r\n     */\r\n    public registerClipboardEvents(): void {\r\n        self.addEventListener(\"copy\", this._onClipboardCopy, false);\r\n        self.addEventListener(\"cut\", this._onClipboardCut, false);\r\n        self.addEventListener(\"paste\", this._onClipboardPaste, false);\r\n    }\r\n    /**\r\n     * Unregister the clipboard Events from the canvas\r\n     */\r\n    public unRegisterClipboardEvents(): void {\r\n        self.removeEventListener(\"copy\", this._onClipboardCopy);\r\n        self.removeEventListener(\"cut\", this._onClipboardCut);\r\n        self.removeEventListener(\"paste\", this._onClipboardPaste);\r\n    }\r\n\r\n    /**\r\n     * Transform uvs from mesh space to texture space, taking the texture into account\r\n     * @param uv the uvs in mesh space\r\n     * @returns the uvs in texture space\r\n     */\r\n    private _transformUvs(uv: Vector2): Vector2 {\r\n        const textureMatrix = this.getTextureMatrix();\r\n        let result;\r\n        if (textureMatrix.isIdentityAs3x2()) {\r\n            result = uv;\r\n        } else {\r\n            const homogeneousTextureMatrix = TmpVectors.Matrix[0];\r\n\r\n            textureMatrix.getRowToRef(0, TmpVectors.Vector4[0]);\r\n            textureMatrix.getRowToRef(1, TmpVectors.Vector4[1]);\r\n            textureMatrix.getRowToRef(2, TmpVectors.Vector4[2]);\r\n\r\n            const r0 = TmpVectors.Vector4[0];\r\n            const r1 = TmpVectors.Vector4[1];\r\n            const r2 = TmpVectors.Vector4[2];\r\n\r\n            homogeneousTextureMatrix.setRowFromFloats(0, r0.x, r0.y, 0, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(1, r1.x, r1.y, 0, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(2, 0, 0, 1, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(3, r2.x, r2.y, 0, 1);\r\n\r\n            result = TmpVectors.Vector2[0];\r\n            Vector2.TransformToRef(uv, homogeneousTextureMatrix, result);\r\n        }\r\n\r\n        // In wrap and mirror mode, the texture coordinate for coordinates more than 1 is the fractional part of the coordinate\r\n        if (this.wrapU === Texture.WRAP_ADDRESSMODE || this.wrapU === Texture.MIRROR_ADDRESSMODE) {\r\n            if (result.x > 1) {\r\n                let fX = result.x - Math.trunc(result.x);\r\n                // In mirror mode, the sign of the texture coordinate depends on the integer part -\r\n                // odd integers means it is mirrored from the original coordinate\r\n                if (this.wrapU === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\r\n                    fX = 1 - fX;\r\n                }\r\n                result.x = fX;\r\n            }\r\n        }\r\n        if (this.wrapV === Texture.WRAP_ADDRESSMODE || this.wrapV === Texture.MIRROR_ADDRESSMODE) {\r\n            if (result.y > 1) {\r\n                let fY = result.y - Math.trunc(result.y);\r\n                if (this.wrapV === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\r\n                    fY = 1 - fY;\r\n                }\r\n                result.y = fY;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Connect the texture to a hosting mesh to enable interactions\r\n     * @param mesh defines the mesh to attach to\r\n     * @param supportPointerMove defines a boolean indicating if pointer move events must be catched as well\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh, supportPointerMove = true): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n\r\n        this._pointerObserver = scene.onPointerObservable.add((pi) => {\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE && (pi.event as IPointerEvent).pointerId) {\r\n                this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n            }\r\n\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            if (pi.pickInfo && pi.pickInfo.hit && pi.pickInfo.pickedMesh === mesh) {\r\n                let uv = pi.pickInfo.getTextureCoordinates();\r\n                if (uv) {\r\n                    uv = this._transformUvs(uv);\r\n                    const size = this.getSize();\r\n                    this._doPicking(\r\n                        uv.x * size.width,\r\n                        (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height,\r\n                        pi,\r\n                        pi.type,\r\n                        pointerId,\r\n                        pi.event.button,\r\n                        (<IWheelEvent>pi.event).deltaX,\r\n                        (<IWheelEvent>pi.event).deltaY\r\n                    );\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERUP) {\r\n                if (this._lastControlDown[pointerId]) {\r\n                    this._lastControlDown[pointerId]._forcePointerUp(pointerId);\r\n                }\r\n                delete this._lastControlDown[pointerId];\r\n                if (this.focusedControl) {\r\n                    const friendlyControls = this.focusedControl.keepsFocusWith();\r\n                    let canMoveFocus = true;\r\n                    if (friendlyControls) {\r\n                        for (const control of friendlyControls) {\r\n                            // Same host, no need to keep the focus\r\n                            if (this === control._host) {\r\n                                continue;\r\n                            }\r\n                            // Different hosts\r\n                            const otherHost = control._host;\r\n                            if (otherHost._lastControlOver[pointerId] && otherHost._lastControlOver[pointerId].isAscendant(control)) {\r\n                                canMoveFocus = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (canMoveFocus) {\r\n                        this.focusedControl = null;\r\n                    }\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi, true);\r\n                }\r\n                delete this._lastControlOver[pointerId];\r\n            }\r\n        });\r\n        mesh.enablePointerMoveEvents = supportPointerMove;\r\n        this._attachPickingToSceneRender(\r\n            scene,\r\n            () => {\r\n                const pointerId = this._defaultMousePointerId;\r\n                const pick = scene?.pick(scene.pointerX, scene.pointerY);\r\n                if (pick && pick.hit && pick.pickedMesh === mesh) {\r\n                    let uv = pick.getTextureCoordinates();\r\n                    if (uv) {\r\n                        uv = this._transformUvs(uv);\r\n                        const size = this.getSize();\r\n                        this._doPicking(uv.x * size.width, (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height, null, PointerEventTypes.POINTERMOVE, pointerId, 0);\r\n                    }\r\n                } else {\r\n                    if (this._lastControlOver[pointerId]) {\r\n                        this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], null, true);\r\n                    }\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            },\r\n            true\r\n        );\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n    /**\r\n     * Move the focus to a specific control\r\n     * @param control defines the control which will receive the focus\r\n     */\r\n    public moveFocusToControl(control: Control): void {\r\n        this.focusedControl = control;\r\n        this._lastPickedControl = <any>control;\r\n        this._blockNextFocusCheck = true;\r\n    }\r\n    private _manageFocus(): void {\r\n        if (this._blockNextFocusCheck) {\r\n            this._blockNextFocusCheck = false;\r\n            this._lastPickedControl = <any>this._focusedControl;\r\n            return;\r\n        }\r\n        // Focus management\r\n        if (this._focusedControl) {\r\n            if (this._focusedControl !== <any>this._lastPickedControl) {\r\n                if (this._lastPickedControl.isFocusInvisible) {\r\n                    return;\r\n                }\r\n                this.focusedControl = null;\r\n            }\r\n        }\r\n    }\r\n    private _attachPickingToSceneRender(scene: Scene, pickFunction: () => void, forcePicking: boolean) {\r\n        this._sceneRenderObserver = scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.checkPointerEveryFrame) {\r\n                return;\r\n            }\r\n            if (this._linkedControls.length > 0 || forcePicking) {\r\n                pickFunction();\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnPointerOut(scene: Scene): void {\r\n        this._canvasPointerOutObserver = scene.getEngine().onCanvasPointerOutObservable.add((pointerEvent) => {\r\n            if (this._lastControlOver[pointerEvent.pointerId]) {\r\n                this._lastControlOver[pointerEvent.pointerId]._onPointerOut(this._lastControlOver[pointerEvent.pointerId], null);\r\n            }\r\n            delete this._lastControlOver[pointerEvent.pointerId];\r\n            if (this._lastControlDown[pointerEvent.pointerId] && this._lastControlDown[pointerEvent.pointerId] !== this._capturingControl[pointerEvent.pointerId]) {\r\n                this._lastControlDown[pointerEvent.pointerId]._forcePointerUp(pointerEvent.pointerId);\r\n                delete this._lastControlDown[pointerEvent.pointerId];\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnBlur(scene: Scene): void {\r\n        this._canvasBlurObserver = scene.getEngine().onCanvasBlurObservable.add(() => {\r\n            Object.entries(this._lastControlDown).forEach(([, value]) => {\r\n                value._onCanvasBlur();\r\n            });\r\n            this.focusedControl = null;\r\n            this._lastControlDown = {};\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes the entire GUI system\r\n     * @returns an object with the JSON serialized data\r\n     */\r\n    public serializeContent(): any {\r\n        const size = this.getSize();\r\n        const serializationObject = {\r\n            root: {},\r\n            width: size.width,\r\n            height: size.height,\r\n        };\r\n\r\n        this._rootContainer.serialize(serializationObject.root);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     */\r\n    public parseSerializedObject(serializedObject: any, scaleToSize?: boolean, urlRewriter?: (url: string) => string) {\r\n        this._rootContainer = Control.Parse(serializedObject.root, this, urlRewriter) as Container;\r\n        if (scaleToSize) {\r\n            const width = serializedObject.width;\r\n            const height = serializedObject.height;\r\n            if (typeof width === \"number\" && typeof height === \"number\" && width >= 0 && height >= 0) {\r\n                this.scaleTo(width, height);\r\n            } else {\r\n                // scales the GUI to a default size if none was available in the serialized content\r\n                this.scaleTo(1920, 1080);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the ADT. If no mesh is defined, the GUI will be considered as a fullscreen GUI\r\n     * @param newName defines the name of the new ADT\r\n     * @param attachToMesh defines if the new ADT should be attached to a mesh\r\n     * @returns the clone of the ADT\r\n     */\r\n    public override clone(newName?: string, attachToMesh?: AbstractMesh): AdvancedDynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n        const size = this.getSize();\r\n        const data = this.serializeContent();\r\n        let clone;\r\n        if (!this._isFullscreen) {\r\n            if (attachToMesh) {\r\n                clone = AdvancedDynamicTexture.CreateForMesh(attachToMesh, size.width, size.height);\r\n            } else {\r\n                clone = new AdvancedDynamicTexture(newName ?? \"Clone of \" + this.name, size.width, size.height, scene, !this.noMipmap, this.samplingMode);\r\n            }\r\n        } else {\r\n            clone = AdvancedDynamicTexture.CreateFullscreenUI(newName ?? \"Clone of \" + this.name);\r\n        }\r\n        clone.parseSerializedObject(data);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @deprecated Please use parseSerializedObject instead\r\n     */\r\n    public parseContent = this.parseSerializedObject;\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public static async ParseFromSnippetAsync(\r\n        snippetId: string,\r\n        scaleToSize?: boolean,\r\n        appendToAdt?: AdvancedDynamicTexture,\r\n        urlRewriter?: (url: string) => string\r\n    ): Promise<AdvancedDynamicTexture> {\r\n        const adt = appendToAdt ?? AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from snippet\");\r\n        if (snippetId === \"_BLANK\") {\r\n            return adt;\r\n        }\r\n\r\n        const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(AdvancedDynamicTexture.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"), true);\r\n        adt.parseSerializedObject(serialized, scaleToSize, urlRewriter);\r\n        return adt;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public parseFromSnippetAsync(snippetId: string, scaleToSize?: boolean, urlRewriter?: (url: string) => string): Promise<AdvancedDynamicTexture> {\r\n        return AdvancedDynamicTexture.ParseFromSnippetAsync(snippetId, scaleToSize, this, urlRewriter);\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public static async ParseFromFileAsync(\r\n        url: string,\r\n        scaleToSize?: boolean,\r\n        appendToAdt?: AdvancedDynamicTexture,\r\n        urlRewriter?: (url: string) => string\r\n    ): Promise<AdvancedDynamicTexture> {\r\n        const adt = appendToAdt ?? AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from URL\");\r\n        const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(url);\r\n        adt.parseSerializedObject(serialized, scaleToSize, urlRewriter);\r\n        return adt;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public parseFromURLAsync(url: string, scaleToSize?: boolean, urlRewriter?: (url: string) => string): Promise<AdvancedDynamicTexture> {\r\n        return AdvancedDynamicTexture.ParseFromFileAsync(url, scaleToSize, this, urlRewriter);\r\n    }\r\n\r\n    private static _LoadURLContentAsync(url: string, snippet: boolean = false): Promise<any> {\r\n        if (url === \"\") {\r\n            return Promise.reject(\"No URL provided\");\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let gui;\r\n                        if (snippet) {\r\n                            const payload = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                            gui = payload.encodedGui ? new TextDecoder(\"utf-8\").decode(DecodeBase64ToBinary(payload.encodedGui)) : payload.gui;\r\n                        } else {\r\n                            gui = request.responseText;\r\n                        }\r\n                        const serializationObject = JSON.parse(gui);\r\n                        resolve(serializationObject);\r\n                    } else {\r\n                        reject(\"Unable to load\");\r\n                    }\r\n                }\r\n            });\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Compares two rectangle based controls for pixel overlap\r\n     * @param control1 The first control to compare\r\n     * @param control2 The second control to compare\r\n     * @returns true if overlaps, otherwise false\r\n     */\r\n    private static _Overlaps(control1: Control, control2: Control) {\r\n        return !(\r\n            control1.centerX > control2.centerX + control2.widthInPixels ||\r\n            control1.centerX + control1.widthInPixels < control2.centerX ||\r\n            control1.centerY + control1.heightInPixels < control2.centerY ||\r\n            control1.centerY > control2.centerY + control2.heightInPixels\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh)\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param onlyAlphaTesting defines a boolean indicating that alpha blending will not be used (only alpha testing) (false by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @param materialSetupCallback defines a custom way of creating and setting up the material on the mesh\r\n     * @param sampling defines the texture sampling mode (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMesh(\r\n        mesh: AbstractMesh,\r\n        width = 1024,\r\n        height = 1024,\r\n        supportPointerMove = true,\r\n        onlyAlphaTesting = false,\r\n        invertY?: boolean,\r\n        materialSetupCallback: (mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean) => void = this._CreateMaterial,\r\n        sampling = Texture.TRILINEAR_SAMPLINGMODE\r\n    ): AdvancedDynamicTexture {\r\n        // use a unique ID in name so serialization will work even if you create two ADTs for a single mesh\r\n        const uniqueId = RandomGUID();\r\n        const result = new AdvancedDynamicTexture(`AdvancedDynamicTexture for ${mesh.name} [${uniqueId}]`, width, height, mesh.getScene(), true, sampling, invertY);\r\n\r\n        materialSetupCallback(mesh, uniqueId, result, onlyAlphaTesting);\r\n\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n\r\n    private static _CreateMaterial(mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean): void {\r\n        const internalClassType = GetClass(\"BABYLON.StandardMaterial\");\r\n        if (!internalClassType) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"StandardMaterial needs to be imported before as it contains a side-effect required by your code.\";\r\n        }\r\n\r\n        const material: StandardMaterial = new internalClassType(`AdvancedDynamicTextureMaterial for ${mesh.name} [${uniqueId}]`, mesh.getScene());\r\n        material.backFaceCulling = false;\r\n        material.diffuseColor = Color3.Black();\r\n        material.specularColor = Color3.Black();\r\n        if (onlyAlphaTesting) {\r\n            material.diffuseTexture = texture;\r\n            material.emissiveTexture = texture;\r\n            texture.hasAlpha = true;\r\n        } else {\r\n            material.emissiveTexture = texture;\r\n            material.opacityTexture = texture;\r\n        }\r\n        mesh.material = material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh) BUT do not create a new material for the mesh. You will be responsible for connecting the texture\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @param sampling defines the texture sampling mode (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMeshTexture(\r\n        mesh: AbstractMesh,\r\n        width = 1024,\r\n        height = 1024,\r\n        supportPointerMove = true,\r\n        invertY?: boolean,\r\n        sampling = Texture.TRILINEAR_SAMPLINGMODE\r\n    ): AdvancedDynamicTexture {\r\n        const result = new AdvancedDynamicTexture(mesh.name + \" AdvancedDynamicTexture\", width, height, mesh.getScene(), true, sampling, invertY);\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in fullscreen mode.\r\n     * In this mode the texture will rely on a layer for its rendering.\r\n     * This allows it to be treated like any other layer.\r\n     * As such, if you have a multi camera setup, you can set the layerMask on the GUI as well.\r\n     * LayerMask is set through advancedTexture.layer.layerMask\r\n     * @param name defines name for the texture\r\n     * @param foreground defines a boolean indicating if the texture must be rendered in foreground (default is true)\r\n     * @param sceneOrOptions defines the hosting scene or options (IAdvancedDynamicTextureOptions)\r\n     * @param sampling defines the texture sampling mode (Texture.BILINEAR_SAMPLINGMODE by default)\r\n     * @param adaptiveScaling defines whether to automatically scale root to match hardwarescaling (false by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateFullscreenUI(\r\n        name: string,\r\n        foreground: boolean = true,\r\n        sceneOrOptions: Nullable<Scene> | IAdvancedDynamicTextureOptions = null,\r\n        sampling = Texture.BILINEAR_SAMPLINGMODE,\r\n        adaptiveScaling: boolean = false\r\n    ): AdvancedDynamicTexture {\r\n        const isScene = !sceneOrOptions || (sceneOrOptions as Scene)._isScene;\r\n        const result = isScene\r\n            ? new AdvancedDynamicTexture(name, 0, 0, sceneOrOptions as Scene, false, sampling)\r\n            : new AdvancedDynamicTexture(name, sceneOrOptions as IAdvancedDynamicTextureOptions);\r\n        // Display\r\n        const resultScene = result.getScene();\r\n        const layer = new Layer(name + \"_layer\", null, resultScene, !foreground);\r\n        layer.texture = result;\r\n        result._layerToDispose = layer;\r\n        result._isFullscreen = true;\r\n\r\n        if (result.useStandalone) {\r\n            // Make sure the layer is not rendered by the layer component!\r\n            layer.layerMask = 0;\r\n        }\r\n\r\n        if (adaptiveScaling && resultScene) {\r\n            const newScale = 1 / resultScene.getEngine().getHardwareScalingLevel();\r\n            result._rootContainer.scaleX = newScale;\r\n            result._rootContainer.scaleY = newScale;\r\n        }\r\n\r\n        // Attach\r\n        result.attach();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public override scale(ratio: number): void {\r\n        super.scale(ratio);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public override scaleTo(width: number, height: number): void {\r\n        super.scaleTo(width, height);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    private _checkGuiIsReady() {\r\n        if (this.guiIsReady()) {\r\n            this.onGuiReadyObservable.notifyObservers(this);\r\n\r\n            this.onGuiReadyObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns true if all the GUI components are ready to render\r\n     */\r\n    public guiIsReady(): boolean {\r\n        return this._rootContainer.isReady();\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { PerfCounter } from \"core/Misc/perfCounter\";\r\nimport type { IDisposable } from \"core/scene\";\r\n\r\nimport type { AdvancedDynamicTexture } from \"./advancedDynamicTexture\";\r\n\r\n/**\r\n * This class can be used to get instrumentation data from a AdvancedDynamicTexture object\r\n */\r\nexport class AdvancedDynamicTextureInstrumentation implements IDisposable {\r\n    private _captureRenderTime = false;\r\n    private _renderTime = new PerfCounter();\r\n\r\n    private _captureLayoutTime = false;\r\n    private _layoutTime = new PerfCounter();\r\n\r\n    // Observers\r\n    private _onBeginRenderObserver: Nullable<Observer<AdvancedDynamicTexture>> = null;\r\n    private _onEndRenderObserver: Nullable<Observer<AdvancedDynamicTexture>> = null;\r\n    private _onBeginLayoutObserver: Nullable<Observer<AdvancedDynamicTexture>> = null;\r\n    private _onEndLayoutObserver: Nullable<Observer<AdvancedDynamicTexture>> = null;\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets the perf counter used to capture render time\r\n     */\r\n    public get renderTimeCounter(): PerfCounter {\r\n        return this._renderTime;\r\n    }\r\n\r\n    /**\r\n     * Gets the perf counter used to capture layout time\r\n     */\r\n    public get layoutTimeCounter(): PerfCounter {\r\n        return this._layoutTime;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the render time capture\r\n     */\r\n    public get captureRenderTime(): boolean {\r\n        return this._captureRenderTime;\r\n    }\r\n\r\n    public set captureRenderTime(value: boolean) {\r\n        if (value === this._captureRenderTime) {\r\n            return;\r\n        }\r\n\r\n        this._captureRenderTime = value;\r\n\r\n        if (value) {\r\n            this._onBeginRenderObserver = this.texture.onBeginRenderObservable.add(() => {\r\n                this._renderTime.beginMonitoring();\r\n            });\r\n\r\n            this._onEndRenderObserver = this.texture.onEndRenderObservable.add(() => {\r\n                this._renderTime.endMonitoring(true);\r\n            });\r\n        } else {\r\n            this.texture.onBeginRenderObservable.remove(this._onBeginRenderObserver);\r\n            this._onBeginRenderObserver = null;\r\n            this.texture.onEndRenderObservable.remove(this._onEndRenderObserver);\r\n            this._onEndRenderObserver = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the layout time capture\r\n     */\r\n    public get captureLayoutTime(): boolean {\r\n        return this._captureLayoutTime;\r\n    }\r\n\r\n    public set captureLayoutTime(value: boolean) {\r\n        if (value === this._captureLayoutTime) {\r\n            return;\r\n        }\r\n\r\n        this._captureLayoutTime = value;\r\n\r\n        if (value) {\r\n            this._onBeginLayoutObserver = this.texture.onBeginLayoutObservable.add(() => {\r\n                this._layoutTime.beginMonitoring();\r\n            });\r\n\r\n            this._onEndLayoutObserver = this.texture.onEndLayoutObservable.add(() => {\r\n                this._layoutTime.endMonitoring(true);\r\n            });\r\n        } else {\r\n            this.texture.onBeginLayoutObservable.remove(this._onBeginLayoutObserver);\r\n            this._onBeginLayoutObserver = null;\r\n            this.texture.onEndLayoutObservable.remove(this._onEndLayoutObserver);\r\n            this._onEndLayoutObserver = null;\r\n        }\r\n    }\r\n    /**\r\n     * Instantiates a new advanced dynamic texture instrumentation.\r\n     * This class can be used to get instrumentation data from an AdvancedDynamicTexture object\r\n     * @param texture Defines the AdvancedDynamicTexture to instrument\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Define the instrumented AdvancedDynamicTexture.\r\n         */\r\n        public texture: AdvancedDynamicTexture\r\n    ) {}\r\n\r\n    /**\r\n     * Dispose and release associated resources.\r\n     */\r\n    public dispose() {\r\n        this.texture.onBeginRenderObservable.remove(this._onBeginRenderObserver);\r\n        this._onBeginRenderObserver = null;\r\n        this.texture.onEndRenderObservable.remove(this._onEndRenderObserver);\r\n        this._onEndRenderObserver = null;\r\n        this.texture.onBeginLayoutObservable.remove(this._onBeginLayoutObserver);\r\n        this._onBeginLayoutObserver = null;\r\n        this.texture.onEndLayoutObservable.remove(this._onEndLayoutObserver);\r\n        this._onEndLayoutObserver = null;\r\n\r\n        (<any>this.texture) = null;\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { FrameGraphTextureHandle, FrameGraph } from \"core/index\";\r\nimport { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport { FrameGraphTask } from \"core/FrameGraph/frameGraphTask\";\r\n\r\n/**\r\n * Task that renders a GUI texture.\r\n */\r\nexport class FrameGraphGUITask extends FrameGraphTask {\r\n    /**\r\n     * The destination texture to render the GUI to.\r\n     */\r\n    public destinationTexture: FrameGraphTextureHandle;\r\n\r\n    /**\r\n     * The output texture of the task.\r\n     * This is the same texture as the destination texture, but the handles are different!\r\n     */\r\n    public readonly outputTexture: FrameGraphTextureHandle;\r\n\r\n    public override get disabled() {\r\n        return this._disabled;\r\n    }\r\n\r\n    public override set disabled(value: boolean) {\r\n        this._disabled = value;\r\n        this._adt.disablePicking = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying advanced dynamic texture.\r\n     */\r\n    public get gui() {\r\n        return this._adt;\r\n    }\r\n\r\n    protected _adt: AdvancedDynamicTexture;\r\n\r\n    /**\r\n     * Constructs a new GUI task.\r\n     * @param name Name of the task\r\n     * @param frameGraph Frame graph the task belongs to\r\n     * @param adt The GUI texture. If not provided, a new fullscreen GUI will be created.\r\n     */\r\n    constructor(name: string, frameGraph: FrameGraph, adt?: AdvancedDynamicTexture) {\r\n        super(name, frameGraph);\r\n\r\n        if (adt) {\r\n            if (!adt.useStandalone) {\r\n                throw new Error(`AdvancedDynamicTexture \"${name}\": the texture must have been created with the useStandalone property set to true`);\r\n            }\r\n        } else {\r\n            adt = AdvancedDynamicTexture.CreateFullscreenUI(name, undefined, { useStandalone: true });\r\n        }\r\n        this._adt = adt;\r\n\r\n        this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();\r\n    }\r\n\r\n    public override isReady() {\r\n        return this._adt.guiIsReady() && this._adt._layerToDispose!.isReady();\r\n    }\r\n\r\n    public record(): void {\r\n        if (this.destinationTexture === undefined) {\r\n            throw new Error(\"FrameGraphGUITask: destinationTexture is required\");\r\n        }\r\n\r\n        this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, this.destinationTexture);\r\n\r\n        const pass = this._frameGraph.addRenderPass(this.name);\r\n\r\n        pass.setRenderTarget(this.outputTexture);\r\n        pass.setExecuteFunc((context) => {\r\n            this._adt._checkUpdate(null);\r\n            context.render(this._adt._layerToDispose!);\r\n        });\r\n\r\n        const passDisabled = this._frameGraph.addRenderPass(this.name + \"_disabled\", true);\r\n\r\n        passDisabled.setRenderTarget(this.outputTexture);\r\n        passDisabled.setExecuteFunc((_context) => {});\r\n    }\r\n\r\n    public override dispose(): void {\r\n        this._adt.dispose();\r\n        super.dispose();\r\n    }\r\n}\r\n", "import { NodeRenderGraphBlock } from \"core/FrameGraph/Node/nodeRenderGraphBlock\";\r\nimport { AdvancedDynamicTexture } from \"../advancedDynamicTexture\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { NodeRenderGraphBlockConnectionPointTypes } from \"core/FrameGraph/Node/Types/nodeRenderGraphTypes\";\r\nimport type { NodeRenderGraphConnectionPoint } from \"core/FrameGraph/Node/nodeRenderGraphBlockConnectionPoint\";\r\nimport type { NodeRenderGraphBuildState } from \"core/FrameGraph/Node/nodeRenderGraphBuildState\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { FrameGraphTextureHandle } from \"core/FrameGraph/frameGraphTypes\";\r\nimport { FrameGraphGUITask } from \"./guiTask\";\r\nimport type { FrameGraph } from \"core/FrameGraph/frameGraph\";\r\n\r\n/**\r\n * Block that implements a fullscreen GUI for render graph\r\n */\r\nexport class NodeRenderGraphGUIBlock extends NodeRenderGraphBlock {\r\n    protected override _frameGraphTask: FrameGraphGUITask;\r\n    protected _gui: AdvancedDynamicTexture;\r\n\r\n    /**\r\n     * Gets the frame graph task associated with this block\r\n     */\r\n    public override get task() {\r\n        return this._frameGraphTask;\r\n    }\r\n\r\n    /**\r\n     * Gets the GUI texture used by this block\r\n     */\r\n    public get gui() {\r\n        return this._frameGraphTask.gui;\r\n    }\r\n\r\n    /**\r\n     * Create a new NodeRenderGraphGUIBlock\r\n     * @param name defines the block name\r\n     * @param frameGraph defines the hosting frame graph\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public constructor(name: string, frameGraph: FrameGraph, scene: Scene) {\r\n        super(name, frameGraph, scene);\r\n\r\n        this.registerInput(\"destination\", NodeRenderGraphBlockConnectionPointTypes.Texture);\r\n        this._addDependenciesInput();\r\n        this.registerOutput(\"output\", NodeRenderGraphBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this.destination.addAcceptedConnectionPointTypes(NodeRenderGraphBlockConnectionPointTypes.TextureAll);\r\n        this.output._typeConnectionSource = this.destination;\r\n\r\n        this._gui = AdvancedDynamicTexture.CreateFullscreenUI(this.name, undefined, {\r\n            useStandalone: true,\r\n        });\r\n        this._frameGraphTask = new FrameGraphGUITask(this.name, frameGraph, this._gui);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"GUI.NodeRenderGraphGUIBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the destination input component\r\n     */\r\n    public get destination(): NodeRenderGraphConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeRenderGraphConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeRenderGraphBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this.output.value = this._frameGraphTask.outputTexture; // the value of the output connection point is the \"output\" texture of the task\r\n\r\n        this._frameGraphTask.destinationTexture = this.destination.connectedPoint?.value as FrameGraphTextureHandle;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GUI.NodeRenderGraphGUIBlock\", NodeRenderGraphGUIBlock);\r\n", "import { GetClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst XmlLoaderError = \"XmlLoader Exception : XML file is malformed or corrupted.\";\r\n\r\n/**\r\n * Class used to load GUI via XML.\r\n */\r\nexport class XmlLoader {\r\n    private _nodes: any = {};\r\n\r\n    private _nodeTypes: any = {\r\n        element: 1,\r\n        attribute: 2,\r\n        text: 3,\r\n    };\r\n\r\n    private _isLoaded: boolean = false;\r\n\r\n    private _objectAttributes: any = {\r\n        textHorizontalAlignment: 1,\r\n        textVerticalAlignment: 2,\r\n        horizontalAlignment: 3,\r\n        verticalAlignment: 4,\r\n        stretch: 5,\r\n    };\r\n\r\n    private _rootNode: any;\r\n\r\n    private _parentClass: any;\r\n\r\n    /**\r\n     * Create a new xml loader\r\n     * @param parentClass Sets the class context. Used when the loader is instanced inside a class and not in a global context\r\n     */\r\n    constructor(parentClass: any = null) {\r\n        if (parentClass) {\r\n            this._parentClass = parentClass;\r\n        }\r\n    }\r\n\r\n    private _getChainElement(attributeValue: any): any {\r\n        let element: any = window;\r\n\r\n        if (this._parentClass) {\r\n            element = this._parentClass;\r\n        }\r\n        let value = attributeValue;\r\n        value = value.split(\".\");\r\n\r\n        for (let i = 0; i < value.length; i++) {\r\n            element = element[value[i]];\r\n        }\r\n        return element;\r\n    }\r\n\r\n    private _getClassAttribute(attributeName: string): any {\r\n        const attribute = attributeName.split(\".\");\r\n        const className = GetClass(\"BABYLON.GUI.\" + attribute[0]);\r\n        return className[attribute[1]];\r\n    }\r\n\r\n    private _createGuiElement(node: any, parent: any, linkParent: boolean = true): void {\r\n        try {\r\n            const className = GetClass(\"BABYLON.GUI.\" + node.nodeName);\r\n            const guiNode = new className();\r\n\r\n            if (parent && linkParent) {\r\n                parent.addControl(guiNode);\r\n            }\r\n\r\n            for (let i = 0; i < node.attributes.length; i++) {\r\n                if (node.attributes[i].name.toLowerCase().includes(\"datasource\")) {\r\n                    continue;\r\n                }\r\n\r\n                if (node.attributes[i].name.toLowerCase().includes(\"observable\")) {\r\n                    const element = this._getChainElement(node.attributes[i].value);\r\n                    guiNode[node.attributes[i].name].add(element);\r\n\r\n                    continue;\r\n                } else if (node.attributes[i].name == \"linkWithMesh\") {\r\n                    if (this._parentClass) {\r\n                        guiNode.linkWithMesh(this._parentClass[node.attributes[i].value]);\r\n                    } else {\r\n                        guiNode.linkWithMesh(window[node.attributes[i].value]);\r\n                    }\r\n                } else if (node.attributes[i].value.match(/{{.*}}/)) {\r\n                    const matches = node.attributes[i].value.match(/{{(.*)}}/);\r\n                    let element = this._getChainElement(matches[1]);\r\n                    if (!(node.attributes[i].value.startsWith(\"{{\") && node.attributes[i].value.endsWith(\"}}\"))) {\r\n                        element = (node.attributes[i].value as string).replace(/{{.*}}/, `${element}`);\r\n                    }\r\n                    guiNode[node.attributes[i].name] = element;\r\n                } else if (!this._objectAttributes[node.attributes[i].name]) {\r\n                    if (node.attributes[i].value == \"true\" || node.attributes[i].value == \"false\") {\r\n                        guiNode[node.attributes[i].name] = node.attributes[i].value == \"true\";\r\n                    } else {\r\n                        guiNode[node.attributes[i].name] = !isNaN(Number(node.attributes[i].value)) ? Number(node.attributes[i].value) : node.attributes[i].value;\r\n                    }\r\n                } else {\r\n                    guiNode[node.attributes[i].name] = this._getClassAttribute(node.attributes[i].value);\r\n                }\r\n            }\r\n\r\n            if (!node.attributes.getNamedItem(\"id\")) {\r\n                this._nodes[node.nodeName + Object.keys(this._nodes).length + \"_gen\"] = guiNode;\r\n                return guiNode;\r\n            }\r\n\r\n            let id = node.attributes.getNamedItem(\"id\").value;\r\n            if (id.startsWith(\"{{\") && id.endsWith(\"}}\")) {\r\n                id = this._getChainElement(id.substring(2, id.length - 2));\r\n            }\r\n\r\n            if (!this._nodes[id]) {\r\n                this._nodes[id] = guiNode;\r\n            } else {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"XmlLoader Exception : Duplicate ID, every element should have an unique ID attribute\";\r\n            }\r\n            return guiNode;\r\n        } catch (exception) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"XmlLoader Exception : Error parsing Control \" + node.nodeName + \",\" + exception + \".\";\r\n        }\r\n    }\r\n\r\n    private _parseGrid(node: any, guiNode: any, parent: any): void {\r\n        let width;\r\n        let height;\r\n        let columns;\r\n        const rows = node.children;\r\n        let cells;\r\n        let isPixel = false;\r\n        let cellNode;\r\n        let rowNumber = -1;\r\n        let columnNumber = -1;\r\n        let totalColumnsNumber = 0;\r\n\r\n        for (let i = 0; i < rows.length; i++) {\r\n            if (rows[i].nodeType != this._nodeTypes.element) {\r\n                continue;\r\n            }\r\n            if (rows[i].nodeName != \"Row\") {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"XmlLoader Exception : Expecting Row node, received \" + rows[i].nodeName;\r\n            }\r\n            rowNumber += 1;\r\n            columns = rows[i].children;\r\n\r\n            if (!rows[i].attributes.getNamedItem(\"height\")) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"XmlLoader Exception : Height must be defined for grid rows\";\r\n            }\r\n            height = Number(rows[i].attributes.getNamedItem(\"height\").nodeValue);\r\n            isPixel = rows[i].attributes.getNamedItem(\"isPixel\") ? JSON.parse(rows[i].attributes.getNamedItem(\"isPixel\").nodeValue) : false;\r\n            guiNode.addRowDefinition(height, isPixel);\r\n\r\n            for (let j = 0; j < columns.length; j++) {\r\n                if (columns[j].nodeType != this._nodeTypes.element) {\r\n                    continue;\r\n                }\r\n                if (columns[j].nodeName != \"Column\") {\r\n                    // eslint-disable-next-line no-throw-literal\r\n                    throw \"XmlLoader Exception : Expecting Column node, received \" + columns[j].nodeName;\r\n                }\r\n                columnNumber += 1;\r\n                if (rowNumber > 0 && columnNumber > totalColumnsNumber) {\r\n                    // eslint-disable-next-line no-throw-literal\r\n                    throw \"XmlLoader Exception : In the Grid element, the number of columns is defined in the first row, do not add more columns in the subsequent rows.\";\r\n                }\r\n\r\n                if (rowNumber == 0) {\r\n                    if (!columns[j].attributes.getNamedItem(\"width\")) {\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"XmlLoader Exception : Width must be defined for all the grid columns in the first row\";\r\n                    }\r\n                    width = Number(columns[j].attributes.getNamedItem(\"width\").nodeValue);\r\n                    isPixel = columns[j].attributes.getNamedItem(\"isPixel\") ? JSON.parse(columns[j].attributes.getNamedItem(\"isPixel\").nodeValue) : false;\r\n                    guiNode.addColumnDefinition(width, isPixel);\r\n                }\r\n\r\n                cells = columns[j].children;\r\n\r\n                for (let k = 0; k < cells.length; k++) {\r\n                    if (cells[k].nodeType != this._nodeTypes.element) {\r\n                        continue;\r\n                    }\r\n                    cellNode = this._createGuiElement(cells[k], guiNode, false);\r\n                    guiNode.addControl(cellNode, rowNumber, columnNumber);\r\n                    if (cells[k].firstChild) {\r\n                        this._parseXml(cells[k].firstChild, cellNode);\r\n                    }\r\n                }\r\n            }\r\n            if (rowNumber == 0) {\r\n                totalColumnsNumber = columnNumber;\r\n            }\r\n            columnNumber = -1;\r\n        }\r\n\r\n        if (node.nextSibling) {\r\n            this._parseXml(node.nextSibling, parent);\r\n        }\r\n    }\r\n\r\n    private _parseElement(node: any, guiNode: any, parent: any): void {\r\n        if (node.firstChild) {\r\n            this._parseXml(node.firstChild, guiNode);\r\n        }\r\n\r\n        if (node.nextSibling) {\r\n            this._parseXml(node.nextSibling, parent);\r\n        }\r\n    }\r\n\r\n    private _prepareSourceElement(node: any, guiNode: any, variable: any, source: any, iterator: any): void {\r\n        if (this._parentClass) {\r\n            this._parentClass[variable] = source[iterator];\r\n        } else {\r\n            window[variable] = source[iterator];\r\n        }\r\n\r\n        if (node.firstChild) {\r\n            this._parseXml(node.firstChild, guiNode, true);\r\n        }\r\n    }\r\n\r\n    private _parseElementsFromSource(node: any, guiNode: any, parent: any): void {\r\n        const dataSource = node.attributes.getNamedItem(\"dataSource\").value;\r\n\r\n        if (!dataSource.includes(\" in \")) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"XmlLoader Exception : Malformed XML, Data Source must include an in\";\r\n        } else {\r\n            let isArray = true;\r\n            const splittedSource = dataSource.split(\" in \");\r\n            if (splittedSource.length < 2) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"XmlLoader Exception : Malformed XML, Data Source must have an iterator and a source\";\r\n            }\r\n            let source = splittedSource[1];\r\n            if (source.startsWith(\"{\") && source.endsWith(\"}\")) {\r\n                isArray = false;\r\n            }\r\n\r\n            if (!isArray || (source.startsWith(\"[\") && source.endsWith(\"]\"))) {\r\n                source = source.substring(1, source.length - 1);\r\n            }\r\n\r\n            if (this._parentClass) {\r\n                source = this._parentClass[source];\r\n            } else {\r\n                source = window[source];\r\n            }\r\n\r\n            if (isArray) {\r\n                for (let i = 0; i < source.length; i++) {\r\n                    this._prepareSourceElement(node, guiNode, splittedSource[0], source, i);\r\n                }\r\n            } else {\r\n                for (const i in source) {\r\n                    this._prepareSourceElement(node, guiNode, splittedSource[0], source, i);\r\n                }\r\n            }\r\n\r\n            if (node.nextSibling) {\r\n                this._parseXml(node.nextSibling, parent);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _parseXml(node: any, parent: any, generated: boolean = false): void {\r\n        if (node.nodeType != this._nodeTypes.element) {\r\n            if (node.nextSibling) {\r\n                this._parseXml(node.nextSibling, parent, generated);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (generated) {\r\n            node.setAttribute(\"id\", parent.id + (parent._children.length + 1));\r\n        }\r\n\r\n        const guiNode = this._createGuiElement(node, parent);\r\n\r\n        if (!this._rootNode) {\r\n            this._rootNode = guiNode;\r\n        }\r\n\r\n        if (node.nodeName == \"Grid\") {\r\n            this._parseGrid(node, guiNode, parent);\r\n        } else if (!node.attributes.getNamedItem(\"dataSource\")) {\r\n            this._parseElement(node, guiNode, parent);\r\n        } else {\r\n            this._parseElementsFromSource(node, guiNode, parent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets if the loading has finished.\r\n     * @returns whether the loading has finished or not\r\n     */\r\n    public isLoaded(): boolean {\r\n        return this._isLoaded;\r\n    }\r\n\r\n    /**\r\n     * Gets a loaded node / control by id.\r\n     * @param id the Controls id set in the xml\r\n     * @returns element of type Control\r\n     */\r\n    public getNodeById(id: string): any {\r\n        return this._nodes[id];\r\n    }\r\n\r\n    /**\r\n     * Gets all loaded nodes / controls\r\n     * @returns Array of controls\r\n     */\r\n    public getNodes(): any {\r\n        return this._nodes;\r\n    }\r\n    /**\r\n     * Disposes the loaded layout\r\n     */\r\n    public dispose(): void {\r\n        if (this._rootNode) {\r\n            this._rootNode.dispose();\r\n            this._rootNode = null;\r\n            this._nodes = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initiates the xml layout loading\r\n     * @param xmlFile defines the xml layout to load\r\n     * @param rootNode defines the node / control to use as a parent for the loaded layout controls.\r\n     * @param onSuccess defines the callback called on layout load successfully.\r\n     * @param onError defines the callback called on layout load failure.\r\n     */\r\n    public loadLayout(xmlFile: any, rootNode: any, onSuccess: Nullable<() => void> = null, onError: Nullable<(error: string) => void> = null): void {\r\n        const xhttp = new XMLHttpRequest();\r\n        xhttp.onload = () => {\r\n            if (xhttp.readyState === 4 && xhttp.status === 200) {\r\n                if (!xhttp.responseXML) {\r\n                    if (onError) {\r\n                        onError(XmlLoaderError);\r\n                        return;\r\n                    } else {\r\n                        throw XmlLoaderError;\r\n                    }\r\n                }\r\n\r\n                const xmlDoc = xhttp.responseXML.documentElement;\r\n                this._parseXml(xmlDoc.firstChild, rootNode);\r\n                this._isLoaded = true;\r\n\r\n                if (onSuccess) {\r\n                    onSuccess();\r\n                }\r\n            }\r\n        };\r\n\r\n        xhttp.onerror = function () {\r\n            if (onError) {\r\n                onError(\"an error occurred during loading the layout\");\r\n            }\r\n        };\r\n\r\n        xhttp.open(\"GET\", xmlFile, true);\r\n        xhttp.send();\r\n    }\r\n    /**\r\n     * Initiates the xml layout loading asynchronously\r\n     * @param xmlFile defines the xml layout to load\r\n     * @param rootNode defines the node / control to use as a parent for the loaded layout controls.\r\n     * @returns Promise\r\n     */\r\n    public async loadLayoutAsync(xmlFile: any, rootNode: any): Promise<any> {\r\n        return new Promise((resolve: any, reject: any) => {\r\n            this.loadLayout(xmlFile, rootNode, resolve, reject);\r\n        });\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["name", "name", "contains", "name", "TextWrapping", "name", "name", "name", "name", "name", "name", "name", "name", "labelText", "minusPound", "name", "name", "name", "name", "name", "name", "name", "name", "name", "value", "name", "name", "name", "name", "name", "name", "name", "name", "name", "transformedX", "transformedY", "name", "name"]
}
