{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/Extensions/engine.dynamicTexture.ts", "../../../dev/core/src/Materials/Textures/dynamicTexture.ts", "../../../dev/core/src/Events/clipboardEvents.ts", "../../../dev/core/src/FrameGraph/Node/Types/nodeRenderGraphTypes.ts", "../../../dev/core/src/FrameGraph/Node/nodeRenderGraphBlockConnectionPoint.ts", "../../../dev/core/src/FrameGraph/Node/nodeRenderGraphBlock.ts", "../../../dev/core/src/FrameGraph/Passes/pass.ts", "../../../dev/core/src/FrameGraph/Passes/cullPass.ts", "../../../dev/core/src/FrameGraph/Passes/renderPass.ts", "../../../dev/core/src/FrameGraph/frameGraphTask.ts", "../../../dev/core/src/Layers/layerSceneComponent.ts", "../../../dev/core/src/Layers/layer.ts"],
  "sourcesContent": ["import { GetExponentOfTwo } from \"core/Misc/tools.functions\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ImageSource, Nullable } from \"../../types\";\r\nimport type { ICanvas } from \"../ICanvas\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageSource | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageSource,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    allowGPUOptimization: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source as TexImageSource);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    if (format) {\r\n        texture.format = format;\r\n    }\r\n\r\n    texture._dynamicTextureSource = source;\r\n    texture._premulAlpha = premulAlpha;\r\n    texture.invertY = invertY || false;\r\n    texture.isReady = true;\r\n};\r\n", "import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport type { ITextureCreationOptions } from \"../../Materials/Textures/texture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\n\r\n/**\r\n * Interface defining options used to create a dynamic texture\r\n */\r\nexport interface IDynamicTextureOptions extends ITextureCreationOptions {\r\n    /** defines the width of the texture (default: 0) */\r\n    width?: number;\r\n    /** defines the height of the texture (default: 0) */\r\n    height?: number;\r\n    /** defines the hosting scene (default: null) */\r\n    scene?: Nullable<Scene>;\r\n}\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _ownCanvas: boolean;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param canvasOrSize provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param options The options to be used when constructing the dynamic texture\r\n     */\r\n    constructor(name: string, canvasOrSize: ICanvas | { width: number; height: number } | number, options?: IDynamicTextureOptions);\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: ICanvas | { width: number; height: number } | number,\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps?: boolean,\r\n        samplingMode?: number,\r\n        format?: number,\r\n        invertY?: boolean\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        canvasOrSize: ICanvas | { width: number; height: number } | number,\r\n        sceneOrOptions?: Nullable<Scene> | IDynamicTextureOptions,\r\n        generateMipMaps?: boolean,\r\n        samplingMode?: number,\r\n        format?: number,\r\n        invertY?: boolean\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        canvasOrSize: ICanvas | { width: number; height: number } | number,\r\n        sceneOrOptions?: Nullable<Scene> | IDynamicTextureOptions,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        const isScene = !sceneOrOptions || (sceneOrOptions as Scene)._isScene;\r\n        const scene = isScene ? (sceneOrOptions as Scene) : (sceneOrOptions as IDynamicTextureOptions)?.scene;\r\n        const noMipmap = isScene ? !generateMipMaps : (sceneOrOptions as IDynamicTextureOptions);\r\n\r\n        super(null, scene, noMipmap, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if ((canvasOrSize as ICanvas).getContext) {\r\n            this._canvas = canvasOrSize as ICanvas;\r\n            this._ownCanvas = false;\r\n            this._texture = engine.createDynamicTexture(this._canvas.width, this._canvas.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n            this._ownCanvas = true;\r\n\r\n            const optionsAsSize = canvasOrSize as ISize;\r\n            if (optionsAsSize.width || optionsAsSize.width === 0) {\r\n                this._texture = engine.createDynamicTexture(optionsAsSize.width, optionsAsSize.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(canvasOrSize as number, canvasOrSize as number, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public override get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public override scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     * @param clearColor Defines the clear color to use\r\n     */\r\n    public clear(clearColor?: string): void {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n        }\r\n        this._context.clearRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        fillColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (fillColor) {\r\n            this._context.fillStyle = fillColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the dynamic texture.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        if (this._ownCanvas) {\r\n            this._canvas?.remove?.();\r\n        }\r\n        (this._canvas as any) = null;\r\n        (this._context as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public override clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public override serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n", "/**\r\n * Gather the list of clipboard event types as constants.\r\n */\r\nexport class ClipboardEventTypes {\r\n    /**\r\n     * The clipboard event is fired when a copy command is active (pressed).\r\n     */\r\n    public static readonly COPY = 0x01; //\r\n    /**\r\n     *  The clipboard event is fired when a cut command is active (pressed).\r\n     */\r\n    public static readonly CUT = 0x02;\r\n\r\n    /**\r\n     * The clipboard event is fired when a paste command is active (pressed).\r\n     */\r\n    public static readonly PASTE = 0x03;\r\n}\r\n/**\r\n * This class is used to store clipboard related info for the onClipboardObservable event.\r\n */\r\nexport class ClipboardInfo {\r\n    /**\r\n     *Creates an instance of ClipboardInfo.\r\n     * @param type Defines the type of event (BABYLON.ClipboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (BABYLON.ClipboardEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: ClipboardEvent\r\n    ) {}\r\n\r\n    /**\r\n     *  Get the clipboard event's type from the keycode.\r\n     * @param keyCode Defines the keyCode for the current keyboard event.\r\n     * @returns {number}\r\n     */\r\n    public static GetTypeFromCharacter(keyCode: number): number {\r\n        const charCode = keyCode;\r\n        //TODO: add codes for extended ASCII\r\n        switch (charCode) {\r\n            case 67:\r\n                return ClipboardEventTypes.COPY;\r\n            case 86:\r\n                return ClipboardEventTypes.PASTE;\r\n            case 88:\r\n                return ClipboardEventTypes.CUT;\r\n            default:\r\n                return -1;\r\n        }\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { Color4, Scene, FrameGraphTextureHandle, Camera, FrameGraphObjectList, IShadowLight, FrameGraphShadowGeneratorTask, FrameGraphObjectRendererTask } from \"core/index\";\r\n\r\n/**\r\n * Interface used to configure the node render graph editor\r\n */\r\nexport interface INodeRenderGraphEditorOptions {\r\n    /** Define the URL to load node editor script from */\r\n    editorURL?: string;\r\n    /** Additional configuration for the FGE */\r\n    nodeRenderGraphEditorConfig?: {\r\n        backgroundColor?: Color4;\r\n        hostScene?: Scene;\r\n    };\r\n}\r\n\r\n/**\r\n * Options that can be passed to the node render graph build method\r\n */\r\nexport interface INodeRenderGraphCreateOptions {\r\n    /** If true, textures created by the node render graph will be visible in the inspector, for easier debugging (default: false) */\r\n    debugTextures?: boolean;\r\n    /** Rebuild the node render graph when the screen is resized (default: true) */\r\n    rebuildGraphOnEngineResize?: boolean;\r\n    /** Defines if the build should log activity (default: false) */\r\n    verbose?: boolean;\r\n    /** Defines if the autoConfigure method should be called when initializing blocks (default: false) */\r\n    autoConfigure?: boolean;\r\n    /** If true, external inputs like object lists and cameras will be filled with default values, taken from the scene. Note that external textures are not concerned (default: true). */\r\n    autoFillExternalInputs?: boolean;\r\n}\r\n\r\n/**\r\n * Defines the kind of connection point for node render graph nodes\r\n */\r\nexport enum NodeRenderGraphBlockConnectionPointTypes {\r\n    /** General purpose texture */\r\n    Texture = 0x00000001,\r\n    /** Back buffer color texture */\r\n    TextureBackBuffer = 0x00000002,\r\n    /** Back buffer depth/stencil attachment */\r\n    TextureBackBufferDepthStencilAttachment = 0x00000004,\r\n    /** Depth/stencil attachment */\r\n    TextureDepthStencilAttachment = 0x00000008,\r\n    /** Depth (in view space) geometry texture */\r\n    TextureViewDepth = 0x00000010,\r\n    /** Normal (in view space) geometry texture */\r\n    TextureViewNormal = 0x00000020,\r\n    /** Albedo geometry texture */\r\n    TextureAlbedo = 0x00000040,\r\n    /** Reflectivity geometry texture */\r\n    TextureReflectivity = 0x00000080,\r\n    /** Position (in world space) geometry texture */\r\n    TextureWorldPosition = 0x00000100,\r\n    /** Velocity geometry texture */\r\n    TextureVelocity = 0x00000200,\r\n    /** Irradiance geometry texture */\r\n    TextureIrradiance = 0x00000400,\r\n    /** Albedo (sqrt) geometry texture */\r\n    TextureAlbedoSqrt = 0x00000800,\r\n    /** Depth (in screen space) geometry texture */\r\n    TextureScreenDepth = 0x00001000,\r\n    /** Normal (in world space) geometry texture */\r\n    TextureWorldNormal = 0x00002000,\r\n    /** Position (in local space) geometry texture */\r\n    TextureLocalPosition = 0x00004000,\r\n    /** Linear velocity geometry texture */\r\n    TextureLinearVelocity = 0x00008000,\r\n\r\n    /** Bit field for all textures but back buffer depth/stencil */\r\n    TextureAllButBackBufferDepthStencil = 0x000ffffb,\r\n    /** Bit field for all textures but back buffer color and depth/stencil */\r\n    TextureAllButBackBuffer = 0x000ffff9,\r\n    /** Bit field for all textures */\r\n    TextureAll = 0x000fffff,\r\n\r\n    /** Resource container */\r\n    ResourceContainer = 0x00100000,\r\n    /** Shadow generator */\r\n    ShadowGenerator = 0x00200000,\r\n    /** Light */\r\n    ShadowLight = 0x00400000,\r\n    /** Camera */\r\n    Camera = 0x01000000,\r\n    /** List of objects (meshes, particle systems, sprites) */\r\n    ObjectList = 0x02000000,\r\n\r\n    /** Detect type based on connection */\r\n    AutoDetect = 0x10000000,\r\n    /** Output type that will be defined by input type */\r\n    BasedOnInput = 0x20000000,\r\n    /** Undefined */\r\n    Undefined = 0x40000000,\r\n    /** Custom object */\r\n    Object = 0x80000000,\r\n    /** Bitmask of all types */\r\n    All = 0xffffffff,\r\n}\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport const enum NodeRenderGraphConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport const enum NodeRenderGraphConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines the type of a connection point value\r\n */\r\nexport type NodeRenderGraphBlockConnectionPointValueType =\r\n    | FrameGraphTextureHandle\r\n    | Camera\r\n    | FrameGraphObjectList\r\n    | IShadowLight\r\n    | FrameGraphShadowGeneratorTask\r\n    | FrameGraphObjectRendererTask;\r\n", "import type {\r\n    Nullable,\r\n    NodeRenderGraphBlock,\r\n    NodeRenderGraphBlockConnectionPointValueType,\r\n    NodeRenderGraphInputBlock,\r\n    IShadowLight,\r\n    FrameGraphShadowGeneratorTask,\r\n    // eslint-disable-next-line import/no-internal-modules\r\n} from \"core/index\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeRenderGraphBlockConnectionPointTypes, NodeRenderGraphConnectionPointCompatibilityStates, NodeRenderGraphConnectionPointDirection } from \"./Types/nodeRenderGraphTypes\";\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeRenderGraphConnectionPoint {\r\n    private readonly _ownerBlock: NodeRenderGraphBlock;\r\n    private _connectedPoint: Nullable<NodeRenderGraphConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeRenderGraphConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeRenderGraphConnectionPoint>();\r\n    private readonly _direction: NodeRenderGraphConnectionPointDirection;\r\n    private _type = NodeRenderGraphBlockConnectionPointTypes.Undefined;\r\n\r\n    /** @internal */\r\n    public _linkedConnectionSource: Nullable<NodeRenderGraphConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _isMainLinkSource = false;\r\n\r\n    /** @internal */\r\n    public _typeConnectionSource: Nullable<NodeRenderGraphConnectionPoint | (() => NodeRenderGraphConnectionPoint)> = null;\r\n\r\n    /** @internal */\r\n    public _defaultConnectionPointType: Nullable<NodeRenderGraphBlockConnectionPointTypes> = null;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /**\r\n     * Checks if the value is a texture handle\r\n     * @param value The value to check\r\n     * @returns True if the value is a texture handle\r\n     */\r\n    public static IsTextureHandle(value: NodeRenderGraphBlockConnectionPointValueType | undefined): boolean {\r\n        return value !== undefined && Number.isFinite(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if the value is a shadow generator task\r\n     * @param value The value to check\r\n     * @returns True if the value is a shadow generator\r\n     */\r\n    public static IsShadowGenerator(value: NodeRenderGraphBlockConnectionPointValueType | undefined): boolean {\r\n        return value !== undefined && (value as FrameGraphShadowGeneratorTask).mapSize !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Checks if the value is a shadow light\r\n     * @param value The value to check\r\n     * @returns True if the value is a shadow light\r\n     */\r\n    public static IsShadowLight(value: NodeRenderGraphBlockConnectionPointValueType | undefined): boolean {\r\n        return value !== undefined && (value as IShadowLight).setShadowProjectionMatrix !== undefined;\r\n    }\r\n\r\n    /**\r\n     * The value stored in this connection point\r\n     */\r\n    public value: NodeRenderGraphBlockConnectionPointValueType | undefined;\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes: NodeRenderGraphBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes: NodeRenderGraphBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeRenderGraphConnectionPoint>();\r\n\r\n    /**\r\n     * Observable triggered when this point is disconnected\r\n     */\r\n    public onDisconnectionObservable = new Observable<NodeRenderGraphConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is Undefined)\r\n     */\r\n    public get type(): NodeRenderGraphBlockConnectionPointTypes {\r\n        if (this._type === NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as NodeRenderGraphInputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource) {\r\n                if (this._linkedConnectionSource.isConnected) {\r\n                    return this._linkedConnectionSource.type;\r\n                }\r\n                if (this._linkedConnectionSource._defaultConnectionPointType) {\r\n                    return this._linkedConnectionSource._defaultConnectionPointType;\r\n                }\r\n            }\r\n\r\n            if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeRenderGraphBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                const typeConnectionSource = typeof this._typeConnectionSource === \"function\" ? this._typeConnectionSource() : this._typeConnectionSource;\r\n                if (!typeConnectionSource.isConnected) {\r\n                    return this._defaultConnectionPointType ?? typeConnectionSource.type;\r\n                }\r\n                return typeConnectionSource._connectedPoint!.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeRenderGraphBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point display name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeRenderGraphBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeRenderGraphConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeRenderGraphBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeRenderGraphBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeRenderGraphBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeRenderGraphBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeRenderGraphBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeRenderGraphBlock, direction: NodeRenderGraphConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeRenderGraphConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeRenderGraphConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeRenderGraphConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeRenderGraphConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeRenderGraphConnectionPoint): NodeRenderGraphConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {\r\n            // Accepted types\r\n            if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n                return NodeRenderGraphConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeRenderGraphConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeRenderGraphConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeRenderGraphConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeRenderGraphConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeRenderGraphConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeRenderGraphConnectionPoint, ignoreConstraints = false): NodeRenderGraphConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeRenderGraphConnectionPoint): NodeRenderGraphConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n\r\n        this.onDisconnectionObservable.notifyObservers(endpoint);\r\n        endpoint.onDisconnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of excluded connection point types with all types other than those passed in the parameter\r\n     * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\r\n     */\r\n    public addExcludedConnectionPointFromAllowedTypes(mask: number): void {\r\n        let bitmask = 0;\r\n        let val = 2 ** bitmask;\r\n        // Note: don't use 1 << bitmask instead of 2 ** bitmask, as it will cause an infinite loop because 1 << 31 is negative!\r\n        while (val < NodeRenderGraphBlockConnectionPointTypes.All) {\r\n            if (!(mask & val)) {\r\n                this.excludedConnectionPointTypes.push(val);\r\n            }\r\n            bitmask++;\r\n            val = 2 ** bitmask;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds accepted connection point types\r\n     * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed to connect to this point\r\n     */\r\n    public addAcceptedConnectionPointTypes(mask: number): void {\r\n        let bitmask = 0;\r\n        let val = 2 ** bitmask;\r\n        // Note: don't use 1 << bitmask instead of 2 ** bitmask, as it will cause an infinite loop because 1 << 31 is negative!\r\n        while (val < NodeRenderGraphBlockConnectionPointTypes.All) {\r\n            if (mask & val && this.acceptedConnectionPointTypes.indexOf(val) === -1) {\r\n                this.acceptedConnectionPointTypes.push(val);\r\n            }\r\n            bitmask++;\r\n            val = 2 ** bitmask;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n        this.onDisconnectionObservable.clear();\r\n    }\r\n}\r\n", "import type {\r\n    NodeRenderGraphBuildState,\r\n    Nullable,\r\n    NodeRenderGraphInputBlock,\r\n    AbstractEngine,\r\n    Scene,\r\n    FrameGraphTask,\r\n    FrameGraph,\r\n    NodeRenderGraphResourceContainerBlock,\r\n    FrameGraphTextureHandle,\r\n    // eslint-disable-next-line import/no-internal-modules\r\n} from \"core/index\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport { NodeRenderGraphBlockConnectionPointTypes, NodeRenderGraphConnectionPointDirection } from \"./Types/nodeRenderGraphTypes\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { NodeRenderGraphConnectionPoint } from \"./nodeRenderGraphBlockConnectionPoint\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node render graph\r\n */\r\nexport class NodeRenderGraphBlock {\r\n    private _name = \"\";\r\n    private _buildId: number;\r\n    protected _isInput = false;\r\n    protected _isTeleportOut = false;\r\n    protected _isTeleportIn = false;\r\n    protected _isDebug = false;\r\n    protected _isUnique = false;\r\n    protected _scene: Scene;\r\n    protected _engine: AbstractEngine;\r\n    protected _frameGraph: FrameGraph;\r\n    protected _frameGraphTask?: FrameGraphTask;\r\n\r\n    /**\r\n     * Gets or sets the disable flag of the task associated with this block\r\n     */\r\n    public get disabled() {\r\n        return !!this._frameGraphTask?.disabled;\r\n    }\r\n\r\n    public set disabled(value: boolean) {\r\n        if (this._frameGraphTask) {\r\n            this._frameGraphTask.disabled = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the frame graph task associated with this block\r\n     */\r\n    public get task() {\r\n        return this._frameGraphTask;\r\n    }\r\n\r\n    /**\r\n     * Gets an observable raised when the block is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeRenderGraphBlock>();\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeRenderGraphConnectionPoint>();\r\n\r\n    /** @internal */\r\n    public _outputs = new Array<NodeRenderGraphConnectionPoint>();\r\n\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @internal */\r\n    public _additionalConstructionParameters: Nullable<unknown[]> = null;\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeRenderGraphConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeRenderGraphConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or set the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is an input\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport out\r\n     */\r\n    public get isTeleportOut(): boolean {\r\n        return this._isTeleportOut;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport in\r\n     */\r\n    public get isTeleportIn(): boolean {\r\n        return this._isTeleportIn;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a debug block\r\n     */\r\n    public get isDebug(): boolean {\r\n        return this._isDebug;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per node render graph\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the block\r\n     */\r\n    @serialize(\"comment\")\r\n    public comments: string;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeRenderGraphBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeRenderGraphBlock\";\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeRenderGraphBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given type\r\n     * @param type defines the potential type to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOfType(type: string): boolean {\r\n        if (this.getClassName() === type) {\r\n            return true;\r\n        }\r\n\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock.isAnAncestorOfType(type)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the first descendant using a predicate\r\n     * @param predicate defines the predicate to check\r\n     * @returns descendant or null if none found\r\n     */\r\n    public getDescendantOfPredicate(predicate: (block: NodeRenderGraphBlock) => boolean): Nullable<NodeRenderGraphBlock> {\r\n        if (predicate(this)) {\r\n            return this;\r\n        }\r\n\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);\r\n                if (descendant) {\r\n                    return descendant;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new NodeRenderGraphBlock\r\n     * @param name defines the block name\r\n     * @param frameGraph defines the hosting frame graph\r\n     * @param scene defines the hosting scene\r\n     * @param _additionalConstructionParameters defines additional parameters to pass to the block constructor\r\n     */\r\n    public constructor(name: string, frameGraph: FrameGraph, scene: Scene, ..._additionalConstructionParameters: unknown[]) {\r\n        this._name = name;\r\n        this._frameGraph = frameGraph;\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(name: string, type: NodeRenderGraphBlockConnectionPointTypes, isOptional: boolean = false, point?: NodeRenderGraphConnectionPoint) {\r\n        point = point ?? new NodeRenderGraphConnectionPoint(name, this, NodeRenderGraphConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeRenderGraphBlockConnectionPointTypes, point?: NodeRenderGraphConnectionPoint) {\r\n        point = point ?? new NodeRenderGraphConnectionPoint(name, this, NodeRenderGraphConnectionPointDirection.Output);\r\n        point.type = type;\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _addDependenciesInput() {\r\n        this.registerInput(\"dependencies\", NodeRenderGraphBlockConnectionPointTypes.Texture, true);\r\n\r\n        const dependencies = this.getInputByName(\"dependencies\")!;\r\n\r\n        dependencies.addAcceptedConnectionPointTypes(\r\n            NodeRenderGraphBlockConnectionPointTypes.TextureAllButBackBuffer |\r\n                NodeRenderGraphBlockConnectionPointTypes.ResourceContainer |\r\n                NodeRenderGraphBlockConnectionPointTypes.ShadowGenerator\r\n        );\r\n\r\n        return dependencies;\r\n    }\r\n\r\n    protected _buildBlock(_state: NodeRenderGraphBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    protected _customBuildStep(_state: NodeRenderGraphBuildState): void {\r\n        // Must be implemented by children\r\n    }\r\n\r\n    protected _propagateInputValueToOutput(inputConnectionPoint: NodeRenderGraphConnectionPoint, outputConnectionPoint: NodeRenderGraphConnectionPoint) {\r\n        if (inputConnectionPoint.connectedPoint) {\r\n            outputConnectionPoint.value = inputConnectionPoint.connectedPoint.value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build the current node and generate the vertex data\r\n     * @param state defines the current generation state\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeRenderGraphBuildState): boolean {\r\n        if (this._buildId === state.buildId) {\r\n            return true;\r\n        }\r\n\r\n        this._buildId = state.buildId;\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state._notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                block.build(state);\r\n            }\r\n        }\r\n\r\n        this._customBuildStep(state);\r\n\r\n        // Logs\r\n        if (state.verbose) {\r\n            Logger.Log(`Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        if (this._frameGraphTask) {\r\n            this._frameGraphTask.name = this.name;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        if (this._frameGraphTask) {\r\n            this._frameGraphTask.dependencies = undefined;\r\n\r\n            const dependenciesConnectedPoint = this.getInputByName(\"dependencies\")?.connectedPoint;\r\n            if (dependenciesConnectedPoint) {\r\n                if (dependenciesConnectedPoint.type === NodeRenderGraphBlockConnectionPointTypes.ResourceContainer) {\r\n                    const container = dependenciesConnectedPoint.ownerBlock as NodeRenderGraphResourceContainerBlock;\r\n                    for (let i = 0; i < container.inputs.length; i++) {\r\n                        const input = container.inputs[i];\r\n                        if (input.connectedPoint && input.connectedPoint.value !== undefined && NodeRenderGraphConnectionPoint.IsTextureHandle(input.connectedPoint.value)) {\r\n                            this._frameGraphTask.dependencies = this._frameGraphTask.dependencies || new Set();\r\n                            this._frameGraphTask.dependencies.add(input.connectedPoint.value as FrameGraphTextureHandle);\r\n                        }\r\n                    }\r\n                } else if (NodeRenderGraphConnectionPoint.IsTextureHandle(dependenciesConnectedPoint.value)) {\r\n                    this._frameGraphTask.dependencies = this._frameGraphTask.dependencies || new Set();\r\n                    this._frameGraphTask.dependencies.add(dependenciesConnectedPoint.value as FrameGraphTextureHandle);\r\n                }\r\n            }\r\n            this._frameGraph.addTask(this._frameGraphTask);\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n            this._inputs[inputIndex0]._isMainLinkSource = true;\r\n        }\r\n\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     */\r\n    public initialize() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     */\r\n    public autoConfigure() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.visibleOnFrame = this.visibleOnFrame;\r\n        serializationObject.disabled = this.disabled;\r\n        if (this._additionalConstructionParameters) {\r\n            serializationObject.additionalConstructionParameters = this._additionalConstructionParameters;\r\n        }\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _deserialize(serializationObject: any) {\r\n        this._name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleOnFrame = serializationObject.visibleOnFrame;\r\n        this.disabled = serializationObject.disabled;\r\n\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any) => {\r\n                const input = this.inputs.find((i) => i.name === port.name);\r\n                if (!input) {\r\n                    return;\r\n                }\r\n                if (port.displayName) {\r\n                    input.displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    input.isExposedOnFrame = port.isExposedOnFrame;\r\n                    input.exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n${variableName}.disabled = ${this.disabled};\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeRenderGraphBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeRenderGraphBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        let codeString = `\\n// ${this.getClassName()}\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\n`;\r\n        }\r\n        const className = this.getClassName();\r\n        if (className === \"RenderGraphInputBlock\") {\r\n            const block = this as unknown as NodeRenderGraphInputBlock;\r\n            const blockType = block.type;\r\n\r\n            codeString += `var ${this._codeVariableName} = new BABYLON.NodeRenderGraphInputBlock(\"${this.name}\", nodeRenderGraph.frameGraph, scene, BABYLON.NodeRenderGraphBlockConnectionPointTypes.${NodeRenderGraphBlockConnectionPointTypes[blockType]});\\n`;\r\n        } else {\r\n            if (this._additionalConstructionParameters) {\r\n                codeString += `var ${this._codeVariableName} = new BABYLON.${className}(\"${this.name}\", nodeRenderGraph.frameGraph, scene, ...${JSON.stringify(this._additionalConstructionParameters)});\\n`;\r\n            } else {\r\n                codeString += `var ${this._codeVariableName} = new BABYLON.${className}(\"${this.name}\", nodeRenderGraph.frameGraph, scene);\\n`;\r\n            }\r\n        }\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode() + \"\\n\";\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone() {\r\n        const serializationObject = this.serialize();\r\n        const blockType: typeof NodeRenderGraphBlock = GetClass(serializationObject.customType);\r\n\r\n        if (blockType) {\r\n            const additionalConstructionParameters = serializationObject.additionalConstructionParameters;\r\n            const block: NodeRenderGraphBlock = additionalConstructionParameters\r\n                ? new blockType(\"\", this._frameGraph, this._scene, ...additionalConstructionParameters)\r\n                : new blockType(\"\", this._frameGraph, this._scene);\r\n            block._deserialize(serializationObject);\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n\r\n        this._frameGraphTask?.dispose();\r\n        this._frameGraphTask = undefined as any;\r\n\r\n        this.onBuildObservable.clear();\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, FrameGraphContext, IFrameGraphPass, FrameGraphTask } from \"core/index\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class FrameGraphPass<T extends FrameGraphContext> implements IFrameGraphPass {\r\n    private _executeFunc: (context: T) => void;\r\n\r\n    public disabled = false;\r\n\r\n    constructor(\r\n        public name: string,\r\n        protected readonly _parentTask: FrameGraphTask,\r\n        protected readonly _context: T\r\n    ) {}\r\n\r\n    public setExecuteFunc(func: (context: T) => void) {\r\n        this._executeFunc = func;\r\n    }\r\n\r\n    public _execute() {\r\n        if (!this.disabled) {\r\n            this._executeFunc(this._context);\r\n        }\r\n    }\r\n\r\n    public _isValid(): Nullable<string> {\r\n        return this._executeFunc !== undefined ? null : \"Execute function is not set (call setExecuteFunc to set it)\";\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, AbstractEngine, IFrameGraphPass, FrameGraphContext, FrameGraphObjectList, FrameGraphTask } from \"core/index\";\r\nimport { FrameGraphPass } from \"./pass\";\r\n\r\n/**\r\n * Cull pass used to filter objects that are not visible.\r\n */\r\nexport class FrameGraphCullPass extends FrameGraphPass<FrameGraphContext> {\r\n    protected readonly _engine: AbstractEngine;\r\n    protected _objectList: FrameGraphObjectList;\r\n\r\n    /**\r\n     * Checks if a pass is a cull pass.\r\n     * @param pass The pass to check.\r\n     * @returns True if the pass is a cull pass, else false.\r\n     */\r\n    public static IsCullPass(pass: IFrameGraphPass): pass is FrameGraphCullPass {\r\n        return (pass as FrameGraphCullPass).setObjectList !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the object list used by the cull pass.\r\n     */\r\n    public get objectList(): FrameGraphObjectList {\r\n        return this._objectList;\r\n    }\r\n\r\n    /**\r\n     * Sets the object list to use for culling.\r\n     * @param objectList The object list to use for culling.\r\n     */\r\n    public setObjectList(objectList: FrameGraphObjectList) {\r\n        this._objectList = objectList;\r\n    }\r\n\r\n    /** @internal */\r\n    constructor(name: string, parentTask: FrameGraphTask, context: FrameGraphContext, engine: AbstractEngine) {\r\n        super(name, parentTask, context);\r\n        this._engine = engine;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _isValid(): Nullable<string> {\r\n        const errMsg = super._isValid();\r\n        return errMsg ? errMsg : this._objectList !== undefined ? null : \"Object list is not set (call setObjectList to set it)\";\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, FrameGraphRenderContext, AbstractEngine, IFrameGraphPass, FrameGraphTextureHandle, FrameGraphTask, FrameGraphRenderTarget } from \"core/index\";\r\nimport { FrameGraphPass } from \"./pass\";\r\n\r\n/**\r\n * Render pass used to render objects.\r\n */\r\nexport class FrameGraphRenderPass extends FrameGraphPass<FrameGraphRenderContext> {\r\n    protected readonly _engine: AbstractEngine;\r\n    protected _renderTarget: FrameGraphTextureHandle | FrameGraphTextureHandle[] | undefined;\r\n    protected _renderTargetDepth: FrameGraphTextureHandle | undefined;\r\n    protected _frameGraphRenderTarget: FrameGraphRenderTarget | undefined;\r\n    protected _dependencies: Set<FrameGraphTextureHandle> = new Set();\r\n\r\n    /**\r\n     * Checks if a pass is a render pass.\r\n     * @param pass The pass to check.\r\n     * @returns True if the pass is a render pass, else false.\r\n     */\r\n    public static IsRenderPass(pass: IFrameGraphPass): pass is FrameGraphRenderPass {\r\n        return (pass as FrameGraphRenderPass).setRenderTarget !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets the render target(s) used by the render pass.\r\n     */\r\n    public get renderTarget(): FrameGraphTextureHandle | FrameGraphTextureHandle[] | undefined {\r\n        return this._renderTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the render target depth used by the render pass.\r\n     */\r\n    public get renderTargetDepth(): FrameGraphTextureHandle | undefined {\r\n        return this._renderTargetDepth;\r\n    }\r\n\r\n    /** @internal */\r\n    constructor(name: string, parentTask: FrameGraphTask, context: FrameGraphRenderContext, engine: AbstractEngine) {\r\n        super(name, parentTask, context);\r\n        this._engine = engine;\r\n    }\r\n\r\n    /**\r\n     * Sets the render target(s) to use for rendering.\r\n     * @param renderTargetHandle The render target to use for rendering, or an array of render targets to use for multi render target rendering.\r\n     */\r\n    public setRenderTarget(renderTargetHandle?: FrameGraphTextureHandle | FrameGraphTextureHandle[]) {\r\n        this._renderTarget = renderTargetHandle;\r\n    }\r\n\r\n    /**\r\n     * Sets the render target depth to use for rendering.\r\n     * @param renderTargetHandle The render target depth to use for rendering.\r\n     */\r\n    public setRenderTargetDepth(renderTargetHandle?: FrameGraphTextureHandle) {\r\n        this._renderTargetDepth = renderTargetHandle;\r\n    }\r\n\r\n    /**\r\n     * Adds dependencies to the render pass.\r\n     * @param dependencies The dependencies to add.\r\n     */\r\n    public addDependencies(dependencies: FrameGraphTextureHandle | FrameGraphTextureHandle[]) {\r\n        if (Array.isArray(dependencies)) {\r\n            for (const dependency of dependencies) {\r\n                this._dependencies.add(dependency);\r\n            }\r\n        } else {\r\n            this._dependencies.add(dependencies);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Collects the dependencies of the render pass.\r\n     * @param dependencies The set of dependencies to update.\r\n     */\r\n    public collectDependencies(dependencies: Set<FrameGraphTextureHandle>): void {\r\n        const iterator = this._dependencies.keys();\r\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n            dependencies.add(key.value);\r\n        }\r\n\r\n        if (this._renderTarget) {\r\n            if (Array.isArray(this._renderTarget)) {\r\n                for (const handle of this._renderTarget) {\r\n                    if (handle !== undefined) {\r\n                        dependencies.add(handle);\r\n                    }\r\n                }\r\n            } else {\r\n                dependencies.add(this._renderTarget);\r\n            }\r\n        }\r\n\r\n        if (this._renderTargetDepth) {\r\n            dependencies.add(this._renderTargetDepth);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _execute() {\r\n        this._frameGraphRenderTarget = this._frameGraphRenderTarget || this._context.createRenderTarget(this.name, this._renderTarget, this._renderTargetDepth);\r\n\r\n        this._context.bindRenderTarget(this._frameGraphRenderTarget, `frame graph render pass - ${this.name}`);\r\n\r\n        super._execute();\r\n\r\n        this._context._flushDebugMessages();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _isValid(): Nullable<string> {\r\n        const errMsg = super._isValid();\r\n        return errMsg\r\n            ? errMsg\r\n            : this._renderTarget !== undefined || this.renderTargetDepth !== undefined\r\n              ? null\r\n              : \"Render target and render target depth cannot both be undefined.\";\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { FrameGraph, FrameGraphObjectList, IFrameGraphPass, Nullable, FrameGraphTextureHandle, InternalTexture, FrameGraphRenderContext } from \"core/index\";\r\nimport { FrameGraphCullPass } from \"./Passes/cullPass\";\r\nimport { FrameGraphRenderPass } from \"./Passes/renderPass\";\r\nimport { Observable } from \"core/Misc/observable\";\r\n\r\n/**\r\n * Represents a task in a frame graph.\r\n * @experimental\r\n */\r\nexport abstract class FrameGraphTask {\r\n    protected readonly _frameGraph: FrameGraph;\r\n\r\n    private readonly _passes: IFrameGraphPass[] = [];\r\n    private readonly _passesDisabled: IFrameGraphPass[] = [];\r\n\r\n    // Note: must be a getter/setter even if there's no specific processing, otherwise inherited classes can't make it a getter/setter!\r\n    // Same thing for the disabled property\r\n    protected _name: string;\r\n\r\n    /**\r\n     * The name of the task.\r\n     */\r\n    public get name() {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    protected _disabled = false;\r\n\r\n    /**\r\n     * Whether the task is disabled.\r\n     */\r\n    public get disabled() {\r\n        return this._disabled;\r\n    }\r\n\r\n    public set disabled(value: boolean) {\r\n        this._disabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the render passes of the task.\r\n     */\r\n    public get passes() {\r\n        return this._passes;\r\n    }\r\n\r\n    /**\r\n     * Gets the disabled render passes of the task.\r\n     */\r\n    public get passesDisabled() {\r\n        return this._passesDisabled;\r\n    }\r\n\r\n    /**\r\n     * The (texture) dependencies of the task (optional).\r\n     */\r\n    public dependencies?: Set<FrameGraphTextureHandle>;\r\n\r\n    /**\r\n     * Records the task in the frame graph. Use this function to add content (render passes, ...) to the task.\r\n     */\r\n    public abstract record(): void;\r\n\r\n    /**\r\n     * An observable that is triggered after the textures have been allocated.\r\n     */\r\n    public onTexturesAllocatedObservable: Observable<FrameGraphRenderContext> = new Observable();\r\n\r\n    /**\r\n     * Checks if the task is ready to be executed.\r\n     * @returns True if the task is ready to be executed, else false.\r\n     */\r\n    public isReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the task.\r\n     */\r\n    public dispose() {\r\n        this._reset();\r\n        this.onTexturesAllocatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Constructs a new frame graph task.\r\n     * @param name The name of the task.\r\n     * @param frameGraph The frame graph this task is associated with.\r\n     */\r\n    constructor(name: string, frameGraph: FrameGraph) {\r\n        this.name = name;\r\n        this._frameGraph = frameGraph;\r\n        this._reset();\r\n    }\r\n\r\n    /** @internal */\r\n    public _reset() {\r\n        this._passes.length = 0;\r\n        this._passesDisabled.length = 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _addPass(pass: IFrameGraphPass, disabled: boolean) {\r\n        if (disabled) {\r\n            this._passesDisabled.push(pass);\r\n        } else {\r\n            this._passes.push(pass);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkTask() {\r\n        let outputTexture: Nullable<Nullable<InternalTexture>[]> = null;\r\n        let outputDepthTexture: Nullable<InternalTexture> = null;\r\n        let outputObjectList: FrameGraphObjectList | undefined;\r\n\r\n        for (const pass of this._passes!) {\r\n            const errMsg = pass._isValid();\r\n            if (errMsg) {\r\n                throw new Error(`Pass \"${pass.name}\" is not valid. ${errMsg}`);\r\n            }\r\n            if (FrameGraphRenderPass.IsRenderPass(pass)) {\r\n                const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];\r\n                outputTexture = [];\r\n                for (const handle of handles) {\r\n                    if (handle !== undefined) {\r\n                        outputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));\r\n                    }\r\n                }\r\n                outputDepthTexture = pass.renderTargetDepth !== undefined ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;\r\n            } else if (FrameGraphCullPass.IsCullPass(pass)) {\r\n                outputObjectList = pass.objectList;\r\n            }\r\n        }\r\n\r\n        let disabledOutputTexture: Nullable<Nullable<InternalTexture>[]> = null;\r\n        let disabledOutputTextureHandle: (FrameGraphTextureHandle | undefined)[] = [];\r\n        let disabledOutputDepthTexture: Nullable<InternalTexture> = null;\r\n        let disabledOutputObjectList: FrameGraphObjectList | undefined;\r\n\r\n        for (const pass of this._passesDisabled!) {\r\n            const errMsg = pass._isValid();\r\n            if (errMsg) {\r\n                throw new Error(`Pass \"${pass.name}\" is not valid. ${errMsg}`);\r\n            }\r\n            if (FrameGraphRenderPass.IsRenderPass(pass)) {\r\n                const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];\r\n                disabledOutputTexture = [];\r\n                for (const handle of handles) {\r\n                    if (handle !== undefined) {\r\n                        disabledOutputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));\r\n                    }\r\n                }\r\n                disabledOutputTextureHandle = handles;\r\n                disabledOutputDepthTexture = pass.renderTargetDepth !== undefined ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;\r\n            } else if (FrameGraphCullPass.IsCullPass(pass)) {\r\n                disabledOutputObjectList = pass.objectList;\r\n            }\r\n        }\r\n\r\n        if (this._passesDisabled.length > 0) {\r\n            if (!this._checkSameRenderTarget(outputTexture, disabledOutputTexture)) {\r\n                let ok = true;\r\n                for (const handle of disabledOutputTextureHandle) {\r\n                    if (handle !== undefined && !this._frameGraph.textureManager.isHistoryTexture(handle)) {\r\n                        ok = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!ok) {\r\n                    throw new Error(`The output texture of the task \"${this.name}\" is different when it is enabled or disabled.`);\r\n                }\r\n            }\r\n            if (outputDepthTexture !== disabledOutputDepthTexture) {\r\n                throw new Error(`The output depth texture of the task \"${this.name}\" is different when it is enabled or disabled.`);\r\n            }\r\n            if (outputObjectList !== disabledOutputObjectList) {\r\n                throw new Error(`The output object list of the task \"${this.name}\" is different when it is enabled or disabled.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _getPasses(): IFrameGraphPass[] {\r\n        return this.disabled && this._passesDisabled.length > 0 ? this._passesDisabled : this._passes;\r\n    }\r\n\r\n    private _checkSameRenderTarget(src: Nullable<Nullable<InternalTexture>[]>, dst: Nullable<Nullable<InternalTexture>[]>) {\r\n        if (src === null || dst === null) {\r\n            return src === dst;\r\n        }\r\n\r\n        if (src.length !== dst.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < src.length; i++) {\r\n            if (src[i] !== dst[i]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "import type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { Layer } from \"./layer\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\r\nexport class LayerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_LAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: AbstractEngine;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);\r\n        this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);\r\n\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);\r\n        this.scene._afterRenderTargetPostProcessStage.registerStep(\r\n            SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER,\r\n            this,\r\n            this._drawRenderTargetForegroundWithoutPostProcessing\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        for (const layer of layers) {\r\n            layer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _draw(predicate: (layer: Layer) => boolean): void {\r\n        const layers = this.scene.layers;\r\n\r\n        if (layers.length) {\r\n            this._engine.setDepthBuffer(false);\r\n            for (const layer of layers) {\r\n                if (predicate(layer)) {\r\n                    layer.render();\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCameraPredicate(layer: Layer, isBackground: boolean, applyPostProcess: boolean, cameraLayerMask: number): boolean {\r\n        return (\r\n            !layer.renderOnlyInRenderTargetTextures &&\r\n            layer.isBackground === isBackground &&\r\n            layer.applyPostProcess === applyPostProcess &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawCameraBackground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, true, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForegroundWithPostProcessing(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForegroundWithoutPostProcessing(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, false, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetPredicate(layer: Layer, isBackground: boolean, applyPostProcess: boolean, cameraLayerMask: number, renderTargetTexture: RenderTargetTexture): boolean {\r\n        return (\r\n            layer.renderTargetTextures.length > 0 &&\r\n            layer.isBackground === isBackground &&\r\n            layer.applyPostProcess === applyPostProcess &&\r\n            layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawRenderTargetBackground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForegroundWithPostProcessing(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForegroundWithoutPostProcessing(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: IAssetContainer): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            this.scene.layers.push(layer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: IAssetContainer, dispose = false): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            const index = this.scene.layers.indexOf(layer);\r\n            if (index !== -1) {\r\n                this.scene.layers.splice(index, 1);\r\n            }\r\n            if (dispose) {\r\n                layer.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { LayerSceneComponent } from \"./layerSceneComponent\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * This represents a full screen 2d layer.\r\n * This can be useful to display a picture in the  background of your scene for instance.\r\n * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n */\r\nexport class Layer {\r\n    /**\r\n     * Force all the layers to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n    /**\r\n     * Define the texture the layer should display.\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Is the layer in background or foreground.\r\n     */\r\n    public isBackground: boolean;\r\n\r\n    private _applyPostProcess: boolean = true;\r\n    /**\r\n     * Determines if the layer is drawn before (true) or after (false) post-processing.\r\n     * If the layer is background, it is always before.\r\n     */\r\n    public set applyPostProcess(value: boolean) {\r\n        this._applyPostProcess = value;\r\n    }\r\n    public get applyPostProcess(): boolean {\r\n        return this.isBackground || this._applyPostProcess;\r\n    }\r\n\r\n    /**\r\n     * Define the color of the layer (instead of texture).\r\n     */\r\n    public color: Color4;\r\n\r\n    /**\r\n     * Define the scale of the layer in order to zoom in out of the texture.\r\n     */\r\n    public scale = new Vector2(1, 1);\r\n\r\n    /**\r\n     * Define an offset for the layer in order to shift the texture.\r\n     */\r\n    public offset = new Vector2(0, 0);\r\n\r\n    /**\r\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\r\n     */\r\n    public alphaBlendingMode = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Define if the layer should alpha test or alpha blend with the rest of the scene.\r\n     * Alpha test will not mix with the background color in case of transparency.\r\n     * It will either use the texture color or the background depending on the alpha value of the current pixel.\r\n     */\r\n    public alphaTest: boolean;\r\n\r\n    /**\r\n     * Define a mask to restrict the layer to only some of the scene cameras.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * Define the list of render target the layer is visible into.\r\n     */\r\n    public renderTargetTextures: RenderTargetTexture[] = [];\r\n\r\n    /**\r\n     * Define if the layer is only used in renderTarget or if it also\r\n     * renders in the main frame buffer of the canvas.\r\n     */\r\n    public renderOnlyInRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Define if the colors of the layer should be generated in linear space (default: false)\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Define if the layer is enabled (ie. should be displayed). Default: true\r\n     */\r\n    public isEnabled = true;\r\n\r\n    private _scene: Scene;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _drawWrapper: DrawWrapper;\r\n    private _previousDefines: string;\r\n\r\n    /**\r\n     * An event triggered when the layer is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<Layer>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onDisposeObservable existed.\r\n     * The set callback will be triggered when the layer has been disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the scene\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Layer>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onBeforeRenderObservable existed.\r\n     * The set callback will be triggered just before rendering the layer.\r\n     */\r\n    public set onBeforeRender(callback: () => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the scene\r\n     */\r\n    public onAfterRenderObservable = new Observable<Layer>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onAfterRenderObservable existed.\r\n     * The set callback will be triggered just after rendering the layer.\r\n     */\r\n    public set onAfterRender(callback: () => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /** Shader language used by the material */\r\n    private _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new layer.\r\n     * This represents a full screen 2d layer.\r\n     * This can be useful to display a picture in the  background of your scene for instance.\r\n     * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n     * @param name Define the name of the layer in the scene\r\n     * @param imgUrl Define the url of the texture to display in the layer\r\n     * @param scene Define the scene the layer belongs to\r\n     * @param isBackground Defines whether the layer is displayed in front or behind the scene\r\n     * @param color Defines a color for the layer\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the layer.\r\n         */\r\n        public name: string,\r\n        imgUrl: Nullable<string>,\r\n        scene: Nullable<Scene>,\r\n        isBackground?: boolean,\r\n        color?: Color4,\r\n        forceGLSL = false\r\n    ) {\r\n        this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\r\n        this.isBackground = isBackground === undefined ? true : isBackground;\r\n        this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\r\n\r\n        this._scene = <Scene>(scene || EngineStore.LastCreatedScene);\r\n        const engine = this._scene.getEngine();\r\n        if (engine.isWebGPU && !forceGLSL && !Layer.ForceGLSL) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n        }\r\n\r\n        let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER) as LayerSceneComponent;\r\n        if (!layerComponent) {\r\n            layerComponent = new LayerSceneComponent(this._scene);\r\n            this._scene._addComponent(layerComponent);\r\n        }\r\n        this._scene.layers.push(this);\r\n\r\n        this._drawWrapper = new DrawWrapper(engine);\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _shadersLoaded = false;\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Checks if the layer is ready to be rendered\r\n     * @returns true if the layer is ready. False otherwise.\r\n     */\r\n    public isReady() {\r\n        const engine = this._scene.getEngine();\r\n\r\n        let defines = \"\";\r\n\r\n        if (this.alphaTest) {\r\n            defines = \"#define ALPHATEST\";\r\n        }\r\n\r\n        if (this.texture) {\r\n            if (this.texture.gammaSpace) {\r\n                if (this.convertToLinearSpace) {\r\n                    defines += \"\\n#define CONVERT_TO_LINEAR\";\r\n                }\r\n            } else if (!this.convertToLinearSpace) {\r\n                defines += \"\\n#define CONVERT_TO_GAMMA\";\r\n            }\r\n        }\r\n\r\n        if (this._previousDefines !== defines) {\r\n            this._previousDefines = defines;\r\n            this._drawWrapper.effect = engine.createEffect(\r\n                \"layer\",\r\n                [VertexBuffer.PositionKind],\r\n                [\"textureMatrix\", \"color\", \"scale\", \"offset\"],\r\n                [\"textureSampler\"],\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                this._shaderLanguage,\r\n                this._shadersLoaded\r\n                    ? undefined\r\n                    : async () => {\r\n                          if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                              await Promise.all([import(\"../ShadersWGSL/layer.vertex\"), import(\"../ShadersWGSL/layer.fragment\")]);\r\n                          } else {\r\n                              await Promise.all([import(\"../Shaders/layer.vertex\"), import(\"../Shaders/layer.fragment\")]);\r\n                          }\r\n                          this._shadersLoaded = true;\r\n                      }\r\n            );\r\n        }\r\n\r\n        const currentEffect = this._drawWrapper.effect;\r\n\r\n        return !!currentEffect?.isReady() && (!this.texture || this.texture.isReady());\r\n    }\r\n\r\n    /**\r\n     * Renders the layer in the scene.\r\n     */\r\n    public render(): void {\r\n        if (!this.isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Check\r\n        if (!this.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const currentEffect = this._drawWrapper.effect!;\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        engine.setState(false);\r\n\r\n        // Texture\r\n        if (this.texture) {\r\n            currentEffect.setTexture(\"textureSampler\", this.texture);\r\n            currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix());\r\n        }\r\n\r\n        // Color\r\n        currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\r\n\r\n        // Scale / offset\r\n        currentEffect.setVector2(\"offset\", this.offset);\r\n        currentEffect.setVector2(\"scale\", this.scale);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\r\n\r\n        // Draw order\r\n        if (!this.alphaTest) {\r\n            engine.setAlphaMode(this.alphaBlendingMode);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        } else {\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        this.onAfterRenderObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Disposes and releases the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            this.texture = null;\r\n        }\r\n\r\n        // Clean RTT list\r\n        this.renderTargetTextures = [];\r\n\r\n        // Remove from scene\r\n        const index = this._scene.layers.indexOf(this);\r\n        this._scene.layers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["NodeRenderGraphBlockConnectionPointTypes", "NodeRenderGraphConnectionPointCompatibilityStates", "NodeRenderGraphConnectionPointDirection"]
}
