{
  "version": 3,
  "sources": ["../../../dev/loaders/src/OBJ/mtlFileLoader.ts", "../../../dev/loaders/src/OBJ/solidParser.ts", "../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts", "../../../dev/loaders/src/OBJ/objFileLoader.ts", "../../../dev/loaders/src/STL/stlFileLoader.metadata.ts", "../../../dev/loaders/src/STL/stlFileLoader.ts", "../../../dev/loaders/src/SPLAT/splatFileLoader.metadata.ts", "../../../dev/loaders/src/SPLAT/splatFileLoader.ts"],
  "sourcesContent": ["import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n/**\r\n * Class reading and parsing the MTL file bundled with the obj file.\r\n */\r\nexport class MTLFileLoader {\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static INVERT_TEXTURE_Y = true;\r\n\r\n    /**\r\n     * All material loaded from the mtl will be set here\r\n     */\r\n    public materials: StandardMaterial[] = [];\r\n\r\n    /**\r\n     * This function will read the mtl file and create each material described inside\r\n     * This function could be improve by adding :\r\n     * -some component missing (Ni, Tf...)\r\n     * -including the specific options available\r\n     *\r\n     * @param scene defines the scene the material will be created in\r\n     * @param data defines the mtl data to parse\r\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\r\n     * @param assetContainer defines the asset container to store the material in (can be null)\r\n     */\r\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void {\r\n        if (data instanceof ArrayBuffer) {\r\n            return;\r\n        }\r\n\r\n        //Split the lines from the file\r\n        const lines = data.split(\"\\n\");\r\n        // whitespace char ie: [ \\t\\r\\n\\f]\r\n        const delimiter_pattern = /\\s+/;\r\n        //Array with RGB colors\r\n        let color: number[];\r\n        //New material\r\n        let material: Nullable<StandardMaterial> = null;\r\n\r\n        //Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n\r\n            // Blank line or comment\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            //Get the first parameter (keyword)\r\n            const pos = line.indexOf(\" \");\r\n            let key = pos >= 0 ? line.substring(0, pos) : line;\r\n            key = key.toLowerCase();\r\n\r\n            //Get the data following the key\r\n            const value: string = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\r\n\r\n            //This mtl keyword will create the new material\r\n            if (key === \"newmtl\") {\r\n                //Check if it is the first material.\r\n                // Materials specifications are described after this keyword.\r\n                if (material) {\r\n                    //Add the previous material in the material array.\r\n                    this.materials.push(material);\r\n                }\r\n                //Create a new material.\r\n                // value is the name of the material read in the mtl file\r\n\r\n                scene._blockEntityCollection = !!assetContainer;\r\n                material = new StandardMaterial(value, scene);\r\n                material._parentContainer = assetContainer;\r\n                scene._blockEntityCollection = false;\r\n            } else if (key === \"kd\" && material) {\r\n                // Diffuse color (color under white light) using RGB values\r\n\r\n                //value  = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.diffuseColor = Color3.FromArray(color);\r\n            } else if (key === \"ka\" && material) {\r\n                // Ambient color (color under shadow) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.ambientColor = Color3.FromArray(color);\r\n            } else if (key === \"ks\" && material) {\r\n                // Specular color (color when light is reflected from shiny surface) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set the color into the material\r\n                material.specularColor = Color3.FromArray(color);\r\n            } else if (key === \"ke\" && material) {\r\n                // Emissive color using RGB values\r\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\r\n                material.emissiveColor = Color3.FromArray(color);\r\n            } else if (key === \"ns\" && material) {\r\n                //value = \"Integer\"\r\n                material.specularPower = parseFloat(value);\r\n            } else if (key === \"d\" && material) {\r\n                //d is dissolve for current material. It mean alpha for BABYLON\r\n                material.alpha = parseFloat(value);\r\n\r\n                //Texture\r\n                //This part can be improved by adding the possible options of texture\r\n            } else if (key === \"map_ka\" && material) {\r\n                // ambient texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_kd\" && material) {\r\n                // Diffuse texture map with a loaded image\r\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ks\" && material) {\r\n                // Specular texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ns\") {\r\n                //Specular\r\n                //Specular highlight component\r\n                //We must first get the folder of the image\r\n                //\r\n                //Not supported by BABYLON\r\n                //\r\n                //    continue;\r\n            } else if (key === \"map_bump\" && material) {\r\n                //The bump texture\r\n                const values = value.split(delimiter_pattern);\r\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\r\n                let bumpMultiplier: Nullable<string> = null;\r\n\r\n                if (bumpMultiplierIndex >= 0) {\r\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\r\n                    values.splice(bumpMultiplierIndex, 2); // remove\r\n                }\r\n\r\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\r\n                if (material.bumpTexture && bumpMultiplier !== null) {\r\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\r\n                }\r\n            } else if (key === \"map_d\" && material) {\r\n                // The dissolve of the material\r\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n\r\n                //Options for illumination\r\n            } else if (key === \"illum\") {\r\n                //Illumination\r\n                if (value === \"0\") {\r\n                    //That mean Kd == Kd\r\n                } else if (value === \"1\") {\r\n                    //Color on and Ambient on\r\n                } else if (value === \"2\") {\r\n                    //Highlight on\r\n                } else if (value === \"3\") {\r\n                    //Reflection on and Ray trace on\r\n                } else if (value === \"4\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace on\r\n                } else if (value === \"5\") {\r\n                    //Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"6\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n                } else if (value === \"7\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"8\") {\r\n                    //Reflection on and Ray trace off\r\n                } else if (value === \"9\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace off\r\n                } else if (value === \"10\") {\r\n                    //Casts shadows onto invisible surfaces\r\n                }\r\n            } else {\r\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\r\n            }\r\n        }\r\n        //At the end of the file, add the last material\r\n        if (material) {\r\n            this.materials.push(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture for the material.\r\n     *\r\n     * If the material is imported from input file,\r\n     * We sanitize the url to ensure it takes the texture from aside the material.\r\n     *\r\n     * @param rootUrl The root url to load from\r\n     * @param value The value stored in the mtl\r\n     * @param scene\r\n     * @returns The Texture\r\n     */\r\n    private static _GetTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\r\n        if (!value) {\r\n            return null;\r\n        }\r\n\r\n        let url = rootUrl;\r\n        // Load from input file.\r\n        if (rootUrl === \"file:\") {\r\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\r\n            if (lastDelimiter === -1) {\r\n                lastDelimiter = value.lastIndexOf(\"/\");\r\n            }\r\n\r\n            if (lastDelimiter > -1) {\r\n                url += value.substring(lastDelimiter + 1);\r\n            } else {\r\n                url += value;\r\n            }\r\n        }\r\n        // Not from input file.\r\n        else {\r\n            url += value;\r\n        }\r\n\r\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\r\n    }\r\n}\r\n", "import type { AssetContainer } from \"core/assetContainer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\ntype MeshObject = {\r\n    name: string;\r\n    indices: Nullable<Array<number>>;\r\n    positions: Nullable<Array<number>>;\r\n    normals: Nullable<Array<number>>;\r\n    colors: Nullable<Array<number>>;\r\n    uvs: Nullable<Array<number>>;\r\n    materialName: string;\r\n    directMaterial?: Nullable<Material>;\r\n    isObject: boolean; // If the entity is defined as an object (\"o\"), or group (\"g\")\r\n    _babylonMesh?: AbstractMesh; // The corresponding Babylon mesh\r\n    hasLines?: boolean; // If the mesh has lines\r\n};\r\n\r\n/**\r\n * Class used to load mesh data from OBJ content\r\n */\r\nexport class SolidParser {\r\n    // Descriptor\r\n    /** Object descriptor */\r\n    public static ObjectDescriptor = /^o/;\r\n    /** Group descriptor */\r\n    public static GroupDescriptor = /^g/;\r\n    /** Material lib descriptor */\r\n    public static MtlLibGroupDescriptor = /^mtllib /;\r\n    /** Use a material descriptor */\r\n    public static UseMtlDescriptor = /^usemtl /;\r\n    /** Smooth descriptor */\r\n    public static SmoothDescriptor = /^s /;\r\n\r\n    // Patterns\r\n    /** Pattern used to detect a vertex */\r\n    public static VertexPattern = /^v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\r\n    /** Pattern used to detect a normal */\r\n    public static NormalPattern = /^vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a UV set */\r\n    public static UVPattern = /^vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a first kind of face (f vertex vertex vertex) */\r\n    public static FacePattern1 = /^f\\s+(([\\d]{1,}[\\s]?){3,})+/;\r\n    /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\r\n    public static FacePattern2 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\r\n    public static FacePattern3 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\r\n    public static FacePattern4 = /^f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\r\n    public static FacePattern5 = /^f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a line(l vertex vertex) */\r\n    public static LinePattern1 = /^l\\s+(([\\d]{1,}[\\s]?){2,})+/;\r\n    /** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */\r\n    public static LinePattern2 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\r\n    /** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */\r\n    public static LinePattern3 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n    private _positions: Array<Vector3> = []; //values for the positions of vertices\r\n    private _normals: Array<Vector3> = []; //Values for the normals\r\n    private _uvs: Array<Vector2> = []; //Values for the textures\r\n    private _colors: Array<Color4> = [];\r\n    private _extColors: Array<Color4> = []; //Extension color\r\n    private _meshesFromObj: Array<MeshObject> = []; //[mesh] Contains all the obj meshes\r\n    private _handledMesh: MeshObject; //The current mesh of meshes array\r\n    private _indicesForBabylon: Array<number> = []; //The list of indices for VertexData\r\n    private _wrappedPositionForBabylon: Array<Vector3> = []; //The list of position in vectors\r\n    private _wrappedUvsForBabylon: Array<Vector2> = []; //Array with all value of uvs to match with the indices\r\n    private _wrappedColorsForBabylon: Array<Color4> = []; // Array with all color values to match with the indices\r\n    private _wrappedNormalsForBabylon: Array<Vector3> = []; //Array with all value of normals to match with the indices\r\n    private _tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\r\n    private _curPositionInIndices = 0;\r\n    private _hasMeshes: Boolean = false; //Meshes are defined in the file\r\n    private _unwrappedPositionsForBabylon: Array<number> = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\r\n    private _unwrappedColorsForBabylon: Array<number> = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\r\n    private _unwrappedNormalsForBabylon: Array<number> = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\r\n    private _unwrappedUVForBabylon: Array<number> = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\r\n    private _triangles: Array<string> = []; //Indices from new triangles coming from polygons\r\n    private _materialNameFromObj: string = \"\"; //The name of the current material\r\n    private _objMeshName: string = \"\"; //The name of the current obj mesh\r\n    private _increment: number = 1; //Id for meshes created by the multimaterial\r\n    private _isFirstMaterial: boolean = true;\r\n    private _grayColor = new Color4(0.5, 0.5, 0.5, 1);\r\n    private _materialToUse: string[];\r\n    private _babylonMeshesArray: Array<Mesh>;\r\n    private _pushTriangle: (faces: Array<string>, faceIndex: number) => void;\r\n    private _handednessSign: number;\r\n    private _hasLineData: boolean = false; //If this mesh has line segment(l) data\r\n\r\n    /**\r\n     * Creates a new SolidParser\r\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\r\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\r\n     * @param loadingOptions defines the loading options to use\r\n     */\r\n    public constructor(materialToUse: string[], babylonMeshesArray: Array<Mesh>, loadingOptions: OBJLoadingOptions) {\r\n        this._materialToUse = materialToUse;\r\n        this._babylonMeshesArray = babylonMeshesArray;\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    /**\r\n     * Search for obj in the given array.\r\n     * This function is called to check if a couple of data already exists in an array.\r\n     *\r\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\r\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\r\n     * @param obj Array<number>\r\n     * @returns {boolean}\r\n     */\r\n    private _isInArray(arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\r\n    }\r\n\r\n    private _isInArrayUV(arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\r\n            return arr[obj[0]].idx[idx];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This function set the data for each triangle.\r\n     * Data are position, normals and uvs\r\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\r\n     * If the tuple already exist, add only their indice\r\n     *\r\n     * @param indicePositionFromObj Integer The index in positions array\r\n     * @param indiceUvsFromObj Integer The index in uvs array\r\n     * @param indiceNormalFromObj Integer The index in normals array\r\n     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\r\n     * @param textureVectorFromOBJ Vector3 The value of uvs\r\n     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\r\n     * @param positionColorsFromOBJ\r\n     */\r\n    private _setData(\r\n        indicePositionFromObj: number,\r\n        indiceUvsFromObj: number,\r\n        indiceNormalFromObj: number,\r\n        positionVectorFromOBJ: Vector3,\r\n        textureVectorFromOBJ: Vector2,\r\n        normalsVectorFromOBJ: Vector3,\r\n        positionColorsFromOBJ?: Color4\r\n    ) {\r\n        //Check if this tuple already exists in the list of tuples\r\n        let _index: number;\r\n        if (this._loadingOptions.optimizeWithUV) {\r\n            _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\r\n        } else {\r\n            _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\r\n        }\r\n\r\n        //If it not exists\r\n        if (_index === -1) {\r\n            //Add an new indice.\r\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\r\n            //We add vertices data in this order\r\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\r\n            //Push the position of vertice for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedPositionForBabylon.push(positionVectorFromOBJ);\r\n            //Push the uvs for Babylon\r\n            //Each element is a Vector2(u,v)\r\n            //If the UVs are missing, set (u,v)=(0,0)\r\n            textureVectorFromOBJ = textureVectorFromOBJ ?? new Vector2(0, 0);\r\n            this._wrappedUvsForBabylon.push(textureVectorFromOBJ);\r\n            //Push the normals for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\r\n\r\n            if (positionColorsFromOBJ !== undefined) {\r\n                //Push the colors for Babylon\r\n                //Each element is a BABYLON.Color4(r,g,b,a)\r\n                this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\r\n            }\r\n\r\n            //Add the tuple in the comparison list\r\n            this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\r\n            this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\r\n            if (this._loadingOptions.optimizeWithUV) {\r\n                this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\r\n            }\r\n        } else {\r\n            //The tuple already exists\r\n            //Add the index of the already existing tuple\r\n            //At this index we can get the value of position, normal, color and uvs of vertex\r\n            this._indicesForBabylon.push(_index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\r\n     */\r\n    private _unwrapData() {\r\n        try {\r\n            //Every array has the same length\r\n            for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\r\n                //Push the x, y, z values of each element in the unwrapped array\r\n                this._unwrappedPositionsForBabylon.push(\r\n                    this._wrappedPositionForBabylon[l].x * this._handednessSign,\r\n                    this._wrappedPositionForBabylon[l].y,\r\n                    this._wrappedPositionForBabylon[l].z\r\n                );\r\n                this._unwrappedNormalsForBabylon.push(\r\n                    this._wrappedNormalsForBabylon[l].x * this._handednessSign,\r\n                    this._wrappedNormalsForBabylon[l].y,\r\n                    this._wrappedNormalsForBabylon[l].z\r\n                );\r\n\r\n                this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    //Push the r, g, b, a values of each element in the unwrapped array\r\n                    this._unwrappedColorsForBabylon.push(\r\n                        this._wrappedColorsForBabylon[l].r,\r\n                        this._wrappedColorsForBabylon[l].g,\r\n                        this._wrappedColorsForBabylon[l].b,\r\n                        this._wrappedColorsForBabylon[l].a\r\n                    );\r\n                }\r\n            }\r\n            // Reset arrays for the next new meshes\r\n            this._wrappedPositionForBabylon.length = 0;\r\n            this._wrappedNormalsForBabylon.length = 0;\r\n            this._wrappedUvsForBabylon.length = 0;\r\n            this._wrappedColorsForBabylon.length = 0;\r\n            this._tuplePosNorm.length = 0;\r\n            this._curPositionInIndices = 0;\r\n        } catch (e) {\r\n            throw new Error(\"Unable to unwrap data while parsing OBJ data.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create triangles from polygons\r\n     * It is important to notice that a triangle is a polygon\r\n     * We get 5 patterns of face defined in OBJ File :\r\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\r\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\r\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\r\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\r\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\r\n     * Each pattern is divided by the same method\r\n     * @param faces Array[String] The indices of elements\r\n     * @param v Integer The variable to increment\r\n     */\r\n    private _getTriangles(faces: Array<string>, v: number) {\r\n        //Work for each element of the array\r\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\r\n            //Add on the triangle variable the indexes to obtain triangles\r\n            this._pushTriangle(faces, faceIndex);\r\n        }\r\n\r\n        //Result obtained after 2 iterations:\r\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\r\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\r\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\r\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\r\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\r\n    }\r\n\r\n    /**\r\n     * To get color between color and extension color\r\n     * @param index Integer The index of the element in the array\r\n     * @returns value of target color\r\n     */\r\n    private _getColor(index: number) {\r\n        if (this._loadingOptions.importVertexColors) {\r\n            return this._extColors[index] ?? this._colors[index];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 1\r\n     * In this pattern we get vertice positions\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern1(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        //For each element in the triangles array.\r\n        //This var could contains 1 to an infinity of triangles\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                0,\r\n                0, // In the pattern 1, normals and uvs are not defined\r\n                this._positions[indicePositionFromObj], // Get the vectors data\r\n                Vector2.Zero(),\r\n                Vector3.Up(), // Create default vectors\r\n                this._getColor(indicePositionFromObj)\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 2\r\n     * In this pattern we get vertice positions and uvs\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern2(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1\"\r\n            //Split the data for getting position and uv\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\r\n            //Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            //Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                0, //Default value for normals\r\n                this._positions[indicePositionFromObj], //Get the values for each element\r\n                this._uvs[indiceUvsFromObj] ?? Vector2.Zero(),\r\n                Vector3.Up(), //Default value for normals\r\n                this._getColor(indicePositionFromObj)\r\n            );\r\n        }\r\n\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern3(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1/1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            // Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n            // Set normal indice\r\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj],\r\n                this._uvs[indiceUvsFromObj] ?? Vector2.Zero(),\r\n                this._normals[indiceNormalFromObj] ?? Vector3.Up() //Set the vector for each component\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 4\r\n     * In this pattern we get vertice positions and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern4(face: Array<string>, v: number) {\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1//1\"\r\n            //Split the data for getting position and normals\r\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\r\n            // We check indices, and normals\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                1, //Default value for uv\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj], //Get each vector of data\r\n                Vector2.Zero(),\r\n                this._normals[indiceNormalFromObj],\r\n                this._getColor(indicePositionFromObj)\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /*\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern5(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"-1/-1/-1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\r\n            // Set uv indice\r\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\r\n            // Set normal indice\r\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj],\r\n                this._uvs[indiceUvsFromObj],\r\n                this._normals[indiceNormalFromObj], //Set the vector for each component\r\n                this._getColor(indicePositionFromObj)\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    private _addPreviousObjMesh() {\r\n        //Check if it is not the first mesh. Otherwise we don't have data.\r\n        if (this._meshesFromObj.length > 0) {\r\n            //Get the previous mesh for applying the data about the faces\r\n            //=> in obj file, faces definition append after the name of the mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Set the data into Array for the mesh\r\n            this._unwrapData();\r\n\r\n            if (this._loadingOptions.useLegacyBehavior) {\r\n                // Reverse tab. Otherwise face are displayed in the wrong sens\r\n                this._indicesForBabylon.reverse();\r\n            }\r\n\r\n            //Set the information for the mesh\r\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\r\n            this._handledMesh.indices = this._indicesForBabylon.slice();\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\r\n            this._handledMesh.hasLines = this._hasLineData;\r\n\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\r\n            }\r\n\r\n            //Reset the array for the next mesh\r\n            this._indicesForBabylon.length = 0;\r\n            this._unwrappedPositionsForBabylon.length = 0;\r\n            this._unwrappedColorsForBabylon.length = 0;\r\n            this._unwrappedNormalsForBabylon.length = 0;\r\n            this._unwrappedUVForBabylon.length = 0;\r\n            this._hasLineData = false;\r\n        }\r\n    }\r\n\r\n    private _optimizeNormals(mesh: AbstractMesh): void {\r\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const mapVertices: { [key: string]: number[] } = {};\r\n\r\n        if (!positions || !normals) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < positions.length / 3; i++) {\r\n            const x = positions[i * 3 + 0];\r\n            const y = positions[i * 3 + 1];\r\n            const z = positions[i * 3 + 2];\r\n            const key = x + \"_\" + y + \"_\" + z;\r\n\r\n            let lst = mapVertices[key];\r\n            if (!lst) {\r\n                lst = [];\r\n                mapVertices[key] = lst;\r\n            }\r\n            lst.push(i);\r\n        }\r\n\r\n        const normal = new Vector3();\r\n        for (const key in mapVertices) {\r\n            const lst = mapVertices[key];\r\n            if (lst.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            const v0Idx = lst[0];\r\n            for (let i = 1; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\r\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\r\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\r\n            }\r\n\r\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\r\n            normal.normalize();\r\n\r\n            for (let i = 0; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[vIdx * 3 + 0] = normal.x;\r\n                normals[vIdx * 3 + 1] = normal.y;\r\n                normals[vIdx * 3 + 2] = normal.z;\r\n            }\r\n        }\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n    }\r\n\r\n    private static _IsLineElement(line: string) {\r\n        return line.startsWith(\"l\");\r\n    }\r\n\r\n    private static _IsObjectElement(line: string) {\r\n        return line.startsWith(\"o\");\r\n    }\r\n\r\n    private static _IsGroupElement(line: string) {\r\n        return line.startsWith(\"g\");\r\n    }\r\n\r\n    private static _GetZbrushMRGB(line: string, notParse: boolean) {\r\n        if (!line.startsWith(\"mrgb\")) return null;\r\n        line = line.replace(\"mrgb\", \"\").trim();\r\n        // if include vertex color , not load mrgb anymore\r\n        if (notParse) return [];\r\n        const regex = /[a-z0-9]/g;\r\n        const regArray = line.match(regex);\r\n        if (!regArray || regArray.length % 8 !== 0) {\r\n            return [];\r\n        }\r\n        const array: Color4[] = [];\r\n        for (let regIndex = 0; regIndex < regArray.length / 8; regIndex++) {\r\n            //each item is MMRRGGBB, m is material index\r\n            // const m = regArray[regIndex * 8 + 0] + regArray[regIndex * 8 + 1];\r\n            const r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];\r\n            const g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];\r\n            const b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];\r\n            array.push(new Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Function used to parse an OBJ string\r\n     * @param meshesNames defines the list of meshes to load (all if not defined)\r\n     * @param data defines the OBJ string\r\n     * @param scene defines the hosting scene\r\n     * @param assetContainer defines the asset container to load data in\r\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\r\n     */\r\n    public parse(meshesNames: any, data: string, scene: Scene, assetContainer: Nullable<AssetContainer>, onFileToLoadFound: (fileToLoad: string) => void): void {\r\n        //Move Santitize here to forbid delete zbrush data\r\n        // Sanitize data\r\n        data = data.replace(/#MRGB/g, \"mrgb\");\r\n        data = data.replace(/#.*$/gm, \"\").trim();\r\n        if (this._loadingOptions.useLegacyBehavior) {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n            this._handednessSign = 1;\r\n        } else if (scene.useRightHandedSystem) {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);\r\n            this._handednessSign = 1;\r\n        } else {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n            this._handednessSign = -1;\r\n        }\r\n\r\n        // Split the file into lines\r\n        // Preprocess line data\r\n        const linesOBJ = data.split(\"\\n\");\r\n        const lineLines: string[][] = [];\r\n        let currentGroup: string[] = [];\r\n\r\n        lineLines.push(currentGroup);\r\n\r\n        for (let i = 0; i < linesOBJ.length; i++) {\r\n            const line = linesOBJ[i].trim().replace(/\\s\\s/g, \" \");\r\n\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            if (SolidParser._IsGroupElement(line) || SolidParser._IsObjectElement(line)) {\r\n                currentGroup = [];\r\n                lineLines.push(currentGroup);\r\n            }\r\n\r\n            if (SolidParser._IsLineElement(line)) {\r\n                const lineValues = line.split(\" \");\r\n                // create line elements with two vertices only\r\n                for (let i = 1; i < lineValues.length - 1; i++) {\r\n                    currentGroup.push(`l ${lineValues[i]} ${lineValues[i + 1]}`);\r\n                }\r\n            } else {\r\n                currentGroup.push(line);\r\n            }\r\n        }\r\n\r\n        const lines = lineLines.flat();\r\n        // Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\r\n            let result;\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            } else if (SolidParser.VertexPattern.test(line)) {\r\n                //Get information about one position possible for the vertices\r\n                result = line.match(/[^ ]+/g)!; // match will return non-null due to passing regex pattern\r\n\r\n                // Value of result with line: \"v 1.0 2.0 3.0\"\r\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\r\n                // Create a Vector3 with the position x, y, z\r\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    if (result.length >= 7) {\r\n                        const r = parseFloat(result[4]);\r\n                        const g = parseFloat(result[5]);\r\n                        const b = parseFloat(result[6]);\r\n\r\n                        this._colors.push(\r\n                            new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7]))\r\n                        );\r\n                    } else {\r\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\r\n                        this._colors.push(this._grayColor);\r\n                    }\r\n                }\r\n            } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\r\n                //Create a Vector3 with the normals x, y, z\r\n                //Value of result\r\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n                //Add the Vector in the list of normals\r\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n            } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\r\n                //Create a Vector2 with the normals u, v\r\n                //Value of result\r\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\r\n                //Add the Vector in the list of uvs\r\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\r\n\r\n                //Identify patterns of faces\r\n                //Face could be defined in different type of pattern\r\n            } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern4(\r\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern5(\r\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"f 1 2 3\", \"1 2 3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\r\n                    1\r\n                );\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser.LinePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1 2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser.LinePattern2.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1/1 2/2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors))) {\r\n                result.forEach((element) => {\r\n                    this._extColors.push(element);\r\n                });\r\n            } else if ((result = SolidParser.LinePattern3.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1/1/1 2/2/2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\r\n                // Create a new mesh corresponding to the name of the group.\r\n                // Definition of the mesh\r\n                const objMesh: MeshObject = {\r\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\r\n                    indices: null,\r\n                    positions: null,\r\n                    normals: null,\r\n                    uvs: null,\r\n                    colors: null,\r\n                    materialName: this._materialNameFromObj,\r\n                    isObject: SolidParser.ObjectDescriptor.test(line),\r\n                };\r\n                this._addPreviousObjMesh();\r\n\r\n                //Push the last mesh created with only the name\r\n                this._meshesFromObj.push(objMesh);\r\n\r\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\r\n                this._hasMeshes = true;\r\n                this._isFirstMaterial = true;\r\n                this._increment = 1;\r\n                //Keyword for applying a material\r\n            } else if (SolidParser.UseMtlDescriptor.test(line)) {\r\n                //Get the name of the material\r\n                this._materialNameFromObj = line.substring(7).trim();\r\n\r\n                //If this new material is in the same mesh\r\n\r\n                if (!this._isFirstMaterial || !this._hasMeshes) {\r\n                    //Set the data for the previous mesh\r\n                    this._addPreviousObjMesh();\r\n                    //Create a new mesh\r\n                    const objMesh: MeshObject =\r\n                        //Set the name of the current obj mesh\r\n                        {\r\n                            name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\r\n                            indices: null,\r\n                            positions: null,\r\n                            normals: null,\r\n                            uvs: null,\r\n                            colors: null,\r\n                            materialName: this._materialNameFromObj,\r\n                            isObject: false,\r\n                        };\r\n                    this._increment++;\r\n                    //If meshes are already defined\r\n                    this._meshesFromObj.push(objMesh);\r\n                    this._hasMeshes = true;\r\n                }\r\n                //Set the material name if the previous line define a mesh\r\n\r\n                if (this._hasMeshes && this._isFirstMaterial) {\r\n                    //Set the material name to the previous mesh (1 material per mesh)\r\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\r\n                    this._isFirstMaterial = false;\r\n                }\r\n                // Keyword for loading the mtl file\r\n            } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\r\n                // Get the name of mtl file\r\n                onFileToLoadFound(line.substring(7).trim());\r\n\r\n                // Apply smoothing\r\n            } else if (SolidParser.SmoothDescriptor.test(line)) {\r\n                // smooth shading => apply smoothing\r\n                // Today I don't know it work with babylon and with obj.\r\n                // With the obj file  an integer is set\r\n            } else {\r\n                //If there is another possibility\r\n                Logger.Log(\"Unhandled expression at line : \" + line);\r\n            }\r\n        }\r\n        // At the end of the file, add the last mesh into the meshesFromObj array\r\n        if (this._hasMeshes) {\r\n            // Set the data for the last mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            if (this._loadingOptions.useLegacyBehavior) {\r\n                //Reverse indices for displaying faces in the good sense\r\n                this._indicesForBabylon.reverse();\r\n            }\r\n\r\n            //Get the good array\r\n            this._unwrapData();\r\n            //Set array\r\n            this._handledMesh.indices = this._indicesForBabylon;\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon;\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon;\r\n            this._handledMesh.hasLines = this._hasLineData;\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\r\n            }\r\n        }\r\n\r\n        // If any o or g keyword not found, create a mesh with a random id\r\n        if (!this._hasMeshes) {\r\n            let newMaterial: Nullable<StandardMaterial> = null;\r\n            if (this._indicesForBabylon.length) {\r\n                if (this._loadingOptions.useLegacyBehavior) {\r\n                    // reverse tab of indices\r\n                    this._indicesForBabylon.reverse();\r\n                }\r\n\r\n                //Get positions normals uvs\r\n                this._unwrapData();\r\n            } else {\r\n                // There is no indices in the file. We will have to switch to point cloud rendering\r\n                for (const pos of this._positions) {\r\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\r\n                }\r\n\r\n                if (this._normals.length) {\r\n                    for (const normal of this._normals) {\r\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                }\r\n\r\n                if (this._uvs.length) {\r\n                    for (const uv of this._uvs) {\r\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\r\n                    }\r\n                }\r\n\r\n                if (this._extColors.length) {\r\n                    for (const color of this._extColors) {\r\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                    }\r\n                } else {\r\n                    if (this._colors.length) {\r\n                        for (const color of this._colors) {\r\n                            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!this._materialNameFromObj) {\r\n                    // Create a material with point cloud on\r\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\r\n\r\n                    newMaterial.pointsCloud = true;\r\n\r\n                    this._materialNameFromObj = newMaterial.name;\r\n\r\n                    if (!this._normals.length) {\r\n                        newMaterial.disableLighting = true;\r\n                        newMaterial.emissiveColor = Color3.White();\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Set data for one mesh\r\n            this._meshesFromObj.push({\r\n                name: Geometry.RandomId(),\r\n                indices: this._indicesForBabylon,\r\n                positions: this._unwrappedPositionsForBabylon,\r\n                colors: this._unwrappedColorsForBabylon,\r\n                normals: this._unwrappedNormalsForBabylon,\r\n                uvs: this._unwrappedUVForBabylon,\r\n                materialName: this._materialNameFromObj,\r\n                directMaterial: newMaterial,\r\n                isObject: true,\r\n                hasLines: this._hasLineData,\r\n            });\r\n        }\r\n\r\n        //Set data for each mesh\r\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\r\n            //check meshesNames (stlFileLoader)\r\n            if (meshesNames && this._meshesFromObj[j].name) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (this._meshesFromObj[j].name !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Get the current mesh\r\n            //Set the data with VertexBuffer for each mesh\r\n            this._handledMesh = this._meshesFromObj[j];\r\n            //Create a Mesh with the name of the obj mesh\r\n\r\n            scene._blockEntityCollection = !!assetContainer;\r\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\r\n            babylonMesh._parentContainer = assetContainer;\r\n            scene._blockEntityCollection = false;\r\n            this._handledMesh._babylonMesh = babylonMesh;\r\n            // If this is a group mesh, it should have an object mesh as a parent. So look for the first object mesh that appears before it.\r\n            if (!this._handledMesh.isObject) {\r\n                for (let k = j - 1; k >= 0; --k) {\r\n                    if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {\r\n                        babylonMesh.parent = this._meshesFromObj[k]._babylonMesh!;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Push the name of the material to an array\r\n            //This is indispensable for the importMesh function\r\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\r\n            //If the mesh is a line mesh\r\n            if (this._handledMesh.hasLines) {\r\n                babylonMesh._internalMetadata ??= {};\r\n                babylonMesh._internalMetadata[\"_isLine\"] = true; //this is a line mesh\r\n            }\r\n\r\n            if (this._handledMesh.positions?.length === 0) {\r\n                //Push the mesh into an array\r\n                this._babylonMeshesArray.push(babylonMesh);\r\n                continue;\r\n            }\r\n\r\n            const vertexData: VertexData = new VertexData(); //The container for the values\r\n            //Set the data for the babylonMesh\r\n            vertexData.uvs = this._handledMesh.uvs;\r\n            vertexData.indices = this._handledMesh.indices;\r\n            vertexData.positions = this._handledMesh.positions;\r\n            if (this._loadingOptions.computeNormals) {\r\n                const normals: Array<number> = new Array<number>();\r\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\r\n                vertexData.normals = normals;\r\n            } else {\r\n                vertexData.normals = this._handledMesh.normals;\r\n            }\r\n            if (this._loadingOptions.importVertexColors) {\r\n                vertexData.colors = this._handledMesh.colors;\r\n            }\r\n            //Set the data from the VertexBuffer to the current Mesh\r\n            vertexData.applyToMesh(babylonMesh);\r\n            if (this._loadingOptions.invertY) {\r\n                babylonMesh.scaling.y *= -1;\r\n            }\r\n            if (this._loadingOptions.optimizeNormals) {\r\n                this._optimizeNormals(babylonMesh);\r\n            }\r\n\r\n            //Push the mesh into an array\r\n            this._babylonMeshesArray.push(babylonMesh);\r\n\r\n            if (this._handledMesh.directMaterial) {\r\n                babylonMesh.material = this._handledMesh.directMaterial;\r\n            }\r\n        }\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const OBJFileLoaderMetadata = {\r\n    name: \"obj\",\r\n    extensions: \".obj\",\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderAsyncResult } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport { OBJFileLoaderMetadata } from \"./objFileLoader.metadata\";\r\nimport { MTLFileLoader } from \"./mtlFileLoader\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { SolidParser } from \"./solidParser\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the obj loader.\r\n         */\r\n        [OBJFileLoaderMetadata.name]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * OBJ file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class OBJFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines if UVs are optimized by default during load.\r\n     */\r\n    public static OPTIMIZE_WITH_UV = true;\r\n    /**\r\n     * Invert model on y-axis (does a model scaling inversion)\r\n     */\r\n    public static INVERT_Y = false;\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static get INVERT_TEXTURE_Y() {\r\n        return MTLFileLoader.INVERT_TEXTURE_Y;\r\n    }\r\n\r\n    public static set INVERT_TEXTURE_Y(value: boolean) {\r\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\r\n    }\r\n\r\n    /**\r\n     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\r\n     */\r\n    public static IMPORT_VERTEX_COLORS = false;\r\n    /**\r\n     * Compute the normals for the model, even if normals are present in the file.\r\n     */\r\n    public static COMPUTE_NORMALS = false;\r\n    /**\r\n     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\r\n     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\r\n     */\r\n    public static OPTIMIZE_NORMALS = false;\r\n    /**\r\n     * Defines custom scaling of UV coordinates of loaded meshes.\r\n     */\r\n    public static UV_SCALING = new Vector2(1, 1);\r\n    /**\r\n     * Skip loading the materials even if defined in the OBJ file (materials are ignored).\r\n     */\r\n    public static SKIP_MATERIALS = false;\r\n\r\n    /**\r\n     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\r\n     *\r\n     * Defaults to true for backwards compatibility.\r\n     */\r\n    public static MATERIAL_LOADING_FAILS_SILENTLY = true;\r\n\r\n    /**\r\n     * Loads assets without handedness conversions. This flag is for compatibility. Use it only if absolutely required. Defaults to false.\r\n     */\r\n    public static USE_LEGACY_BEHAVIOR = false;\r\n\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = OBJFileLoaderMetadata.name;\r\n    /**\r\n     * Defines the extension the plugin is able to load.\r\n     */\r\n    public readonly extensions = OBJFileLoaderMetadata.extensions;\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n\r\n    /**\r\n     * Creates loader for .OBJ files\r\n     *\r\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\r\n     */\r\n    constructor(loadingOptions?: OBJLoadingOptions) {\r\n        this._loadingOptions = loadingOptions || OBJFileLoader._DefaultLoadingOptions;\r\n    }\r\n\r\n    private static get _DefaultLoadingOptions(): OBJLoadingOptions {\r\n        return {\r\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\r\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\r\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\r\n            invertY: OBJFileLoader.INVERT_Y,\r\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            UVScaling: OBJFileLoader.UV_SCALING,\r\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\r\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\r\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\r\n            useLegacyBehavior: OBJFileLoader.USE_LEGACY_BEHAVIOR,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calls synchronously the MTL file attached to this obj.\r\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\r\n     * Without this function materials are not displayed in the first frame (but displayed after).\r\n     * In consequence it is impossible to get material information in your HTML file\r\n     *\r\n     * @param url The URL of the MTL file\r\n     * @param rootUrl defines where to load data from\r\n     * @param onSuccess Callback function to be called when the MTL file is loaded\r\n     * @param onFailure\r\n     */\r\n    private _loadMTL(\r\n        url: string,\r\n        rootUrl: string,\r\n        onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any,\r\n        onFailure: (pathOfFile: string, exception?: any) => void\r\n    ) {\r\n        //The complete path to the mtl file\r\n        const pathOfFile = rootUrl + url;\r\n\r\n        // Loads through the babylon tools to allow fileInput search.\r\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request?: WebRequest | undefined, exception?: any) => {\r\n            onFailure(pathOfFile, exception);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Instantiates a OBJ file loader plugin.\r\n     * @returns the created plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\r\n        return new OBJFileLoader(OBJFileLoader._DefaultLoadingOptions);\r\n    }\r\n\r\n    /**\r\n     * If the data string can be loaded directly.\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    public canDirectLoad(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<ISceneLoaderAsyncResult> {\r\n        //get the meshes from OBJ file\r\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n                spriteManagers: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return this.importMeshAsync(null, scene, data, rootUrl)\r\n            .then((result) => {\r\n                result.meshes.forEach((mesh) => container.meshes.push(mesh));\r\n                result.meshes.forEach((mesh) => {\r\n                    const material = mesh.material;\r\n                    if (material) {\r\n                        // Materials\r\n                        if (container.materials.indexOf(material) == -1) {\r\n                            container.materials.push(material);\r\n\r\n                            // Textures\r\n                            const textures = material.getActiveTextures();\r\n                            textures.forEach((t) => {\r\n                                if (container.textures.indexOf(t) == -1) {\r\n                                    container.textures.push(t);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n                this._assetContainer = null;\r\n                return container;\r\n            })\r\n            .catch((ex) => {\r\n                this._assetContainer = null;\r\n                throw ex;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Read the OBJ file and create an Array of meshes.\r\n     * Each mesh contains all information given by the OBJ and the MTL file.\r\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\r\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene defines the scene where are displayed the data\r\n     * @param data defines the content of the obj file\r\n     * @param rootUrl defines the path to the folder\r\n     * @returns the list of loaded meshes\r\n     */\r\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        let fileToLoad: string = \"\"; //The name of the mtlFile to load\r\n        const materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\r\n        const materialToUse: string[] = [];\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        // Sanitize data\r\n        data = data.replace(/#.*$/gm, \"\").trim();\r\n\r\n        // Main function\r\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\r\n\r\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName: string) => {\r\n            fileToLoad = fileName;\r\n        });\r\n\r\n        // load the materials\r\n        const mtlPromises: Array<Promise<void>> = [];\r\n        // Check if we have a file to load\r\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\r\n            //Load the file synchronously\r\n            mtlPromises.push(\r\n                new Promise((resolve, reject) => {\r\n                    this._loadMTL(\r\n                        fileToLoad,\r\n                        rootUrl,\r\n                        (dataLoaded) => {\r\n                            try {\r\n                                //Create materials thanks MTLLoader function\r\n                                materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\r\n                                //Look at each material loaded in the mtl file\r\n                                for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\r\n                                    //Three variables to get all meshes with the same material\r\n                                    let startIndex = 0;\r\n                                    const _indices = [];\r\n                                    let _index;\r\n\r\n                                    //The material from MTL file is used in the meshes loaded\r\n                                    //Push the indice in an array\r\n                                    //Check if the material is not used for another mesh\r\n                                    while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\r\n                                        _indices.push(_index);\r\n                                        startIndex = _index + 1;\r\n                                    }\r\n                                    //If the material is not used dispose it\r\n                                    if (_index === -1 && _indices.length === 0) {\r\n                                        //If the material is not needed, remove it\r\n                                        materialsFromMTLFile.materials[n].dispose();\r\n                                    } else {\r\n                                        for (let o = 0; o < _indices.length; o++) {\r\n                                            //Apply the material to the Mesh for each mesh with the material\r\n                                            const mesh = babylonMeshesArray[_indices[o]];\r\n                                            const material = materialsFromMTLFile.materials[n];\r\n                                            mesh.material = material;\r\n\r\n                                            if (!mesh.getTotalIndices()) {\r\n                                                // No indices, we need to turn on point cloud\r\n                                                material.pointsCloud = true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                resolve();\r\n                            } catch (e) {\r\n                                Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\r\n                                if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                    resolve();\r\n                                } else {\r\n                                    reject(e);\r\n                                }\r\n                            }\r\n                        },\r\n                        (pathOfFile: string, exception?: any) => {\r\n                            Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\r\n                            if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                resolve();\r\n                            } else {\r\n                                reject(exception);\r\n                            }\r\n                        }\r\n                    );\r\n                })\r\n            );\r\n        }\r\n        //Return an array with all Mesh\r\n        return Promise.all(mtlPromises).then(() => {\r\n            const isLine = (mesh: AbstractMesh) => Boolean(mesh._internalMetadata?.[\"_isLine\"] ?? false);\r\n\r\n            // Iterate over the mesh, determine if it is a line mesh, clone or modify the material to line rendering.\r\n            babylonMeshesArray.forEach((mesh) => {\r\n                if (isLine(mesh)) {\r\n                    let mat = mesh.material ?? new StandardMaterial(mesh.name + \"_line\", scene);\r\n                    // If another mesh is using this material and it is not a line then we need to clone it.\r\n                    const needClone = mat.getBindedMeshes().filter((e) => !isLine(e)).length > 0;\r\n                    if (needClone) {\r\n                        mat = mat.clone(mat.name + \"_line\") ?? mat;\r\n                    }\r\n                    mat.wireframe = true;\r\n                    mesh.material = mat;\r\n                    if (mesh._internalMetadata) {\r\n                        mesh._internalMetadata[\"_isLine\"] = undefined;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return babylonMeshesArray;\r\n        });\r\n    }\r\n}\r\n\r\n//Add this loader into the register plugin\r\nRegisterSceneLoaderPlugin(new OBJFileLoader());\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { ISceneLoaderPluginExtensions, ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const STLFileLoaderMetadata = {\r\n    name: \"stl\",\r\n\r\n    extensions: {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".stl\": { isBinary: true },\r\n    } as const satisfies ISceneLoaderPluginExtensions,\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { ISceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { STLFileLoaderMetadata } from \"./stlFileLoader.metadata\";\r\nimport \"core/Materials/standardMaterial\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the stl loader.\r\n         */\r\n        [STLFileLoaderMetadata.name]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * STL file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class STLFileLoader implements ISceneLoaderPlugin {\r\n    /** @internal */\r\n    public solidPattern = /solid (\\S*)([\\S\\s]*?)endsolid[ ]*(\\S*)/g;\r\n\r\n    /** @internal */\r\n    public facetsPattern = /facet([\\s\\S]*?)endfacet/g;\r\n    /** @internal */\r\n    public normalPattern = /normal[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\r\n    /** @internal */\r\n    public vertexPattern = /vertex[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\r\n\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = STLFileLoaderMetadata.name;\r\n\r\n    /**\r\n     * Defines the extensions the stl loader is able to load.\r\n     * force data to come in as an ArrayBuffer\r\n     * we'll convert to string if it looks like it's an ASCII .stl\r\n     */\r\n    public readonly extensions = STLFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Defines if Y and Z axes are swapped or not when loading an STL file.\r\n     * The default is false to maintain backward compatibility. When set to\r\n     * true, coordinates from the STL file are used without change.\r\n     */\r\n    public static DO_NOT_ALTER_FILE_COORDINATES = false;\r\n\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    public importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: Nullable<AbstractMesh[]>): boolean {\r\n        let matches;\r\n\r\n        if (typeof data !== \"string\") {\r\n            if (this._isBinary(data)) {\r\n                // binary .stl\r\n                const babylonMesh = new Mesh(\"stlmesh\", scene);\r\n                this._parseBinary(babylonMesh, data);\r\n                if (meshes) {\r\n                    meshes.push(babylonMesh);\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // ASCII .stl\r\n\r\n            // convert to string\r\n            data = new TextDecoder().decode(new Uint8Array(data));\r\n        }\r\n\r\n        //if arrived here, data is a string, containing the STLA data.\r\n\r\n        while ((matches = this.solidPattern.exec(data))) {\r\n            let meshName = matches[1];\r\n            const meshNameFromEnd = matches[3];\r\n            if (meshNameFromEnd && meshName != meshNameFromEnd) {\r\n                Tools.Error(\"Error in STL, solid name != endsolid name\");\r\n                return false;\r\n            }\r\n\r\n            // check meshesNames\r\n            if (meshesNames && meshName) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (!meshesNames.indexOf(meshName)) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (meshName !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // stl mesh name can be empty as well\r\n            meshName = meshName || \"stlmesh\";\r\n\r\n            const babylonMesh = new Mesh(meshName, scene);\r\n            this._parseASCII(babylonMesh, matches[2]);\r\n            if (meshes) {\r\n                meshes.push(babylonMesh);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns true if successful or false otherwise\r\n     */\r\n    public load(scene: Scene, data: any, rootUrl: string): boolean {\r\n        const result = this.importMesh(null, scene, data, rootUrl, null);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainer(scene: Scene, data: string, rootUrl: string): AssetContainer {\r\n        const container = new AssetContainer(scene);\r\n        scene._blockEntityCollection = true;\r\n        this.importMesh(null, scene, data, rootUrl, container.meshes);\r\n        scene._blockEntityCollection = false;\r\n        return container;\r\n    }\r\n\r\n    private _isBinary(data: any) {\r\n        // check if file size is correct for binary stl\r\n        const reader = new DataView(data);\r\n\r\n        // A Binary STL header is 80 bytes, if the data size is not great than\r\n        // that then it's not a binary STL.\r\n        if (reader.byteLength <= 80) {\r\n            return false;\r\n        }\r\n\r\n        const faceSize = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8;\r\n        const nFaces = reader.getUint32(80, true);\r\n\r\n        if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {\r\n            return true;\r\n        }\r\n\r\n        // US-ASCII begin with 's', 'o', 'l', 'i', 'd'\r\n        const ascii = [115, 111, 108, 105, 100];\r\n        for (let off = 0; off < 5; off++) {\r\n            if (reader.getUint8(off) !== ascii[off]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _parseBinary(mesh: Mesh, data: ArrayBuffer) {\r\n        const reader = new DataView(data);\r\n        const faces = reader.getUint32(80, true);\r\n\r\n        const dataOffset = 84;\r\n        const faceLength = 12 * 4 + 2;\r\n\r\n        let offset = 0;\r\n\r\n        const positions = new Float32Array(faces * 3 * 3);\r\n        const normals = new Float32Array(faces * 3 * 3);\r\n        const indices = new Uint32Array(faces * 3);\r\n        let indicesCount = 0;\r\n\r\n        for (let face = 0; face < faces; face++) {\r\n            const start = dataOffset + face * faceLength;\r\n            const normalX = reader.getFloat32(start, true);\r\n            const normalY = reader.getFloat32(start + 4, true);\r\n            const normalZ = reader.getFloat32(start + 8, true);\r\n\r\n            for (let i = 1; i <= 3; i++) {\r\n                const vertexstart = start + i * 12;\r\n\r\n                // ordering is intentional to match ascii import\r\n                positions[offset] = reader.getFloat32(vertexstart, true);\r\n                normals[offset] = normalX;\r\n\r\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);\r\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);\r\n\r\n                    normals[offset + 2] = normalY;\r\n                    normals[offset + 1] = normalZ;\r\n                } else {\r\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);\r\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);\r\n\r\n                    normals[offset + 1] = normalY;\r\n                    normals[offset + 2] = normalZ;\r\n                }\r\n\r\n                offset += 3;\r\n            }\r\n\r\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                indices[indicesCount] = indicesCount;\r\n                indices[indicesCount + 1] = indicesCount + 2;\r\n                indices[indicesCount + 2] = indicesCount + 1;\r\n                indicesCount += 3;\r\n            } else {\r\n                indices[indicesCount] = indicesCount++;\r\n                indices[indicesCount] = indicesCount++;\r\n                indices[indicesCount] = indicesCount++;\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        mesh.setIndices(indices);\r\n        mesh.computeWorldMatrix(true);\r\n    }\r\n\r\n    private _parseASCII(mesh: Mesh, solidData: string) {\r\n        const positions = [];\r\n        const normals = [];\r\n        const indices = [];\r\n        let indicesCount = 0;\r\n\r\n        //load facets, ignoring loop as the standard doesn't define it can contain more than vertices\r\n        let matches;\r\n        while ((matches = this.facetsPattern.exec(solidData))) {\r\n            const facet = matches[1];\r\n            //one normal per face\r\n            const normalMatches = this.normalPattern.exec(facet);\r\n            this.normalPattern.lastIndex = 0;\r\n            if (!normalMatches) {\r\n                continue;\r\n            }\r\n            const normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];\r\n\r\n            let vertexMatch;\r\n            while ((vertexMatch = this.vertexPattern.exec(facet))) {\r\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));\r\n                    normals.push(normal[0], normal[1], normal[2]);\r\n                } else {\r\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));\r\n\r\n                    // Flipping the second and third component because inverted\r\n                    // when normal was declared.\r\n                    normals.push(normal[0], normal[2], normal[1]);\r\n                }\r\n            }\r\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\r\n                indicesCount += 3;\r\n            } else {\r\n                indices.push(indicesCount++, indicesCount++, indicesCount++);\r\n            }\r\n            this.vertexPattern.lastIndex = 0;\r\n        }\r\n\r\n        this.facetsPattern.lastIndex = 0;\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        mesh.setIndices(indices);\r\n        mesh.computeWorldMatrix(true);\r\n    }\r\n}\r\n\r\nRegisterSceneLoaderPlugin(new STLFileLoader());\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { ISceneLoaderPluginExtensions, ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const SPLATFileLoaderMetadata = {\r\n    name: \"splat\",\r\n\r\n    extensions: {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".splat\": { isBinary: true },\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".ply\": { isBinary: true },\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".spz\": { isBinary: true },\r\n    } as const satisfies ISceneLoaderPluginExtensions,\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n", "import type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderAsyncResult, ISceneLoaderProgressEvent, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { SPLATFileLoaderMetadata } from \"./splatFileLoader.metadata\";\r\nimport { GaussianSplattingMesh } from \"core/Meshes/GaussianSplatting/gaussianSplattingMesh\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { PointsCloudSystem } from \"core/Particles/pointsCloudSystem\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { SPLATLoadingOptions } from \"./splatLoadingOptions\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the splat loader.\r\n         */\r\n        [SPLATFileLoaderMetadata.name]: Partial<SPLATLoadingOptions>;\r\n    }\r\n}\r\n\r\n/**\r\n * Indicator of the parsed ply buffer. A standard ready to use splat or an array of positions for a point cloud\r\n */\r\nconst enum Mode {\r\n    Splat = 0,\r\n    PointCloud = 1,\r\n    Mesh = 2,\r\n    Reject = 3,\r\n}\r\n\r\n/**\r\n * A parsed buffer and how to use it\r\n */\r\ninterface ParsedPLY {\r\n    data: ArrayBuffer;\r\n    mode: Mode;\r\n    faces?: number[];\r\n    hasVertexColors?: boolean;\r\n    sh?: Uint8Array[];\r\n}\r\n\r\n/**\r\n * @experimental\r\n * SPLAT file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class SPLATFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = SPLATFileLoaderMetadata.name;\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private readonly _loadingOptions: Readonly<SPLATLoadingOptions>;\r\n    /**\r\n     * Defines the extensions the splat loader is able to load.\r\n     * force data to come in as an ArrayBuffer\r\n     */\r\n    public readonly extensions = SPLATFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Creates loader for gaussian splatting files\r\n     * @param loadingOptions options for loading and parsing splat and PLY files.\r\n     */\r\n    constructor(loadingOptions: Partial<Readonly<SPLATLoadingOptions>> = SPLATFileLoader._DefaultLoadingOptions) {\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    private static readonly _DefaultLoadingOptions = {\r\n        keepInRam: false,\r\n        flipY: false,\r\n    } as const satisfies SPLATLoadingOptions;\r\n\r\n    /** @internal */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\r\n        return new SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the gaussian splatting data to load\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress callback called while file is loading\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public async importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return this._parse(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n                spriteManagers: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    private static _BuildPointCloud(pointcloud: PointsCloudSystem, data: ArrayBuffer): boolean {\r\n        if (!data.byteLength) {\r\n            return false;\r\n        }\r\n        const uBuffer = new Uint8Array(data);\r\n        const fBuffer = new Float32Array(data);\r\n\r\n        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        const pointcloudfunc = function (particle: any, i: number) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n            particle.position = new Vector3(x, y, z);\r\n\r\n            const r = uBuffer[rowLength * i + 24 + 0] / 255;\r\n            const g = uBuffer[rowLength * i + 24 + 1] / 255;\r\n            const b = uBuffer[rowLength * i + 24 + 2] / 255;\r\n            particle.color = new Color4(r, g, b, 1);\r\n        };\r\n\r\n        pointcloud.addPoints(vertexCount, pointcloudfunc);\r\n        return true;\r\n    }\r\n\r\n    private static _BuildMesh(scene: Scene, parsedPLY: ParsedPLY): Mesh {\r\n        const mesh = new Mesh(\"PLYMesh\", scene);\r\n\r\n        const uBuffer = new Uint8Array(parsedPLY.data);\r\n        const fBuffer = new Float32Array(parsedPLY.data);\r\n\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        const positions = [];\r\n\r\n        const vertexData = new VertexData();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n            positions.push(x, y, z);\r\n        }\r\n\r\n        if (parsedPLY.hasVertexColors) {\r\n            const colors = new Float32Array(vertexCount * 4);\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                const r = uBuffer[rowLength * i + 24 + 0] / 255;\r\n                const g = uBuffer[rowLength * i + 24 + 1] / 255;\r\n                const b = uBuffer[rowLength * i + 24 + 2] / 255;\r\n                colors[i * 4 + 0] = r;\r\n                colors[i * 4 + 1] = g;\r\n                colors[i * 4 + 2] = b;\r\n                colors[i * 4 + 3] = 1;\r\n            }\r\n            vertexData.colors = colors;\r\n        }\r\n\r\n        vertexData.positions = positions;\r\n        vertexData.indices = parsedPLY.faces!;\r\n\r\n        vertexData.applyToMesh(mesh);\r\n        return mesh;\r\n    }\r\n\r\n    private _parseSPZ(data: ArrayBuffer, scene: Scene): Promise<ParsedPLY> {\r\n        const ubuf = new Uint8Array(data);\r\n        const ubufu32 = new Uint32Array(data);\r\n        // debug infos\r\n        const splatCount = ubufu32[2];\r\n\r\n        const shDegree = ubuf[12];\r\n        const fractionalBits = ubuf[13];\r\n        //const flags = ubuf[14];\r\n        const reserved = ubuf[15];\r\n\r\n        // check magic and version\r\n        if (reserved || ubufu32[0] != 0x5053474e || ubufu32[1] != 2) {\r\n            // reserved must be 0\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: Mode.Reject, data: buffer, hasVertexColors: false });\r\n            });\r\n        }\r\n\r\n        const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\r\n        const buffer = new ArrayBuffer(rowOutputLength * splatCount);\r\n\r\n        const positionScale = 1.0 / (1 << fractionalBits);\r\n\r\n        const int32View = new Int32Array(1);\r\n        const uint8View = new Uint8Array(int32View.buffer);\r\n        const read24bComponent = function (u8: Uint8Array, offset: number) {\r\n            uint8View[0] = u8[offset + 0];\r\n            uint8View[1] = u8[offset + 1];\r\n            uint8View[2] = u8[offset + 2];\r\n            uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;\r\n            return int32View[0] * positionScale;\r\n        };\r\n\r\n        let byteOffset = 16;\r\n\r\n        const position = new Float32Array(buffer);\r\n        const scale = new Float32Array(buffer);\r\n        const rgba = new Uint8ClampedArray(buffer);\r\n        const rot = new Uint8ClampedArray(buffer);\r\n\r\n        let coordinateSign = 1;\r\n        let quaternionOffset = 0;\r\n        if (!this._loadingOptions.flipY) {\r\n            coordinateSign = -1;\r\n            quaternionOffset = 255;\r\n        }\r\n        // positions\r\n        for (let i = 0; i < splatCount; i++) {\r\n            position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);\r\n            position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);\r\n            position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);\r\n            byteOffset += 9;\r\n        }\r\n\r\n        // colors\r\n        const SH_C0 = 0.282;\r\n        for (let i = 0; i < splatCount; i++) {\r\n            for (let component = 0; component < 3; component++) {\r\n                const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];\r\n                // 0.15 is hard coded value from spz\r\n                // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can\r\n                // be useful to represent base colors that are out of range if the higher spherical harmonics bands\r\n                // bring them back into range so we multiply by a smaller value.\r\n                const value = (byteValue - 127.5) / (0.15 * 255);\r\n                rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + SH_C0 * value) * 255, 0, 255);\r\n            }\r\n\r\n            rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];\r\n        }\r\n        byteOffset += splatCount * 4;\r\n\r\n        // scales\r\n        for (let i = 0; i < splatCount; i++) {\r\n            scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);\r\n            scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);\r\n            scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);\r\n            byteOffset += 3;\r\n        }\r\n\r\n        // convert quaternion\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const x = ubuf[byteOffset + 0];\r\n            const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;\r\n            const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;\r\n            const nx = x / 127.5 - 1;\r\n            const ny = y / 127.5 - 1;\r\n            const nz = z / 127.5 - 1;\r\n            rot[i * 32 + 28 + 1] = x;\r\n            rot[i * 32 + 28 + 2] = y;\r\n            rot[i * 32 + 28 + 3] = z;\r\n            const v = 1 - (nx * nx + ny * ny + nz * nz);\r\n            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;\r\n\r\n            byteOffset += 3;\r\n        }\r\n\r\n        //SH\r\n        if (shDegree) {\r\n            // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3\r\n            // number of vec3 vector needed per splat\r\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color\r\n            // number of component values : 3 per vector3 (45)\r\n            const shComponentCount = shVectorCount * 3;\r\n\r\n            const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\r\n            let shIndexRead = byteOffset;\r\n\r\n            // sh is an array of uint8array that will be used to create sh textures\r\n            const sh: Uint8Array[] = [];\r\n\r\n            const engine = scene.getEngine();\r\n            const width = engine.getCaps().maxTextureSize;\r\n            const height = Math.ceil(splatCount / width);\r\n            // create array for the number of textures needed.\r\n            for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\r\n                const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\r\n                sh.push(texture);\r\n            }\r\n\r\n            for (let i = 0; i < splatCount; i++) {\r\n                for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {\r\n                    const shValue = ubuf[shIndexRead++];\r\n\r\n                    const textureIndex = Math.floor(shIndexWrite / 16);\r\n                    const shArray = sh[textureIndex];\r\n\r\n                    const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                    const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n                    shArray[byteIndexInTexture + offsetPerSplat] = shValue;\r\n                }\r\n            }\r\n\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, sh: sh });\r\n            });\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false });\r\n        });\r\n    }\r\n\r\n    private _parse(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        const readableStream = new ReadableStream({\r\n            start(controller) {\r\n                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array\r\n                controller.close();\r\n            },\r\n        });\r\n\r\n        // Use GZip DecompressionStream\r\n        const decompressionStream = new DecompressionStream(\"gzip\");\r\n        const decompressedStream = readableStream.pipeThrough(decompressionStream);\r\n\r\n        return new Promise((resolve) => {\r\n            new Response(decompressedStream)\r\n                .arrayBuffer()\r\n                .then((buffer) => {\r\n                    this._parseSPZ(buffer, scene).then((parsedSPZ) => {\r\n                        const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n                        gaussianSplatting._parentContainer = this._assetContainer;\r\n                        babylonMeshesArray.push(gaussianSplatting);\r\n                        gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);\r\n                    });\r\n                    resolve(babylonMeshesArray);\r\n                })\r\n                .catch(() => {\r\n                    // Catch any decompression errors\r\n                    SPLATFileLoader._ConvertPLYToSplat(data as ArrayBuffer).then(async (parsedPLY) => {\r\n                        switch (parsedPLY.mode) {\r\n                            case Mode.Splat:\r\n                                {\r\n                                    const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n                                    gaussianSplatting._parentContainer = this._assetContainer;\r\n                                    babylonMeshesArray.push(gaussianSplatting);\r\n                                    gaussianSplatting.updateData(parsedPLY.data);\r\n                                }\r\n                                break;\r\n                            case Mode.PointCloud:\r\n                                {\r\n                                    const pointcloud = new PointsCloudSystem(\"PointCloud\", 1, scene);\r\n                                    if (SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {\r\n                                        await pointcloud.buildMeshAsync().then((mesh) => {\r\n                                            babylonMeshesArray.push(mesh);\r\n                                        });\r\n                                    } else {\r\n                                        pointcloud.dispose();\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case Mode.Mesh:\r\n                                {\r\n                                    if (parsedPLY.faces) {\r\n                                        babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));\r\n                                    } else {\r\n                                        throw new Error(\"PLY mesh doesn't contain face informations.\");\r\n                                    }\r\n                                }\r\n                                break;\r\n                            default:\r\n                                throw new Error(\"Unsupported Splat mode\");\r\n                        }\r\n                        resolve(babylonMeshesArray);\r\n                    });\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return this.importMeshAsync(null, scene, data, rootUrl)\r\n            .then((result) => {\r\n                result.meshes.forEach((mesh) => container.meshes.push(mesh));\r\n                // mesh material will be null before 1st rendered frame.\r\n                this._assetContainer = null;\r\n                return container;\r\n            })\r\n            .catch((ex) => {\r\n                this._assetContainer = null;\r\n                throw ex;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer\r\n     */\r\n    private static _ConvertPLYToSplat(data: ArrayBuffer): Promise<ParsedPLY> {\r\n        const ubuf = new Uint8Array(data);\r\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\r\n        const headerEnd = \"end_header\\n\";\r\n        const headerEndIndex = header.indexOf(headerEnd);\r\n        if (headerEndIndex < 0 || !header) {\r\n            // standard splat\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: Mode.Splat, data: data });\r\n            });\r\n        }\r\n\r\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)![1]);\r\n        const faceElement = /element face (\\d+)\\n/.exec(header);\r\n        let faceCount = 0;\r\n        if (faceElement) {\r\n            faceCount = parseInt(faceElement[1]);\r\n        }\r\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\r\n        let chunkCount = 0;\r\n        if (chunkElement) {\r\n            chunkCount = parseInt(chunkElement[1]);\r\n        }\r\n\r\n        let rowVertexOffset = 0;\r\n        let rowChunkOffset = 0;\r\n        const offsets: Record<string, number> = {\r\n            double: 8,\r\n            int: 4,\r\n            uint: 4,\r\n            float: 4,\r\n            short: 2,\r\n            ushort: 2,\r\n            uchar: 1,\r\n            list: 0,\r\n        };\r\n\r\n        type PlyProperty = {\r\n            name: string;\r\n            type: string;\r\n            offset: number;\r\n        };\r\n\r\n        const enum ElementMode {\r\n            Vertex = 0,\r\n            Chunk = 1,\r\n        }\r\n\r\n        let chunkMode = ElementMode.Chunk;\r\n        const vertexProperties: PlyProperty[] = [];\r\n        const chunkProperties: PlyProperty[] = [];\r\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\r\n        for (const prop of filtered) {\r\n            if (prop.startsWith(\"property \")) {\r\n                const [, type, name] = prop.split(\" \");\r\n\r\n                if (chunkMode == ElementMode.Chunk) {\r\n                    chunkProperties.push({ name, type, offset: rowChunkOffset });\r\n                    rowChunkOffset += offsets[type];\r\n                } else if (chunkMode == ElementMode.Vertex) {\r\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\r\n                    rowVertexOffset += offsets[type];\r\n                }\r\n\r\n                if (!offsets[type]) {\r\n                    Logger.Warn(`Unsupported property type: ${type}.`);\r\n                }\r\n            } else if (prop.startsWith(\"element \")) {\r\n                const [, type] = prop.split(\" \");\r\n                if (type == \"chunk\") {\r\n                    chunkMode = ElementMode.Chunk;\r\n                } else if (type == \"vertex\") {\r\n                    chunkMode = ElementMode.Vertex;\r\n                }\r\n            }\r\n        }\r\n\r\n        const rowVertexLength = rowVertexOffset;\r\n        const rowChunkLength = rowChunkOffset;\r\n\r\n        return (GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data) as any).then((splatsData: any) => {\r\n            const dataView = new DataView(data, headerEndIndex + headerEnd.length);\r\n            let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;\r\n            // faces\r\n            const faces: number[] = [];\r\n            if (faceCount) {\r\n                for (let i = 0; i < faceCount; i++) {\r\n                    const faceVertexCount = dataView.getUint8(offset);\r\n                    if (faceVertexCount != 3) {\r\n                        continue; // only support triangles\r\n                    }\r\n                    offset += 1;\r\n\r\n                    for (let j = 0; j < faceVertexCount; j++) {\r\n                        const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true); // change face winding\r\n                        faces.push(vertexIndex);\r\n                    }\r\n                    offset += 12;\r\n                }\r\n            }\r\n\r\n            // early exit for chunked/quantized ply\r\n            if (chunkCount) {\r\n                return new Promise((resolve) => {\r\n                    resolve({ mode: Mode.Splat, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false });\r\n                });\r\n            }\r\n            // count available properties. if all necessary are present then it's a splat. Otherwise, it's a point cloud\r\n            // if faces are found, then it's a standard mesh\r\n            let propertyCount = 0;\r\n            let propertyColorCount = 0;\r\n            const splatProperties = [\"x\", \"y\", \"z\", \"scale_0\", \"scale_1\", \"scale_2\", \"opacity\", \"rot_0\", \"rot_1\", \"rot_2\", \"rot_3\"];\r\n            const splatColorProperties = [\"red\", \"green\", \"blue\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"];\r\n            for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {\r\n                const property = vertexProperties[propertyIndex];\r\n                if (splatProperties.includes(property.name)) {\r\n                    propertyCount++;\r\n                }\r\n                if (splatColorProperties.includes(property.name)) {\r\n                    propertyColorCount++;\r\n                }\r\n            }\r\n            const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;\r\n            const currentMode = faceCount ? Mode.Mesh : hasMandatoryProperties ? Mode.Splat : Mode.PointCloud;\r\n            // parsed ready ready to be used as a splat\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: !!propertyColorCount });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n// Add this loader into the register plugin\r\nRegisterSceneLoaderPlugin(new SPLATFileLoader());\r\n"],
  "mappings": "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",
  "names": ["i", "Mode", "ElementMode"]
}
