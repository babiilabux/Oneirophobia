import {
  Material
} from "./chunk-CILZ646M.js";
import {
  SceneComponentConstants
} from "./chunk-SEFTBBPY.js";
import {
  UniqueIdGenerator
} from "./chunk-WKXRXUEO.js";
import {
  Texture
} from "./chunk-YDA7SEAD.js";
import {
  ThinEngine
} from "./chunk-LS3EXLWE.js";
import {
  DrawWrapper
} from "./chunk-7MWCSIAI.js";
import {
  VertexBuffer
} from "./chunk-SGWWALOD.js";
import {
  GetExponentOfTwo,
  InternalTexture
} from "./chunk-2PMLUZ5B.js";
import {
  __decorate,
  serialize
} from "./chunk-YC62VEDI.js";
import {
  Color4
} from "./chunk-QJYZAU53.js";
import {
  Vector2
} from "./chunk-3LKPOCHD.js";
import {
  GetClass
} from "./chunk-LMH7SWDS.js";
import {
  EngineStore,
  Observable
} from "./chunk-6QZ75BYX.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js
ThinEngine.prototype.createDynamicTexture = function(width, height, generateMipMaps, samplingMode) {
  const texture = new InternalTexture(
    this,
    4
    /* InternalTextureSource.Dynamic */
  );
  texture.baseWidth = width;
  texture.baseHeight = height;
  if (generateMipMaps) {
    width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;
    height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;
  }
  texture.width = width;
  texture.height = height;
  texture.isReady = false;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  this.updateTextureSamplingMode(samplingMode, texture);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.updateDynamicTexture = function(texture, source, invertY, premulAlpha = false, format, forceBindTexture = false, allowGPUOptimization = false) {
  if (!texture) {
    return;
  }
  const gl = this._gl;
  const target = gl.TEXTURE_2D;
  const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);
  this._unpackFlipY(invertY === void 0 ? texture.invertY : invertY);
  if (premulAlpha) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
  }
  const textureType = this._getWebGLTextureType(texture.type);
  const glformat = this._getInternalFormat(format ? format : texture.format);
  const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);
  gl.texImage2D(target, 0, internalFormat, glformat, textureType, source);
  if (texture.generateMipMaps) {
    gl.generateMipmap(target);
  }
  if (!wasPreviouslyBound) {
    this._bindTextureDirectly(target, null);
  }
  if (premulAlpha) {
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
  }
  if (format) {
    texture.format = format;
  }
  texture._dynamicTextureSource = source;
  texture._premulAlpha = premulAlpha;
  texture.invertY = invertY || false;
  texture.isReady = true;
};

// node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js
var DynamicTexture = class _DynamicTexture extends Texture {
  /** @internal */
  constructor(name, canvasOrSize, sceneOrOptions, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {
    const isScene = !sceneOrOptions || sceneOrOptions._isScene;
    const scene = isScene ? sceneOrOptions : sceneOrOptions == null ? void 0 : sceneOrOptions.scene;
    const noMipmap = isScene ? !generateMipMaps : sceneOrOptions;
    super(null, scene, noMipmap, invertY, samplingMode, void 0, void 0, void 0, void 0, format);
    this.name = name;
    this.wrapU = Texture.CLAMP_ADDRESSMODE;
    this.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._generateMipMaps = generateMipMaps;
    const engine = this._getEngine();
    if (!engine) {
      return;
    }
    if (canvasOrSize.getContext) {
      this._canvas = canvasOrSize;
      this._ownCanvas = false;
      this._texture = engine.createDynamicTexture(this._canvas.width, this._canvas.height, generateMipMaps, samplingMode);
    } else {
      this._canvas = engine.createCanvas(1, 1);
      this._ownCanvas = true;
      const optionsAsSize = canvasOrSize;
      if (optionsAsSize.width || optionsAsSize.width === 0) {
        this._texture = engine.createDynamicTexture(optionsAsSize.width, optionsAsSize.height, generateMipMaps, samplingMode);
      } else {
        this._texture = engine.createDynamicTexture(canvasOrSize, canvasOrSize, generateMipMaps, samplingMode);
      }
    }
    const textureSize = this.getSize();
    if (this._canvas.width !== textureSize.width) {
      this._canvas.width = textureSize.width;
    }
    if (this._canvas.height !== textureSize.height) {
      this._canvas.height = textureSize.height;
    }
    this._context = this._canvas.getContext("2d");
  }
  /**
   * Get the current class name of the texture useful for serialization or dynamic coding.
   * @returns "DynamicTexture"
   */
  getClassName() {
    return "DynamicTexture";
  }
  /**
   * Gets the current state of canRescale
   */
  get canRescale() {
    return true;
  }
  _recreate(textureSize) {
    this._canvas.width = textureSize.width;
    this._canvas.height = textureSize.height;
    this.releaseInternalTexture();
    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);
  }
  /**
   * Scales the texture
   * @param ratio the scale factor to apply to both width and height
   */
  scale(ratio) {
    const textureSize = this.getSize();
    textureSize.width *= ratio;
    textureSize.height *= ratio;
    this._recreate(textureSize);
  }
  /**
   * Resizes the texture
   * @param width the new width
   * @param height the new height
   */
  scaleTo(width, height) {
    const textureSize = this.getSize();
    textureSize.width = width;
    textureSize.height = height;
    this._recreate(textureSize);
  }
  /**
   * Gets the context of the canvas used by the texture
   * @returns the canvas context of the dynamic texture
   */
  getContext() {
    return this._context;
  }
  /**
   * Clears the texture
   * @param clearColor Defines the clear color to use
   */
  clear(clearColor) {
    const size = this.getSize();
    if (clearColor) {
      this._context.fillStyle = clearColor;
    }
    this._context.clearRect(0, 0, size.width, size.height);
  }
  /**
   * Updates the texture
   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
   * @param premulAlpha defines if alpha is stored as premultiplied (default is false)
   * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature "allowGPUOptimizationsForGUI" being true)
   */
  update(invertY, premulAlpha = false, allowGPUOptimization = false) {
    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === void 0 ? true : invertY, premulAlpha, this._format || void 0, void 0, allowGPUOptimization);
  }
  /**
   * Draws text onto the texture
   * @param text defines the text to be drawn
   * @param x defines the placement of the text from the left
   * @param y defines the placement of the text from the top when invertY is true and from the bottom when false
   * @param font defines the font to be used with font-style, font-size, font-name
   * @param color defines the color used for the text
   * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)
   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
   * @param update defines whether texture is immediately update (default is true)
   */
  drawText(text, x, y, font, color, fillColor, invertY, update = true) {
    const size = this.getSize();
    if (fillColor) {
      this._context.fillStyle = fillColor;
      this._context.fillRect(0, 0, size.width, size.height);
    }
    this._context.font = font;
    if (x === null || x === void 0) {
      const textSize = this._context.measureText(text);
      x = (size.width - textSize.width) / 2;
    }
    if (y === null || y === void 0) {
      const fontSize = parseInt(font.replace(/\D/g, ""));
      y = size.height / 2 + fontSize / 3.65;
    }
    this._context.fillStyle = color || "";
    this._context.fillText(text, x, y);
    if (update) {
      this.update(invertY);
    }
  }
  /**
   * Disposes the dynamic texture.
   */
  dispose() {
    var _a, _b;
    super.dispose();
    if (this._ownCanvas) {
      (_b = (_a = this._canvas) == null ? void 0 : _a.remove) == null ? void 0 : _b.call(_a);
    }
    this._canvas = null;
    this._context = null;
  }
  /**
   * Clones the texture
   * @returns the clone of the texture.
   */
  clone() {
    const scene = this.getScene();
    if (!scene) {
      return this;
    }
    const textureSize = this.getSize();
    const newTexture = new _DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.wrapU = this.wrapU;
    newTexture.wrapV = this.wrapV;
    return newTexture;
  }
  /**
   * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized
   * @returns a serialized dynamic texture object
   */
  serialize() {
    const scene = this.getScene();
    if (scene && !scene.isReady()) {
      Logger.Warn("The scene must be ready before serializing the dynamic texture");
    }
    const serializationObject = super.serialize();
    if (_DynamicTexture._IsCanvasElement(this._canvas)) {
      serializationObject.base64String = this._canvas.toDataURL();
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    return serializationObject;
  }
  static _IsCanvasElement(canvas) {
    return canvas.toDataURL !== void 0;
  }
  /** @internal */
  _rebuild() {
    this.update();
  }
};

// node_modules/@babylonjs/core/Events/clipboardEvents.js
var ClipboardEventTypes = class {
};
ClipboardEventTypes.COPY = 1;
ClipboardEventTypes.CUT = 2;
ClipboardEventTypes.PASTE = 3;
var ClipboardInfo = class {
  /**
   *Creates an instance of ClipboardInfo.
   * @param type Defines the type of event (BABYLON.ClipboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
  /**
   *  Get the clipboard event's type from the keycode.
   * @param keyCode Defines the keyCode for the current keyboard event.
   * @returns {number}
   */
  static GetTypeFromCharacter(keyCode) {
    const charCode = keyCode;
    switch (charCode) {
      case 67:
        return ClipboardEventTypes.COPY;
      case 86:
        return ClipboardEventTypes.PASTE;
      case 88:
        return ClipboardEventTypes.CUT;
      default:
        return -1;
    }
  }
};

// node_modules/@babylonjs/core/FrameGraph/Node/Types/nodeRenderGraphTypes.js
var NodeRenderGraphBlockConnectionPointTypes;
(function(NodeRenderGraphBlockConnectionPointTypes2) {
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Texture"] = 1] = "Texture";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureBackBuffer"] = 2] = "TextureBackBuffer";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureBackBufferDepthStencilAttachment"] = 4] = "TextureBackBufferDepthStencilAttachment";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureDepthStencilAttachment"] = 8] = "TextureDepthStencilAttachment";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureViewDepth"] = 16] = "TextureViewDepth";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureViewNormal"] = 32] = "TextureViewNormal";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAlbedo"] = 64] = "TextureAlbedo";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureReflectivity"] = 128] = "TextureReflectivity";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureWorldPosition"] = 256] = "TextureWorldPosition";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureVelocity"] = 512] = "TextureVelocity";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureIrradiance"] = 1024] = "TextureIrradiance";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAlbedoSqrt"] = 2048] = "TextureAlbedoSqrt";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureScreenDepth"] = 4096] = "TextureScreenDepth";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureWorldNormal"] = 8192] = "TextureWorldNormal";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureLocalPosition"] = 16384] = "TextureLocalPosition";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureLinearVelocity"] = 32768] = "TextureLinearVelocity";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAllButBackBufferDepthStencil"] = 1048571] = "TextureAllButBackBufferDepthStencil";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAllButBackBuffer"] = 1048569] = "TextureAllButBackBuffer";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAll"] = 1048575] = "TextureAll";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ResourceContainer"] = 1048576] = "ResourceContainer";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ShadowGenerator"] = 2097152] = "ShadowGenerator";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ShadowLight"] = 4194304] = "ShadowLight";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Camera"] = 16777216] = "Camera";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ObjectList"] = 33554432] = "ObjectList";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["AutoDetect"] = 268435456] = "AutoDetect";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["BasedOnInput"] = 536870912] = "BasedOnInput";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Undefined"] = 1073741824] = "Undefined";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Object"] = 2147483648] = "Object";
  NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["All"] = 4294967295] = "All";
})(NodeRenderGraphBlockConnectionPointTypes || (NodeRenderGraphBlockConnectionPointTypes = {}));
var NodeRenderGraphConnectionPointCompatibilityStates;
(function(NodeRenderGraphConnectionPointCompatibilityStates2) {
  NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
  NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
  NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["HierarchyIssue"] = 2] = "HierarchyIssue";
})(NodeRenderGraphConnectionPointCompatibilityStates || (NodeRenderGraphConnectionPointCompatibilityStates = {}));
var NodeRenderGraphConnectionPointDirection;
(function(NodeRenderGraphConnectionPointDirection2) {
  NodeRenderGraphConnectionPointDirection2[NodeRenderGraphConnectionPointDirection2["Input"] = 0] = "Input";
  NodeRenderGraphConnectionPointDirection2[NodeRenderGraphConnectionPointDirection2["Output"] = 1] = "Output";
})(NodeRenderGraphConnectionPointDirection || (NodeRenderGraphConnectionPointDirection = {}));

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlockConnectionPoint.js
var NodeRenderGraphConnectionPoint = class {
  /** Gets the direction of the point */
  get direction() {
    return this._direction;
  }
  /**
   * Checks if the value is a texture handle
   * @param value The value to check
   * @returns True if the value is a texture handle
   */
  static IsTextureHandle(value) {
    return value !== void 0 && Number.isFinite(value);
  }
  /**
   * Checks if the value is a shadow generator task
   * @param value The value to check
   * @returns True if the value is a shadow generator
   */
  static IsShadowGenerator(value) {
    return value !== void 0 && value.mapSize !== void 0;
  }
  /**
   * Checks if the value is a shadow light
   * @param value The value to check
   * @returns True if the value is a shadow light
   */
  static IsShadowLight(value) {
    return value !== void 0 && value.setShadowProjectionMatrix !== void 0;
  }
  /**
   * Gets or sets the connection point type (default is Undefined)
   */
  get type() {
    if (this._type === NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {
      if (this._ownerBlock.isInput) {
        return this._ownerBlock.type;
      }
      if (this._connectedPoint) {
        return this._connectedPoint.type;
      }
      if (this._linkedConnectionSource) {
        if (this._linkedConnectionSource.isConnected) {
          return this._linkedConnectionSource.type;
        }
        if (this._linkedConnectionSource._defaultConnectionPointType) {
          return this._linkedConnectionSource._defaultConnectionPointType;
        }
      }
      if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    if (this._type === NodeRenderGraphBlockConnectionPointTypes.BasedOnInput) {
      if (this._typeConnectionSource) {
        const typeConnectionSource = typeof this._typeConnectionSource === "function" ? this._typeConnectionSource() : this._typeConnectionSource;
        if (!typeConnectionSource.isConnected) {
          return this._defaultConnectionPointType ?? typeConnectionSource.type;
        }
        return typeConnectionSource._connectedPoint.type;
      } else if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  /**
   * Gets a boolean indicating that the current point is connected to another NodeRenderGraphBlock
   */
  get isConnected() {
    return this.connectedPoint !== null || this.hasEndpoints;
  }
  /** Get the other side of the connection (if any) */
  get connectedPoint() {
    return this._connectedPoint;
  }
  /** Get the block that owns this connection point */
  get ownerBlock() {
    return this._ownerBlock;
  }
  /** Get the block connected on the other side of this connection (if any) */
  get sourceBlock() {
    if (!this._connectedPoint) {
      return null;
    }
    return this._connectedPoint.ownerBlock;
  }
  /** Get the block connected on the endpoints of this connection (if any) */
  get connectedBlocks() {
    if (this._endpoints.length === 0) {
      return [];
    }
    return this._endpoints.map((e) => e.ownerBlock);
  }
  /** Gets the list of connected endpoints */
  get endpoints() {
    return this._endpoints;
  }
  /** Gets a boolean indicating if that output point is connected to at least one input */
  get hasEndpoints() {
    return this._endpoints && this._endpoints.length > 0;
  }
  /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
  get innerType() {
    if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {
      return this.type;
    }
    return this._type;
  }
  /**
   * Creates a block suitable to be used as an input for this input point.
   * If null is returned, a block based on the point type will be created.
   * @returns The returned string parameter is the name of the output point of NodeRenderGraphBlock (first parameter of the returned array) that can be connected to the input
   */
  createCustomInputBlock() {
    return null;
  }
  /**
   * Creates a new connection point
   * @param name defines the connection point name
   * @param ownerBlock defines the block hosting this connection point
   * @param direction defines the direction of the connection point
   */
  constructor(name, ownerBlock, direction) {
    this._connectedPoint = null;
    this._acceptedConnectionPointType = null;
    this._endpoints = new Array();
    this._type = NodeRenderGraphBlockConnectionPointTypes.Undefined;
    this._linkedConnectionSource = null;
    this._isMainLinkSource = false;
    this._typeConnectionSource = null;
    this._defaultConnectionPointType = null;
    this.needDualDirectionValidation = false;
    this.acceptedConnectionPointTypes = [];
    this.excludedConnectionPointTypes = [];
    this.onConnectionObservable = new Observable();
    this.onDisconnectionObservable = new Observable();
    this.isExposedOnFrame = false;
    this.exposedPortPosition = -1;
    this._ownerBlock = ownerBlock;
    this.name = name;
    this._direction = direction;
  }
  /**
   * Gets the current class name e.g. "NodeRenderGraphConnectionPoint"
   * @returns the class name
   */
  getClassName() {
    return "NodeRenderGraphConnectionPoint";
  }
  /**
   * Gets a boolean indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a boolean
   */
  canConnectTo(connectionPoint) {
    return this.checkCompatibilityState(connectionPoint) === 0;
  }
  /**
   * Gets a number indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a number defining the compatibility state
   */
  checkCompatibilityState(connectionPoint) {
    const ownerBlock = this._ownerBlock;
    const otherBlock = connectionPoint.ownerBlock;
    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {
      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {
        return 0;
      } else {
        return 1;
      }
    }
    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
      return 1;
    }
    let targetBlock = otherBlock;
    let sourceBlock = ownerBlock;
    if (this.direction === 0) {
      targetBlock = ownerBlock;
      sourceBlock = otherBlock;
    }
    if (targetBlock.isAnAncestorOf(sourceBlock)) {
      return 2;
    }
    return 0;
  }
  /**
   * Connect this point to another connection point
   * @param connectionPoint defines the other connection point
   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
   * @returns the current connection point
   */
  connectTo(connectionPoint, ignoreConstraints = false) {
    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
      throw "Cannot connect these two connectors.";
    }
    this._endpoints.push(connectionPoint);
    connectionPoint._connectedPoint = this;
    this.onConnectionObservable.notifyObservers(connectionPoint);
    connectionPoint.onConnectionObservable.notifyObservers(this);
    return this;
  }
  /**
   * Disconnect this point from one of his endpoint
   * @param endpoint defines the other connection point
   * @returns the current connection point
   */
  disconnectFrom(endpoint) {
    const index = this._endpoints.indexOf(endpoint);
    if (index === -1) {
      return this;
    }
    this._endpoints.splice(index, 1);
    endpoint._connectedPoint = null;
    this.onDisconnectionObservable.notifyObservers(endpoint);
    endpoint.onDisconnectionObservable.notifyObservers(this);
    return this;
  }
  /**
   * Fills the list of excluded connection point types with all types other than those passed in the parameter
   * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
   */
  addExcludedConnectionPointFromAllowedTypes(mask) {
    let bitmask = 0;
    let val = 2 ** bitmask;
    while (val < NodeRenderGraphBlockConnectionPointTypes.All) {
      if (!(mask & val)) {
        this.excludedConnectionPointTypes.push(val);
      }
      bitmask++;
      val = 2 ** bitmask;
    }
  }
  /**
   * Adds accepted connection point types
   * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed to connect to this point
   */
  addAcceptedConnectionPointTypes(mask) {
    let bitmask = 0;
    let val = 2 ** bitmask;
    while (val < NodeRenderGraphBlockConnectionPointTypes.All) {
      if (mask & val && this.acceptedConnectionPointTypes.indexOf(val) === -1) {
        this.acceptedConnectionPointTypes.push(val);
      }
      bitmask++;
      val = 2 ** bitmask;
    }
  }
  /**
   * Serializes this point in a JSON representation
   * @param isInput defines if the connection point is an input (default is true)
   * @returns the serialized point object
   */
  serialize(isInput = true) {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.displayName = this.displayName;
    if (isInput && this.connectedPoint) {
      serializationObject.inputName = this.name;
      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
      serializationObject.targetConnectionName = this.connectedPoint.name;
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    return serializationObject;
  }
  /**
   * Release resources
   */
  dispose() {
    this.onConnectionObservable.clear();
    this.onDisconnectionObservable.clear();
  }
};

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlock.js
var NodeRenderGraphBlock = class {
  /**
   * Gets or sets the disable flag of the task associated with this block
   */
  get disabled() {
    var _a;
    return !!((_a = this._frameGraphTask) == null ? void 0 : _a.disabled);
  }
  set disabled(value) {
    if (this._frameGraphTask) {
      this._frameGraphTask.disabled = value;
    }
  }
  /**
   * Gets the frame graph task associated with this block
   */
  get task() {
    return this._frameGraphTask;
  }
  /**
   * Gets the list of input points
   */
  get inputs() {
    return this._inputs;
  }
  /** Gets the list of output points */
  get outputs() {
    return this._outputs;
  }
  /**
   * Gets or set the name of the block
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  /**
   * Gets a boolean indicating if this block is an input
   */
  get isInput() {
    return this._isInput;
  }
  /**
   * Gets a boolean indicating if this block is a teleport out
   */
  get isTeleportOut() {
    return this._isTeleportOut;
  }
  /**
   * Gets a boolean indicating if this block is a teleport in
   */
  get isTeleportIn() {
    return this._isTeleportIn;
  }
  /**
   * Gets a boolean indicating if this block is a debug block
   */
  get isDebug() {
    return this._isDebug;
  }
  /**
   * Gets a boolean indicating that this block can only be used once per node render graph
   */
  get isUnique() {
    return this._isUnique;
  }
  /**
   * Gets the current class name e.g. "NodeRenderGraphBlock"
   * @returns the class name
   */
  getClassName() {
    return "NodeRenderGraphBlock";
  }
  _inputRename(name) {
    return name;
  }
  _outputRename(name) {
    return name;
  }
  /**
   * Checks if the current block is an ancestor of a given block
   * @param block defines the potential descendant block to check
   * @returns true if block is a descendant
   */
  isAnAncestorOf(block) {
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        if (endpoint.ownerBlock === block) {
          return true;
        }
        if (endpoint.ownerBlock.isAnAncestorOf(block)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Checks if the current block is an ancestor of a given type
   * @param type defines the potential type to check
   * @returns true if block is a descendant
   */
  isAnAncestorOfType(type) {
    if (this.getClassName() === type) {
      return true;
    }
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        if (endpoint.ownerBlock.isAnAncestorOfType(type)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Get the first descendant using a predicate
   * @param predicate defines the predicate to check
   * @returns descendant or null if none found
   */
  getDescendantOfPredicate(predicate) {
    if (predicate(this)) {
      return this;
    }
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);
        if (descendant) {
          return descendant;
        }
      }
    }
    return null;
  }
  /**
   * Creates a new NodeRenderGraphBlock
   * @param name defines the block name
   * @param frameGraph defines the hosting frame graph
   * @param scene defines the hosting scene
   * @param _additionalConstructionParameters defines additional parameters to pass to the block constructor
   */
  constructor(name, frameGraph, scene, ..._additionalConstructionParameters) {
    this._name = "";
    this._isInput = false;
    this._isTeleportOut = false;
    this._isTeleportIn = false;
    this._isDebug = false;
    this._isUnique = false;
    this.onBuildObservable = new Observable();
    this._inputs = new Array();
    this._outputs = new Array();
    this._codeVariableName = "";
    this._additionalConstructionParameters = null;
    this.visibleOnFrame = false;
    this._name = name;
    this._frameGraph = frameGraph;
    this._scene = scene;
    this._engine = scene.getEngine();
    this.uniqueId = UniqueIdGenerator.UniqueId;
  }
  /**
   * Register a new input. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param isOptional defines a boolean indicating that this input can be omitted
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerInput(name, type, isOptional = false, point) {
    point = point ?? new NodeRenderGraphConnectionPoint(
      name,
      this,
      0
      /* NodeRenderGraphConnectionPointDirection.Input */
    );
    point.type = type;
    point.isOptional = isOptional;
    this._inputs.push(point);
    return this;
  }
  /**
   * Register a new output. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerOutput(name, type, point) {
    point = point ?? new NodeRenderGraphConnectionPoint(
      name,
      this,
      1
      /* NodeRenderGraphConnectionPointDirection.Output */
    );
    point.type = type;
    this._outputs.push(point);
    return this;
  }
  _addDependenciesInput() {
    this.registerInput("dependencies", NodeRenderGraphBlockConnectionPointTypes.Texture, true);
    const dependencies = this.getInputByName("dependencies");
    dependencies.addAcceptedConnectionPointTypes(NodeRenderGraphBlockConnectionPointTypes.TextureAllButBackBuffer | NodeRenderGraphBlockConnectionPointTypes.ResourceContainer | NodeRenderGraphBlockConnectionPointTypes.ShadowGenerator);
    return dependencies;
  }
  _buildBlock(_state) {
  }
  _customBuildStep(_state) {
  }
  _propagateInputValueToOutput(inputConnectionPoint, outputConnectionPoint) {
    if (inputConnectionPoint.connectedPoint) {
      outputConnectionPoint.value = inputConnectionPoint.connectedPoint.value;
    }
  }
  /**
   * Build the current node and generate the vertex data
   * @param state defines the current generation state
   * @returns true if already built
   */
  build(state) {
    var _a;
    if (this._buildId === state.buildId) {
      return true;
    }
    this._buildId = state.buildId;
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!input.isOptional) {
          state._notConnectedNonOptionalInputs.push(input);
        }
        continue;
      }
      const block = input.connectedPoint.ownerBlock;
      if (block && block !== this) {
        block.build(state);
      }
    }
    this._customBuildStep(state);
    if (state.verbose) {
      Logger.Log(`Building ${this.name} [${this.getClassName()}]`);
    }
    if (this._frameGraphTask) {
      this._frameGraphTask.name = this.name;
    }
    this._buildBlock(state);
    if (this._frameGraphTask) {
      this._frameGraphTask.dependencies = void 0;
      const dependenciesConnectedPoint = (_a = this.getInputByName("dependencies")) == null ? void 0 : _a.connectedPoint;
      if (dependenciesConnectedPoint) {
        if (dependenciesConnectedPoint.type === NodeRenderGraphBlockConnectionPointTypes.ResourceContainer) {
          const container = dependenciesConnectedPoint.ownerBlock;
          for (let i = 0; i < container.inputs.length; i++) {
            const input = container.inputs[i];
            if (input.connectedPoint && input.connectedPoint.value !== void 0 && NodeRenderGraphConnectionPoint.IsTextureHandle(input.connectedPoint.value)) {
              this._frameGraphTask.dependencies = this._frameGraphTask.dependencies || /* @__PURE__ */ new Set();
              this._frameGraphTask.dependencies.add(input.connectedPoint.value);
            }
          }
        } else if (NodeRenderGraphConnectionPoint.IsTextureHandle(dependenciesConnectedPoint.value)) {
          this._frameGraphTask.dependencies = this._frameGraphTask.dependencies || /* @__PURE__ */ new Set();
          this._frameGraphTask.dependencies.add(dependenciesConnectedPoint.value);
        }
      }
      this._frameGraph.addTask(this._frameGraphTask);
    }
    this.onBuildObservable.notifyObservers(this);
    return false;
  }
  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
    if (looseCoupling) {
      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
    } else {
      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
      this._inputs[inputIndex0]._isMainLinkSource = true;
    }
    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
  }
  /**
   * Initialize the block and prepare the context for build
   */
  initialize() {
  }
  /**
   * Lets the block try to connect some inputs automatically
   */
  autoConfigure() {
  }
  /**
   * Find an input by its name
   * @param name defines the name of the input to look for
   * @returns the input or null if not found
   */
  getInputByName(name) {
    const filter = this._inputs.filter((e) => e.name === name);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Find an output by its name
   * @param name defines the name of the output to look for
   * @returns the output or null if not found
   */
  getOutputByName(name) {
    const filter = this._outputs.filter((e) => e.name === name);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.id = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject.visibleOnFrame = this.visibleOnFrame;
    serializationObject.disabled = this.disabled;
    if (this._additionalConstructionParameters) {
      serializationObject.additionalConstructionParameters = this._additionalConstructionParameters;
    }
    serializationObject.inputs = [];
    serializationObject.outputs = [];
    for (const input of this.inputs) {
      serializationObject.inputs.push(input.serialize());
    }
    for (const output of this.outputs) {
      serializationObject.outputs.push(output.serialize(false));
    }
    return serializationObject;
  }
  /**
   * @internal
   */
  _deserialize(serializationObject) {
    this._name = serializationObject.name;
    this.comments = serializationObject.comments;
    this.visibleOnFrame = serializationObject.visibleOnFrame;
    this.disabled = serializationObject.disabled;
    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
  }
  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
    const serializedInputs = serializationObject.inputs;
    const serializedOutputs = serializationObject.outputs;
    if (serializedInputs) {
      serializedInputs.forEach((port) => {
        const input = this.inputs.find((i) => i.name === port.name);
        if (!input) {
          return;
        }
        if (port.displayName) {
          input.displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          input.isExposedOnFrame = port.isExposedOnFrame;
          input.exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
    if (serializedOutputs) {
      serializedOutputs.forEach((port, i) => {
        if (port.displayName) {
          this.outputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.outputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};
${variableName}.disabled = ${this.disabled};
`;
  }
  /**
   * @internal
   */
  _dumpCodeForOutputConnections(alreadyDumped) {
    let codeString = "";
    if (alreadyDumped.indexOf(this) !== -1) {
      return codeString;
    }
    alreadyDumped.push(this);
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});
`;
    }
    return codeString;
  }
  /**
   * @internal
   */
  _dumpCode(uniqueNames, alreadyDumped) {
    alreadyDumped.push(this);
    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
      let index = 0;
      do {
        index++;
        this._codeVariableName = nameAsVariableName + index;
      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
    }
    uniqueNames.push(this._codeVariableName);
    let codeString = `
// ${this.getClassName()}
`;
    if (this.comments) {
      codeString += `// ${this.comments}
`;
    }
    const className = this.getClassName();
    if (className === "RenderGraphInputBlock") {
      const block = this;
      const blockType = block.type;
      codeString += `var ${this._codeVariableName} = new BABYLON.NodeRenderGraphInputBlock("${this.name}", nodeRenderGraph.frameGraph, scene, BABYLON.NodeRenderGraphBlockConnectionPointTypes.${NodeRenderGraphBlockConnectionPointTypes[blockType]});
`;
    } else {
      if (this._additionalConstructionParameters) {
        codeString += `var ${this._codeVariableName} = new BABYLON.${className}("${this.name}", nodeRenderGraph.frameGraph, scene, ...${JSON.stringify(this._additionalConstructionParameters)});
`;
      } else {
        codeString += `var ${this._codeVariableName} = new BABYLON.${className}("${this.name}", nodeRenderGraph.frameGraph, scene);
`;
      }
    }
    codeString += this._dumpPropertiesCode() + "\n";
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      if (alreadyDumped.indexOf(connectedBlock) === -1) {
        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const output of this.outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const connectedBlock = endpoint.ownerBlock;
        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
        }
      }
    }
    return codeString;
  }
  /**
   * Clone the current block to a new identical block
   * @returns a copy of the current block
   */
  clone() {
    const serializationObject = this.serialize();
    const blockType = GetClass(serializationObject.customType);
    if (blockType) {
      const additionalConstructionParameters = serializationObject.additionalConstructionParameters;
      const block = additionalConstructionParameters ? new blockType("", this._frameGraph, this._scene, ...additionalConstructionParameters) : new blockType("", this._frameGraph, this._scene);
      block._deserialize(serializationObject);
      return block;
    }
    return null;
  }
  /**
   * Release resources
   */
  dispose() {
    var _a;
    for (const input of this.inputs) {
      input.dispose();
    }
    for (const output of this.outputs) {
      output.dispose();
    }
    (_a = this._frameGraphTask) == null ? void 0 : _a.dispose();
    this._frameGraphTask = void 0;
    this.onBuildObservable.clear();
  }
};
__decorate([
  serialize("comment")
], NodeRenderGraphBlock.prototype, "comments", void 0);

// node_modules/@babylonjs/core/FrameGraph/Passes/pass.js
var FrameGraphPass = class {
  constructor(name, _parentTask, _context) {
    this.name = name;
    this._parentTask = _parentTask;
    this._context = _context;
    this.disabled = false;
  }
  setExecuteFunc(func) {
    this._executeFunc = func;
  }
  _execute() {
    if (!this.disabled) {
      this._executeFunc(this._context);
    }
  }
  _isValid() {
    return this._executeFunc !== void 0 ? null : "Execute function is not set (call setExecuteFunc to set it)";
  }
};

// node_modules/@babylonjs/core/FrameGraph/Passes/cullPass.js
var FrameGraphCullPass = class extends FrameGraphPass {
  /**
   * Checks if a pass is a cull pass.
   * @param pass The pass to check.
   * @returns True if the pass is a cull pass, else false.
   */
  static IsCullPass(pass) {
    return pass.setObjectList !== void 0;
  }
  /**
   * Gets the object list used by the cull pass.
   */
  get objectList() {
    return this._objectList;
  }
  /**
   * Sets the object list to use for culling.
   * @param objectList The object list to use for culling.
   */
  setObjectList(objectList) {
    this._objectList = objectList;
  }
  /** @internal */
  constructor(name, parentTask, context, engine) {
    super(name, parentTask, context);
    this._engine = engine;
  }
  /** @internal */
  _isValid() {
    const errMsg = super._isValid();
    return errMsg ? errMsg : this._objectList !== void 0 ? null : "Object list is not set (call setObjectList to set it)";
  }
};

// node_modules/@babylonjs/core/FrameGraph/Passes/renderPass.js
var FrameGraphRenderPass = class extends FrameGraphPass {
  /**
   * Checks if a pass is a render pass.
   * @param pass The pass to check.
   * @returns True if the pass is a render pass, else false.
   */
  static IsRenderPass(pass) {
    return pass.setRenderTarget !== void 0;
  }
  /**
   * Gets the render target(s) used by the render pass.
   */
  get renderTarget() {
    return this._renderTarget;
  }
  /**
   * Gets the render target depth used by the render pass.
   */
  get renderTargetDepth() {
    return this._renderTargetDepth;
  }
  /** @internal */
  constructor(name, parentTask, context, engine) {
    super(name, parentTask, context);
    this._dependencies = /* @__PURE__ */ new Set();
    this._engine = engine;
  }
  /**
   * Sets the render target(s) to use for rendering.
   * @param renderTargetHandle The render target to use for rendering, or an array of render targets to use for multi render target rendering.
   */
  setRenderTarget(renderTargetHandle) {
    this._renderTarget = renderTargetHandle;
  }
  /**
   * Sets the render target depth to use for rendering.
   * @param renderTargetHandle The render target depth to use for rendering.
   */
  setRenderTargetDepth(renderTargetHandle) {
    this._renderTargetDepth = renderTargetHandle;
  }
  /**
   * Adds dependencies to the render pass.
   * @param dependencies The dependencies to add.
   */
  addDependencies(dependencies) {
    if (Array.isArray(dependencies)) {
      for (const dependency of dependencies) {
        this._dependencies.add(dependency);
      }
    } else {
      this._dependencies.add(dependencies);
    }
  }
  /**
   * Collects the dependencies of the render pass.
   * @param dependencies The set of dependencies to update.
   */
  collectDependencies(dependencies) {
    const iterator = this._dependencies.keys();
    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
      dependencies.add(key.value);
    }
    if (this._renderTarget) {
      if (Array.isArray(this._renderTarget)) {
        for (const handle of this._renderTarget) {
          if (handle !== void 0) {
            dependencies.add(handle);
          }
        }
      } else {
        dependencies.add(this._renderTarget);
      }
    }
    if (this._renderTargetDepth) {
      dependencies.add(this._renderTargetDepth);
    }
  }
  /** @internal */
  _execute() {
    this._frameGraphRenderTarget = this._frameGraphRenderTarget || this._context.createRenderTarget(this.name, this._renderTarget, this._renderTargetDepth);
    this._context.bindRenderTarget(this._frameGraphRenderTarget, `frame graph render pass - ${this.name}`);
    super._execute();
    this._context._flushDebugMessages();
  }
  /** @internal */
  _isValid() {
    const errMsg = super._isValid();
    return errMsg ? errMsg : this._renderTarget !== void 0 || this.renderTargetDepth !== void 0 ? null : "Render target and render target depth cannot both be undefined.";
  }
};

// node_modules/@babylonjs/core/FrameGraph/frameGraphTask.js
var FrameGraphTask = class {
  /**
   * The name of the task.
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  /**
   * Whether the task is disabled.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  /**
   * Gets the render passes of the task.
   */
  get passes() {
    return this._passes;
  }
  /**
   * Gets the disabled render passes of the task.
   */
  get passesDisabled() {
    return this._passesDisabled;
  }
  /**
   * Checks if the task is ready to be executed.
   * @returns True if the task is ready to be executed, else false.
   */
  isReady() {
    return true;
  }
  /**
   * Disposes of the task.
   */
  dispose() {
    this._reset();
    this.onTexturesAllocatedObservable.clear();
  }
  /**
   * Constructs a new frame graph task.
   * @param name The name of the task.
   * @param frameGraph The frame graph this task is associated with.
   */
  constructor(name, frameGraph) {
    this._passes = [];
    this._passesDisabled = [];
    this._disabled = false;
    this.onTexturesAllocatedObservable = new Observable();
    this.name = name;
    this._frameGraph = frameGraph;
    this._reset();
  }
  /** @internal */
  _reset() {
    this._passes.length = 0;
    this._passesDisabled.length = 0;
  }
  /** @internal */
  _addPass(pass, disabled) {
    if (disabled) {
      this._passesDisabled.push(pass);
    } else {
      this._passes.push(pass);
    }
  }
  /** @internal */
  _checkTask() {
    let outputTexture = null;
    let outputDepthTexture = null;
    let outputObjectList;
    for (const pass of this._passes) {
      const errMsg = pass._isValid();
      if (errMsg) {
        throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
      }
      if (FrameGraphRenderPass.IsRenderPass(pass)) {
        const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
        outputTexture = [];
        for (const handle of handles) {
          if (handle !== void 0) {
            outputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
          }
        }
        outputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
      } else if (FrameGraphCullPass.IsCullPass(pass)) {
        outputObjectList = pass.objectList;
      }
    }
    let disabledOutputTexture = null;
    let disabledOutputTextureHandle = [];
    let disabledOutputDepthTexture = null;
    let disabledOutputObjectList;
    for (const pass of this._passesDisabled) {
      const errMsg = pass._isValid();
      if (errMsg) {
        throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
      }
      if (FrameGraphRenderPass.IsRenderPass(pass)) {
        const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
        disabledOutputTexture = [];
        for (const handle of handles) {
          if (handle !== void 0) {
            disabledOutputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
          }
        }
        disabledOutputTextureHandle = handles;
        disabledOutputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
      } else if (FrameGraphCullPass.IsCullPass(pass)) {
        disabledOutputObjectList = pass.objectList;
      }
    }
    if (this._passesDisabled.length > 0) {
      if (!this._checkSameRenderTarget(outputTexture, disabledOutputTexture)) {
        let ok = true;
        for (const handle of disabledOutputTextureHandle) {
          if (handle !== void 0 && !this._frameGraph.textureManager.isHistoryTexture(handle)) {
            ok = false;
            break;
          }
        }
        if (!ok) {
          throw new Error(`The output texture of the task "${this.name}" is different when it is enabled or disabled.`);
        }
      }
      if (outputDepthTexture !== disabledOutputDepthTexture) {
        throw new Error(`The output depth texture of the task "${this.name}" is different when it is enabled or disabled.`);
      }
      if (outputObjectList !== disabledOutputObjectList) {
        throw new Error(`The output object list of the task "${this.name}" is different when it is enabled or disabled.`);
      }
    }
  }
  /** @internal */
  _getPasses() {
    return this.disabled && this._passesDisabled.length > 0 ? this._passesDisabled : this._passes;
  }
  _checkSameRenderTarget(src, dst) {
    if (src === null || dst === null) {
      return src === dst;
    }
    if (src.length !== dst.length) {
      return false;
    }
    for (let i = 0; i < src.length; i++) {
      if (src[i] !== dst[i]) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/@babylonjs/core/Layers/layerSceneComponent.js
var LayerSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_LAYER;
    this.scene = scene || EngineStore.LastCreatedScene;
    if (!this.scene) {
      return;
    }
    this._engine = this.scene.getEngine();
  }
  /**
   * Registers the component in a given scene
   */
  register() {
    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);
    this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);
    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);
    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);
    this.scene._afterRenderTargetPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER, this, this._drawRenderTargetForegroundWithoutPostProcessing);
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
    const layers = this.scene.layers;
    for (const layer of layers) {
      layer._rebuild();
    }
  }
  /**
   * Disposes the component and the associated resources.
   */
  dispose() {
    const layers = this.scene.layers;
    while (layers.length) {
      layers[0].dispose();
    }
  }
  _draw(predicate) {
    const layers = this.scene.layers;
    if (layers.length) {
      this._engine.setDepthBuffer(false);
      for (const layer of layers) {
        if (predicate(layer)) {
          layer.render();
        }
      }
      this._engine.setDepthBuffer(true);
    }
  }
  _drawCameraPredicate(layer, isBackground, applyPostProcess, cameraLayerMask) {
    return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && (layer.layerMask & cameraLayerMask) !== 0;
  }
  _drawCameraBackground(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, true, true, camera.layerMask);
    });
  }
  _drawCameraForegroundWithPostProcessing(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, false, true, camera.layerMask);
    });
  }
  _drawCameraForegroundWithoutPostProcessing(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, false, false, camera.layerMask);
    });
  }
  _drawRenderTargetPredicate(layer, isBackground, applyPostProcess, cameraLayerMask, renderTargetTexture) {
    return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;
  }
  _drawRenderTargetBackground(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  _drawRenderTargetForegroundWithPostProcessing(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  _drawRenderTargetForegroundWithoutPostProcessing(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  /**
   * Adds all the elements from the container to the scene
   * @param container the container holding the elements
   */
  addFromContainer(container) {
    if (!container.layers) {
      return;
    }
    container.layers.forEach((layer) => {
      this.scene.layers.push(layer);
    });
  }
  /**
   * Removes all the elements in the container from the scene
   * @param container contains the elements to remove
   * @param dispose if the removed element should be disposed (default: false)
   */
  removeFromContainer(container, dispose = false) {
    if (!container.layers) {
      return;
    }
    container.layers.forEach((layer) => {
      const index = this.scene.layers.indexOf(layer);
      if (index !== -1) {
        this.scene.layers.splice(index, 1);
      }
      if (dispose) {
        layer.dispose();
      }
    });
  }
};

// node_modules/@babylonjs/core/Layers/layer.js
var Layer = class _Layer {
  /**
   * Determines if the layer is drawn before (true) or after (false) post-processing.
   * If the layer is background, it is always before.
   */
  set applyPostProcess(value) {
    this._applyPostProcess = value;
  }
  get applyPostProcess() {
    return this.isBackground || this._applyPostProcess;
  }
  /**
   * Back compatibility with callback before the onDisposeObservable existed.
   * The set callback will be triggered when the layer has been disposed.
   */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /**
   * Back compatibility with callback before the onBeforeRenderObservable existed.
   * The set callback will be triggered just before rendering the layer.
   */
  set onBeforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
  }
  /**
   * Back compatibility with callback before the onAfterRenderObservable existed.
   * The set callback will be triggered just after rendering the layer.
   */
  set onAfterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
  }
  /**
   * Gets the shader language used in this material.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Instantiates a new layer.
   * This represents a full screen 2d layer.
   * This can be useful to display a picture in the  background of your scene for instance.
   * @see https://www.babylonjs-playground.com/#08A2BS#1
   * @param name Define the name of the layer in the scene
   * @param imgUrl Define the url of the texture to display in the layer
   * @param scene Define the scene the layer belongs to
   * @param isBackground Defines whether the layer is displayed in front or behind the scene
   * @param color Defines a color for the layer
   * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
   */
  constructor(name, imgUrl, scene, isBackground, color, forceGLSL = false) {
    this.name = name;
    this._applyPostProcess = true;
    this.scale = new Vector2(1, 1);
    this.offset = new Vector2(0, 0);
    this.alphaBlendingMode = 2;
    this.layerMask = 268435455;
    this.renderTargetTextures = [];
    this.renderOnlyInRenderTargetTextures = false;
    this.convertToLinearSpace = false;
    this.isEnabled = true;
    this._vertexBuffers = {};
    this.onDisposeObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this._shaderLanguage = 0;
    this._shadersLoaded = false;
    this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;
    this.isBackground = isBackground === void 0 ? true : isBackground;
    this.color = color === void 0 ? new Color4(1, 1, 1, 1) : color;
    this._scene = scene || EngineStore.LastCreatedScene;
    const engine = this._scene.getEngine();
    if (engine.isWebGPU && !forceGLSL && !_Layer.ForceGLSL) {
      this._shaderLanguage = 1;
    }
    let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);
    if (!layerComponent) {
      layerComponent = new LayerSceneComponent(this._scene);
      this._scene._addComponent(layerComponent);
    }
    this._scene.layers.push(this);
    this._drawWrapper = new DrawWrapper(engine);
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
    this._createIndexBuffer();
  }
  _createIndexBuffer() {
    const engine = this._scene.getEngine();
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  }
  /** @internal */
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
  }
  /**
   * Checks if the layer is ready to be rendered
   * @returns true if the layer is ready. False otherwise.
   */
  isReady() {
    const engine = this._scene.getEngine();
    let defines = "";
    if (this.alphaTest) {
      defines = "#define ALPHATEST";
    }
    if (this.texture) {
      if (this.texture.gammaSpace) {
        if (this.convertToLinearSpace) {
          defines += "\n#define CONVERT_TO_LINEAR";
        }
      } else if (!this.convertToLinearSpace) {
        defines += "\n#define CONVERT_TO_GAMMA";
      }
    }
    if (this._previousDefines !== defines) {
      this._previousDefines = defines;
      this._drawWrapper.effect = engine.createEffect("layer", [VertexBuffer.PositionKind], ["textureMatrix", "color", "scale", "offset"], ["textureSampler"], defines, void 0, void 0, void 0, void 0, this._shaderLanguage, this._shadersLoaded ? void 0 : async () => {
        if (this._shaderLanguage === 1) {
          await Promise.all([import("./layer.vertex-TEPX4UV7.js"), import("./layer.fragment-ZKVSNPQK.js")]);
        } else {
          await Promise.all([import("./layer.vertex-VCSVK63N.js"), import("./layer.fragment-2QZWZP55.js")]);
        }
        this._shadersLoaded = true;
      });
    }
    const currentEffect = this._drawWrapper.effect;
    return !!(currentEffect == null ? void 0 : currentEffect.isReady()) && (!this.texture || this.texture.isReady());
  }
  /**
   * Renders the layer in the scene.
   */
  render() {
    if (!this.isEnabled) {
      return;
    }
    const engine = this._scene.getEngine();
    if (!this.isReady()) {
      return;
    }
    const currentEffect = this._drawWrapper.effect;
    this.onBeforeRenderObservable.notifyObservers(this);
    engine.enableEffect(this._drawWrapper);
    engine.setState(false);
    if (this.texture) {
      currentEffect.setTexture("textureSampler", this.texture);
      currentEffect.setMatrix("textureMatrix", this.texture.getTextureMatrix());
    }
    currentEffect.setFloat4("color", this.color.r, this.color.g, this.color.b, this.color.a);
    currentEffect.setVector2("offset", this.offset);
    currentEffect.setVector2("scale", this.scale);
    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);
    if (!this.alphaTest) {
      engine.setAlphaMode(this.alphaBlendingMode);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
      engine.setAlphaMode(0);
    } else {
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    this.onAfterRenderObservable.notifyObservers(this);
  }
  /**
   * Disposes and releases the associated resources.
   */
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    this.renderTargetTextures = [];
    const index = this._scene.layers.indexOf(this);
    this._scene.layers.splice(index, 1);
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderObservable.clear();
  }
};
Layer.ForceGLSL = false;

export {
  DynamicTexture,
  ClipboardEventTypes,
  ClipboardInfo,
  NodeRenderGraphBlockConnectionPointTypes,
  NodeRenderGraphConnectionPointCompatibilityStates,
  NodeRenderGraphConnectionPointDirection,
  NodeRenderGraphConnectionPoint,
  NodeRenderGraphBlock,
  FrameGraphPass,
  FrameGraphCullPass,
  FrameGraphRenderPass,
  FrameGraphTask,
  LayerSceneComponent,
  Layer
};
//# sourceMappingURL=chunk-N2BWQOYP.js.map
