{
  "version": 3,
  "sources": ["../../../dev/core/src/Culling/ray.core.ts", "../../../dev/core/src/Materials/GaussianSplatting/gaussianSplattingMaterial.ts", "../../../dev/core/src/Maths/math.scalar.ts", "../../../dev/core/src/Meshes/GaussianSplatting/gaussianSplattingMesh.ts", "../../../dev/core/src/Particles/cloudPoint.ts", "../../../dev/core/src/Culling/ray.ts", "../../../dev/core/src/Particles/pointsCloudSystem.ts"],
  "sourcesContent": ["import { Epsilon } from \"core/Maths/math.constants\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport { BuildArray } from \"core/Misc/arrayTools\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport type { DeepImmutable, float, Nullable } from \"core/types\";\r\nimport type { Plane } from \"core/Maths/math.plane\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"core/Collisions/pickingInfo\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { _ImportHelper } from \"core/import.helper\";\r\n\r\n/**\r\n * Type used to define predicate for selecting meshes and instances (if exist)\r\n */\r\nexport type MeshPredicate = (mesh: AbstractMesh, thinInstanceIndex: number) => boolean;\r\n\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray, i0: number, i1: number, i2: number) => boolean;\r\n\r\n/**\r\n * This class allows user to customize internal picking mechanism\r\n */\r\nexport interface IPickingCustomization {\r\n    /**\r\n     * Predicate to select faces when a mesh intersection is detected\r\n     */\r\n    internalPickerForMesh?: (\r\n        pickingInfo: Nullable<PickingInfo>,\r\n        rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n        mesh: AbstractMesh,\r\n        world: Matrix,\r\n        fastCheck?: boolean,\r\n        onlyBoundingInfo?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        skipBoundingInfo?: boolean\r\n    ) => PickingInfo;\r\n}\r\n\r\n/**\r\n * Use this object to customize mesh picking behavior\r\n */\r\nexport const PickingCustomization: IPickingCustomization = {\r\n    internalPickerForMesh: undefined,\r\n};\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: 0)\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** [Number.MAX_VALUE] length of the ray */\r\n        public length: number = Number.MAX_VALUE,\r\n        /** [Epsilon] The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants) */\r\n        public epsilon: number = Epsilon\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < -this.epsilon || bv > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < -this.epsilon || bv + bw > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(\r\n        mesh: DeepImmutable<AbstractMesh>,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const D = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        return Ray.CreateFromToToRef(origin, end, result, world);\r\n    }\r\n\r\n    /**\r\n     * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param result the object to store the result\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the ref ray\r\n     */\r\n    public static CreateFromToToRef(origin: Vector3, end: Vector3, result: Ray, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        result.origin.copyFrom(origin);\r\n        const direction = end.subtractToRef(origin, result.direction);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        result.length = length;\r\n        result.direction.normalize();\r\n\r\n        return Ray.TransformToRef(result, world, result);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     * @returns the updated result ray\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): Ray {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n        result.epsilon = ray.epsilon;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n * @param camera defines the camera to use for the picking\r\n * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n * @returns a Ray\r\n */\r\nexport function CreatePickingRay(scene: Scene, x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n * @param result defines the ray where to store the picking ray\r\n * @param camera defines the camera to use for the picking\r\n * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n * @returns the current scene\r\n */\r\nexport function CreatePickingRayToRef(\r\n    scene: Scene,\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = scene.getEngine();\r\n\r\n    if (!camera && !(camera = scene.activeCamera!)) {\r\n        return scene;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return scene;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param camera defines the camera to use for the picking\r\n * @returns a Ray\r\n */\r\nexport function CreatePickingRayInCameraSpace(scene: Scene, x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param result defines the ray where to store the picking ray\r\n * @param camera defines the camera to use for the picking\r\n * @returns the current scene\r\n */\r\nexport function CreatePickingRayInCameraSpaceToRef(scene: Scene, x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return scene;\r\n    }\r\n\r\n    const engine = scene.getEngine();\r\n\r\n    if (!camera && !(camera = scene.activeCamera!)) {\r\n        throw new Error(\"Active camera not set\");\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n    result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());\r\n    return scene;\r\n}\r\n\r\nfunction InternalPickForMesh(\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction InternalPick(\r\n    scene: Scene,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): PickingInfo {\r\n    let pickingInfo = null;\r\n\r\n    const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);\r\n    const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;\r\n    const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;\r\n\r\n    for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {\r\n        const mesh = scene.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh, -1)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = picker(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    if (predicate && !predicate(mesh, index)) {\r\n                        continue;\r\n                    }\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = picker(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = picker(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n}\r\n\r\nfunction InternalMultiPick(\r\n    scene: Scene,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: MeshPredicate,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos: PickingInfo[] = [];\r\n    const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);\r\n    const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;\r\n    const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;\r\n\r\n    for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {\r\n        const mesh = scene.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh, -1)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = picker(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    if (predicate && !predicate(mesh, index)) {\r\n                        continue;\r\n                    }\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = picker(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = picker(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n}\r\n\r\n/** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\r\n * @param scene defines the scene to use for the picking\r\n * @param x position on screen\r\n * @param y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\r\n */\r\nexport function PickWithBoundingInfo(scene: Scene, x: number, y: number, predicate?: MeshPredicate, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = InternalPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._tempPickingRay) {\r\n                scene._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null);\r\n            return scene._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n}\r\n\r\n/** Launch a ray to try to pick a mesh in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x position on screen\r\n * @param y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @param _enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n * @returns a PickingInfo\r\n */\r\nexport function Pick(\r\n    scene: Scene,\r\n    x: number,\r\n    y: number,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    const result = InternalPick(\r\n        scene,\r\n        (world, enableDistantPicking) => {\r\n            if (!scene._tempPickingRay) {\r\n                scene._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return scene._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\r\n * irrespective of orientation.\r\n * @param scene defines the scene to use for the picking\r\n * @param ray The ray to use to pick meshes\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns a PickingInfo\r\n */\r\nexport function PickWithRay(scene: Scene, ray: Ray, predicate?: MeshPredicate, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    const result = InternalPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._pickWithRayInverseMatrix) {\r\n                scene._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(scene._pickWithRayInverseMatrix);\r\n\r\n            if (!scene._cachedRayForTransform) {\r\n                scene._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);\r\n            return scene._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\r\n * irrespective of orientation.\r\n * @param scene defines the scene to use for the picking\r\n * @param x X position on screen\r\n * @param y Y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns an array of PickingInfo\r\n */\r\nexport function MultiPick(scene: Scene, x: number, y: number, predicate?: MeshPredicate, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return InternalMultiPick(scene, (world) => CreatePickingRay(scene, x, y, world, camera || null), predicate, trianglePredicate);\r\n}\r\n\r\n/**\r\n * Launch a ray to try to pick a mesh in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param ray Ray to use\r\n * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns an array of PickingInfo\r\n */\r\nexport function MultiPickWithRay(scene: Scene, ray: Ray, predicate?: MeshPredicate, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return InternalMultiPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._pickWithRayInverseMatrix) {\r\n                scene._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(scene._pickWithRayInverseMatrix);\r\n\r\n            if (!scene._cachedRayForTransform) {\r\n                scene._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);\r\n            return scene._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n}\r\n\r\n/**\r\n * Gets a ray in the forward direction from the camera.\r\n * @param camera Defines the camera to use to get the ray from\r\n * @param length Defines the length of the ray to create\r\n * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray\r\n * @param origin Defines the start point of the ray which defaults to the camera position\r\n * @returns the forward ray\r\n */\r\nexport function GetForwardRay(camera: Camera, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return GetForwardRayToRef(camera, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n}\r\n\r\n/**\r\n * Gets a ray in the forward direction from the camera.\r\n * @param camera Defines the camera to use to get the ray from\r\n * @param refRay the ray to (re)use when setting the values\r\n * @param length Defines the length of the ray to create\r\n * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray\r\n * @param origin Defines the start point of the ray which defaults to the camera position\r\n * @returns the forward ray\r\n */\r\nexport function GetForwardRayToRef(camera: Camera, refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = camera.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (origin) {\r\n        refRay.origin.copyFrom(origin);\r\n    } else {\r\n        refRay.origin.copyFrom(camera.position);\r\n    }\r\n    const forward = TmpVectors.Vector3[2];\r\n    forward.set(0, 0, camera._scene.useRightHandedSystem ? -1 : 1);\r\n    const worldForward = TmpVectors.Vector3[3];\r\n    Vector3.TransformNormalToRef(forward, transform, worldForward);\r\n    Vector3.NormalizeToRef(worldForward, refRay.direction);\r\n\r\n    return refRay;\r\n}\r\n\r\n/**\r\n * Initialize the minimal interdependecies between the Ray and Scene and Camera\r\n * @param sceneClass defines the scene prototype to use\r\n * @param cameraClass defines the camera prototype to use\r\n */\r\nexport function AddRayExtensions(sceneClass: typeof Scene, cameraClass: typeof Camera): void {\r\n    if (cameraClass) {\r\n        cameraClass.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n            return GetForwardRayToRef(this, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n        };\r\n\r\n        cameraClass.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n            return GetForwardRayToRef(this, refRay, length, transform, origin);\r\n        };\r\n    }\r\n\r\n    if (!sceneClass) {\r\n        return;\r\n    }\r\n\r\n    _ImportHelper._IsPickingAvailable = true;\r\n\r\n    sceneClass.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n        return CreatePickingRay(this, x, y, world, camera, cameraViewSpace);\r\n    };\r\n}\r\n", "import type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport type { GaussianSplattingMesh } from \"core/Meshes\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\n\r\nimport \"../../Shaders/gaussianSplatting.fragment\";\r\nimport \"../../Shaders/gaussianSplatting.vertex\";\r\nimport \"../../ShadersWGSL/gaussianSplatting.fragment\";\r\nimport \"../../ShadersWGSL/gaussianSplatting.vertex\";\r\nimport {\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\n\r\n/**\r\n * @internal\r\n */\r\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\r\n    public FOG = false;\r\n    public THIN_INSTANCES = true;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public SH_DEGREE = 0;\r\n\r\n    /**\r\n     * Constructor of the defines.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * GaussianSplattingMaterial material used to render Gaussian Splatting\r\n * @experimental\r\n */\r\nexport class GaussianSplattingMaterial extends PushMaterial {\r\n    /**\r\n     * Instantiates a Gaussian Splatting Material in the given scene\r\n     * @param name The friendly name of the material\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.backFaceCulling = false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public override get hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns false\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns true\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the material is ready to be rendered for a given mesh.\r\n     * @param mesh The mesh to render\r\n     * @param subMesh The submesh to check against\r\n     * @returns true if all the dependencies are ready (Textures, Effects...)\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        const useInstances = true;\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GaussianSplattingMaterialDefines();\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, false);\r\n\r\n        // SH is disabled for webGL1\r\n        if (engine.version > 1 || engine.isWebGPU) {\r\n            defines[\"SH_DEGREE\"] = (<GaussianSplattingMesh>mesh).shDegree;\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind, \"splatIndex\"];\r\n\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const uniforms = [\"world\", \"view\", \"projection\", \"vFogInfos\", \"vFogColor\", \"logarithmicDepthConstant\", \"invViewport\", \"dataTextureSize\", \"focal\", \"vEyePosition\"];\r\n            const samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\", \"shTexture0\", \"shTexture1\", \"shTexture2\"];\r\n            const uniformBuffers = [\"Scene\", \"Mesh\"];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n            });\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const join = defines.toString();\r\n            const effect = scene.getEngine().createEffect(\r\n                \"gaussianSplatting\",\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: {},\r\n                    shaderLanguage: this._shaderLanguage,\r\n                    extraInitializationsAsync: async () => {\r\n                        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../ShadersWGSL/gaussianSplatting.fragment\"), import(\"../../ShadersWGSL/gaussianSplatting.vertex\")]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../Shaders/gaussianSplatting.fragment\"), import(\"../../Shaders/gaussianSplatting.vertex\")]);\r\n                        }\r\n                    },\r\n                },\r\n                engine\r\n            );\r\n            subMesh.setEffect(effect, defines, this._materialContext);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind material effect for a specific Gaussian Splatting mesh\r\n     * @param mesh Gaussian splatting mesh\r\n     * @param effect Splatting material or node material\r\n     * @param scene scene that contains mesh and camera used for rendering\r\n     */\r\n    public static BindEffect(mesh: Mesh, effect: Effect, scene: Scene): void {\r\n        const engine = scene.getEngine();\r\n        const camera = scene.activeCamera;\r\n\r\n        const renderWidth = engine.getRenderWidth();\r\n        const renderHeight = engine.getRenderHeight();\r\n\r\n        // check if rigcamera, get number of rigs\r\n        const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;\r\n\r\n        effect.setFloat2(\"invViewport\", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);\r\n\r\n        let focal = 1000;\r\n\r\n        if (camera) {\r\n            /*\r\n            more explicit version:\r\n            const t = camera.getProjectionMatrix().m[5];\r\n            const FovY = Math.atan(1.0 / t) * 2.0;\r\n            focal = renderHeight / 2.0 / Math.tan(FovY / 2.0);\r\n            Using a shorter version here to not have tan(atan) and 2.0 factor\r\n            */\r\n            const t = camera.getProjectionMatrix().m[5];\r\n            if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\r\n                focal = (renderHeight * t) / 2.0;\r\n            } else {\r\n                focal = (renderWidth * t) / 2.0;\r\n            }\r\n        }\r\n\r\n        effect.setFloat2(\"focal\", focal, focal);\r\n\r\n        const gsMesh = mesh as GaussianSplattingMesh;\r\n\r\n        if (gsMesh.covariancesATexture) {\r\n            const textureSize = gsMesh.covariancesATexture.getSize();\r\n\r\n            effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\r\n\r\n            effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\r\n            effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\r\n            effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\r\n            effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\r\n\r\n            if (gsMesh.shTextures) {\r\n                for (let i = 0; i < gsMesh.shTextures?.length; i++) {\r\n                    effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        // Bind data\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        if (mustRebind) {\r\n            this.bindView(effect);\r\n            this.bindViewProjection(effect);\r\n            GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, effect);\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth) {\r\n            BindLogDepth(defines, effect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Clones the material.\r\n     * @param name The cloned name.\r\n     * @returns The cloned material.\r\n     */\r\n    public override clone(name: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current material to its JSON representation.\r\n     * @returns The JSON representation.\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns \"GaussianSplattingMaterial\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GaussianSplattingMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON input to create back a Gaussian Splatting material.\r\n     * @param source The JSON data to parse\r\n     * @param scene The scene to create the parsed material in\r\n     * @param rootUrl The root url of the assets the material depends upon\r\n     * @returns the instantiated GaussianSplattingMaterial.\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport * as functions from \"./math.scalar.functions\";\r\n\r\nconst HCF: (a: number, b: number) => number = functions.HighestCommonFactor;\r\n\r\n/**\r\n * Scalar computation library\r\n */\r\nexport const Scalar = {\r\n    ...functions,\r\n\r\n    /**\r\n     * Two pi constants convenient for computation.\r\n     */\r\n    TwoPi: Math.PI * 2,\r\n\r\n    /**\r\n     * Returns -1 if value is negative and +1 is value is positive.\r\n     * @param value the value\r\n     * @returns the value itself if it's equal to zero.\r\n     */\r\n    Sign: Math.sign,\r\n\r\n    /**\r\n     * the log2 of value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    Log2: Math.log2,\r\n\r\n    /**\r\n     * Returns the highest common factor of two integers.\r\n     * @param a first parameter\r\n     * @param b second parameter\r\n     * @returns HCF of a and b\r\n     */\r\n    HCF,\r\n};\r\n/* eslint-enable @typescript-eslint/naming-convention */\r\n", "import type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { SubMesh } from \"../subMesh\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Matrix, TmpVectors, Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Quaternion } from \"core/Maths/math.vector\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport \"core/Meshes/thinInstanceMesh\";\r\nimport type { ThinEngine } from \"core/Engines/thinEngine\";\r\nimport { ToHalfFloat } from \"core/Misc/textureTools\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler, type Coroutine } from \"core/Misc/coroutine\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\ninterface DelayedTextureUpdate {\r\n    covA: Uint16Array;\r\n    covB: Uint16Array;\r\n    colors: Uint8Array;\r\n    centers: Float32Array;\r\n    sh?: Uint8Array[];\r\n}\r\n\r\n// @internal\r\nconst unpackUnorm = (value: number, bits: number) => {\r\n    const t = (1 << bits) - 1;\r\n    return (value & t) / t;\r\n};\r\n\r\n// @internal\r\nconst unpack111011 = (value: number, result: Vector3) => {\r\n    result.x = unpackUnorm(value >>> 21, 11);\r\n    result.y = unpackUnorm(value >>> 11, 10);\r\n    result.z = unpackUnorm(value, 11);\r\n};\r\n\r\n// @internal\r\nconst unpack8888 = (value: number, result: Uint8ClampedArray) => {\r\n    result[0] = unpackUnorm(value >>> 24, 8) * 255;\r\n    result[1] = unpackUnorm(value >>> 16, 8) * 255;\r\n    result[2] = unpackUnorm(value >>> 8, 8) * 255;\r\n    result[3] = unpackUnorm(value, 8) * 255;\r\n};\r\n\r\n// @internal\r\n// unpack quaternion with 2,10,10,10 format (largest element, 3x10bit element)\r\nconst unpackRot = (value: number, result: Quaternion) => {\r\n    const norm = 1.0 / (Math.sqrt(2) * 0.5);\r\n    const a = (unpackUnorm(value >>> 20, 10) - 0.5) * norm;\r\n    const b = (unpackUnorm(value >>> 10, 10) - 0.5) * norm;\r\n    const c = (unpackUnorm(value, 10) - 0.5) * norm;\r\n    const m = Math.sqrt(1.0 - (a * a + b * b + c * c));\r\n\r\n    switch (value >>> 30) {\r\n        case 0:\r\n            result.set(m, a, b, c);\r\n            break;\r\n        case 1:\r\n            result.set(a, m, b, c);\r\n            break;\r\n        case 2:\r\n            result.set(a, b, m, c);\r\n            break;\r\n        case 3:\r\n            result.set(a, b, c, m);\r\n            break;\r\n    }\r\n};\r\n\r\n// @internal\r\ninterface CompressedPLYChunk {\r\n    min: Vector3;\r\n    max: Vector3;\r\n    minScale: Vector3;\r\n    maxScale: Vector3;\r\n    minColor: Vector3;\r\n    maxColor: Vector3;\r\n}\r\n\r\n// @internal\r\ninterface PLYConversionBuffers {\r\n    buffer: ArrayBuffer;\r\n    sh?: [];\r\n}\r\n/**\r\n * Representation of the types\r\n */\r\nconst enum PLYType {\r\n    FLOAT,\r\n    INT,\r\n    UINT,\r\n    DOUBLE,\r\n    UCHAR,\r\n    UNDEFINED,\r\n}\r\n\r\n/**\r\n * Usage types of the PLY values\r\n */\r\nconst enum PLYValue {\r\n    MIN_X,\r\n    MIN_Y,\r\n    MIN_Z,\r\n    MAX_X,\r\n    MAX_Y,\r\n    MAX_Z,\r\n\r\n    MIN_SCALE_X,\r\n    MIN_SCALE_Y,\r\n    MIN_SCALE_Z,\r\n\r\n    MAX_SCALE_X,\r\n    MAX_SCALE_Y,\r\n    MAX_SCALE_Z,\r\n\r\n    PACKED_POSITION,\r\n    PACKED_ROTATION,\r\n    PACKED_SCALE,\r\n    PACKED_COLOR,\r\n    X,\r\n    Y,\r\n    Z,\r\n    SCALE_0,\r\n    SCALE_1,\r\n    SCALE_2,\r\n\r\n    DIFFUSE_RED,\r\n    DIFFUSE_GREEN,\r\n    DIFFUSE_BLUE,\r\n    OPACITY,\r\n\r\n    F_DC_0,\r\n    F_DC_1,\r\n    F_DC_2,\r\n    F_DC_3,\r\n\r\n    ROT_0,\r\n    ROT_1,\r\n    ROT_2,\r\n    ROT_3,\r\n\r\n    MIN_COLOR_R,\r\n    MIN_COLOR_G,\r\n    MIN_COLOR_B,\r\n\r\n    MAX_COLOR_R,\r\n    MAX_COLOR_G,\r\n    MAX_COLOR_B,\r\n\r\n    SH_0,\r\n    SH_1,\r\n    SH_2,\r\n    SH_3,\r\n    SH_4,\r\n    SH_5,\r\n    SH_6,\r\n    SH_7,\r\n    SH_8,\r\n    SH_9,\r\n    SH_10,\r\n    SH_11,\r\n    SH_12,\r\n    SH_13,\r\n    SH_14,\r\n    SH_15,\r\n    SH_16,\r\n    SH_17,\r\n    SH_18,\r\n    SH_19,\r\n    SH_20,\r\n    SH_21,\r\n    SH_22,\r\n    SH_23,\r\n    SH_24,\r\n    SH_25,\r\n    SH_26,\r\n    SH_27,\r\n    SH_28,\r\n    SH_29,\r\n    SH_30,\r\n    SH_31,\r\n    SH_32,\r\n    SH_33,\r\n    SH_34,\r\n    SH_35,\r\n    SH_36,\r\n    SH_37,\r\n    SH_38,\r\n    SH_39,\r\n    SH_40,\r\n    SH_41,\r\n    SH_42,\r\n    SH_43,\r\n    SH_44,\r\n\r\n    UNDEFINED,\r\n}\r\n\r\n/**\r\n * Property field found in PLY header\r\n */\r\nexport type PlyProperty = {\r\n    /**\r\n     * Value usage\r\n     */\r\n    value: PLYValue;\r\n    /**\r\n     * Value type\r\n     */\r\n    type: PLYType;\r\n    /**\r\n     * offset in byte from te beginning of the splat\r\n     */\r\n    offset: number;\r\n};\r\n\r\n/**\r\n * meta info on Splat file\r\n */\r\nexport interface PLYHeader {\r\n    /**\r\n     * number of splats\r\n     */\r\n    vertexCount: number;\r\n    /**\r\n     * number of spatial chunks for compressed ply\r\n     */\r\n    chunkCount: number;\r\n    /**\r\n     * length in bytes of the vertex info\r\n     */\r\n    rowVertexLength: number;\r\n    /**\r\n     * length in bytes of the chunk\r\n     */\r\n    rowChunkLength: number;\r\n    /**\r\n     * array listing properties per vertex\r\n     */\r\n    vertexProperties: PlyProperty[];\r\n    /**\r\n     * array listing properties per chunk\r\n     */\r\n    chunkProperties: PlyProperty[];\r\n    /**\r\n     * data view for parsing chunks and vertices\r\n     */\r\n    dataView: DataView;\r\n    /**\r\n     * buffer for the data view\r\n     */\r\n    buffer: ArrayBuffer;\r\n    /**\r\n     * degree of SH coefficients\r\n     */\r\n    shDegree: number;\r\n    /**\r\n     * number of coefficient per splat\r\n     */\r\n    shCoefficientCount: number;\r\n    /**\r\n     * buffer for SH coefficients\r\n     */\r\n    shBuffer: ArrayBuffer | null;\r\n}\r\n/**\r\n * Class used to render a gaussian splatting mesh\r\n */\r\nexport class GaussianSplattingMesh extends Mesh {\r\n    private _vertexCount = 0;\r\n    private _worker: Nullable<Worker> = null;\r\n    private _frameIdLastUpdate = -1;\r\n    private _modelViewMatrix = Matrix.Identity();\r\n    private _depthMix: BigInt64Array;\r\n    private _canPostToWorker = true;\r\n    private _readyToDisplay = false;\r\n    private _covariancesATexture: Nullable<BaseTexture> = null;\r\n    private _covariancesBTexture: Nullable<BaseTexture> = null;\r\n    private _centersTexture: Nullable<BaseTexture> = null;\r\n    private _colorsTexture: Nullable<BaseTexture> = null;\r\n    private _splatPositions: Nullable<Float32Array> = null;\r\n    private _splatIndex: Nullable<Float32Array> = null;\r\n    private _shTextures: Nullable<BaseTexture[]> = null;\r\n    private _splatsData: Nullable<ArrayBuffer> = null;\r\n    private _sh: Nullable<Uint8Array[]> = null;\r\n    private readonly _keepInRam: boolean = false;\r\n\r\n    private _delayedTextureUpdate: Nullable<DelayedTextureUpdate> = null;\r\n    private _oldDirection = new Vector3();\r\n    private _useRGBACovariants = false;\r\n    private _material: Nullable<Material> = null;\r\n\r\n    private _tmpCovariances = [0, 0, 0, 0, 0, 0];\r\n    private _sortIsDirty = false;\r\n\r\n    private static _RowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // Vector3 position, Vector3 scale, 1 u8 quaternion, 1 color with alpha\r\n    private static _SH_C0 = 0.28209479177387814;\r\n    // batch size between 2 yield calls. This value is a tradeoff between updates overhead and framerate hiccups\r\n    // This step is faster the PLY conversion. So batch size can be bigger\r\n    private static _SplatBatchSize = 327680;\r\n    // batch size between 2 yield calls during the PLY to splat conversion.\r\n    private static _PlyConversionBatchSize = 32768;\r\n    private _shDegree = 0;\r\n\r\n    /**\r\n     * SH degree. 0 = no sh (default). 1 = 3 parameters. 2 = 8 parameters. 3 = 15 parameters.\r\n     */\r\n    public get shDegree() {\r\n        return this._shDegree;\r\n    }\r\n\r\n    /**\r\n     * returns the splats data array buffer that contains in order : postions (3 floats), size (3 floats), color (4 bytes), orientation quaternion (4 bytes)\r\n     */\r\n    public get splatsData() {\r\n        return this._splatsData;\r\n    }\r\n\r\n    /**\r\n     * Set the number of batch (a batch is 16384 splats) after which a display update is performed\r\n     * A value of 0 (default) means display update will not happens before splat is ready.\r\n     */\r\n    public static ProgressiveUpdateAmount = 0;\r\n\r\n    /**\r\n     * Gets the covariancesA texture\r\n     */\r\n    public get covariancesATexture() {\r\n        return this._covariancesATexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the covariancesB texture\r\n     */\r\n    public get covariancesBTexture() {\r\n        return this._covariancesBTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the centers texture\r\n     */\r\n    public get centersTexture() {\r\n        return this._centersTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the colors texture\r\n     */\r\n    public get colorsTexture() {\r\n        return this._colorsTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the SH textures\r\n     */\r\n    public get shTextures() {\r\n        return this._shTextures;\r\n    }\r\n\r\n    /**\r\n     * set rendering material\r\n     */\r\n    public override set material(value: Material) {\r\n        this._material = value;\r\n        this._material.backFaceCulling = true;\r\n        this._material.cullBackFaces = false;\r\n        value.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * get rendering material\r\n     */\r\n    public override get material(): Nullable<Material> {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new gaussian splatting mesh\r\n     * @param name defines the name of the mesh\r\n     * @param url defines the url to load from (optional)\r\n     * @param scene defines the hosting scene (optional)\r\n     * @param keepInRam keep datas in ram for editing purpose\r\n     */\r\n    constructor(name: string, url: Nullable<string> = null, scene: Nullable<Scene> = null, keepInRam: boolean = false) {\r\n        super(name, scene);\r\n\r\n        const vertexData = new VertexData();\r\n\r\n        // Use an intanced quad or triangle. Triangle might be a bit faster because of less shader invocation but I didn't see any difference.\r\n        // Keeping both and use triangle for now.\r\n        // for quad, use following lines\r\n        //vertexData.positions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];\r\n        //vertexData.indices = [0, 1, 2, 0, 2, 3];\r\n        vertexData.positions = [-3, -2, 0, 3, -2, 0, 0, 4, 0];\r\n        vertexData.indices = [0, 1, 2];\r\n        vertexData.applyToMesh(this);\r\n\r\n        this.subMeshes = [];\r\n        // for quad, use following line\r\n        //new SubMesh(0, 0, 4, 0, 6, this);\r\n        new SubMesh(0, 0, 3, 0, 3, this);\r\n\r\n        this.setEnabled(false);\r\n        // webGL2 and webGPU support for RG texture with float16 is fine. not webGL1\r\n        this._useRGBACovariants = !this.getEngine().isWebGPU && this.getEngine().version === 1.0;\r\n\r\n        this._keepInRam = keepInRam;\r\n        if (url) {\r\n            this.loadFileAsync(url);\r\n        }\r\n        this._material = new GaussianSplattingMaterial(this.name + \"_material\", this._scene);\r\n    }\r\n\r\n    /**\r\n     * Returns the class name\r\n     * @returns \"GaussianSplattingMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GaussianSplattingMesh\";\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (splats) within the mesh\r\n     * @returns the total number of vertices\r\n     */\r\n    public override getTotalVertices(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns true when ready\r\n     */\r\n    public override isReady(completeCheck = false): boolean {\r\n        if (!super.isReady(completeCheck, true)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._readyToDisplay) {\r\n            // mesh is ready when worker has done at least 1 sorting\r\n            this._postToWorker(true);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postToWorker(forced = false): void {\r\n        const frameId = this.getScene().getFrameId();\r\n        if ((forced || frameId !== this._frameIdLastUpdate) && this._worker && this._scene.activeCamera && this._canPostToWorker) {\r\n            const cameraMatrix = this._scene.activeCamera.getViewMatrix();\r\n            this.getWorldMatrix().multiplyToRef(cameraMatrix, this._modelViewMatrix);\r\n            cameraMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n            this.getWorldMatrix().multiplyToRef(TmpVectors.Matrix[0], TmpVectors.Matrix[1]);\r\n            Vector3.TransformNormalToRef(Vector3.Forward(this._scene.useRightHandedSystem), TmpVectors.Matrix[1], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[2].normalize();\r\n\r\n            const dot = Vector3.Dot(TmpVectors.Vector3[2], this._oldDirection);\r\n            if (forced || Math.abs(dot - 1) >= 0.01) {\r\n                this._oldDirection.copyFrom(TmpVectors.Vector3[2]);\r\n                this._frameIdLastUpdate = frameId;\r\n                this._canPostToWorker = false;\r\n                this._worker.postMessage({ view: this._modelViewMatrix.m, depthMix: this._depthMix, useRightHandedSystem: this._scene.useRightHandedSystem }, [\r\n                    this._depthMix.buffer,\r\n                ]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\r\n     * @param subMesh defines the subMesh to render\r\n     * @param enableAlphaMode defines if alpha mode can be changed\r\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\r\n     * @returns the current mesh\r\n     */\r\n    public override render(subMesh: SubMesh, enableAlphaMode: boolean, effectiveMeshReplacement?: AbstractMesh): Mesh {\r\n        this._postToWorker();\r\n        return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);\r\n    }\r\n\r\n    private static _TypeNameToEnum(name: string): PLYType {\r\n        switch (name) {\r\n            case \"float\":\r\n                return PLYType.FLOAT;\r\n            case \"int\":\r\n                return PLYType.INT;\r\n                break;\r\n            case \"uint\":\r\n                return PLYType.UINT;\r\n            case \"double\":\r\n                return PLYType.DOUBLE;\r\n            case \"uchar\":\r\n                return PLYType.UCHAR;\r\n        }\r\n        return PLYType.UNDEFINED;\r\n    }\r\n\r\n    private static _ValueNameToEnum(name: string): PLYValue {\r\n        switch (name) {\r\n            case \"min_x\":\r\n                return PLYValue.MIN_X;\r\n            case \"min_y\":\r\n                return PLYValue.MIN_Y;\r\n            case \"min_z\":\r\n                return PLYValue.MIN_Z;\r\n            case \"max_x\":\r\n                return PLYValue.MAX_X;\r\n            case \"max_y\":\r\n                return PLYValue.MAX_Y;\r\n            case \"max_z\":\r\n                return PLYValue.MAX_Z;\r\n            case \"min_scale_x\":\r\n                return PLYValue.MIN_SCALE_X;\r\n            case \"min_scale_y\":\r\n                return PLYValue.MIN_SCALE_Y;\r\n            case \"min_scale_z\":\r\n                return PLYValue.MIN_SCALE_Z;\r\n            case \"max_scale_x\":\r\n                return PLYValue.MAX_SCALE_X;\r\n            case \"max_scale_y\":\r\n                return PLYValue.MAX_SCALE_Y;\r\n            case \"max_scale_z\":\r\n                return PLYValue.MAX_SCALE_Z;\r\n            case \"packed_position\":\r\n                return PLYValue.PACKED_POSITION;\r\n            case \"packed_rotation\":\r\n                return PLYValue.PACKED_ROTATION;\r\n            case \"packed_scale\":\r\n                return PLYValue.PACKED_SCALE;\r\n            case \"packed_color\":\r\n                return PLYValue.PACKED_COLOR;\r\n            case \"x\":\r\n                return PLYValue.X;\r\n            case \"y\":\r\n                return PLYValue.Y;\r\n            case \"z\":\r\n                return PLYValue.Z;\r\n            case \"scale_0\":\r\n                return PLYValue.SCALE_0;\r\n            case \"scale_1\":\r\n                return PLYValue.SCALE_1;\r\n            case \"scale_2\":\r\n                return PLYValue.SCALE_2;\r\n            case \"diffuse_red\":\r\n            case \"red\":\r\n                return PLYValue.DIFFUSE_RED;\r\n            case \"diffuse_green\":\r\n            case \"green\":\r\n                return PLYValue.DIFFUSE_GREEN;\r\n            case \"diffuse_blue\":\r\n            case \"blue\":\r\n                return PLYValue.DIFFUSE_BLUE;\r\n            case \"f_dc_0\":\r\n                return PLYValue.F_DC_0;\r\n            case \"f_dc_1\":\r\n                return PLYValue.F_DC_1;\r\n            case \"f_dc_2\":\r\n                return PLYValue.F_DC_2;\r\n            case \"f_dc_3\":\r\n                return PLYValue.F_DC_3;\r\n            case \"opacity\":\r\n                return PLYValue.OPACITY;\r\n            case \"rot_0\":\r\n                return PLYValue.ROT_0;\r\n            case \"rot_1\":\r\n                return PLYValue.ROT_1;\r\n            case \"rot_2\":\r\n                return PLYValue.ROT_2;\r\n            case \"rot_3\":\r\n                return PLYValue.ROT_3;\r\n            case \"min_r\":\r\n                return PLYValue.MIN_COLOR_R;\r\n            case \"min_g\":\r\n                return PLYValue.MIN_COLOR_G;\r\n            case \"min_b\":\r\n                return PLYValue.MIN_COLOR_B;\r\n            case \"max_r\":\r\n                return PLYValue.MAX_COLOR_R;\r\n            case \"max_g\":\r\n                return PLYValue.MAX_COLOR_G;\r\n            case \"max_b\":\r\n                return PLYValue.MAX_COLOR_B;\r\n            case \"f_rest_0\":\r\n                return PLYValue.SH_0;\r\n            case \"f_rest_1\":\r\n                return PLYValue.SH_1;\r\n            case \"f_rest_2\":\r\n                return PLYValue.SH_2;\r\n            case \"f_rest_3\":\r\n                return PLYValue.SH_3;\r\n            case \"f_rest_4\":\r\n                return PLYValue.SH_4;\r\n            case \"f_rest_5\":\r\n                return PLYValue.SH_5;\r\n            case \"f_rest_6\":\r\n                return PLYValue.SH_6;\r\n            case \"f_rest_7\":\r\n                return PLYValue.SH_7;\r\n            case \"f_rest_8\":\r\n                return PLYValue.SH_8;\r\n            case \"f_rest_9\":\r\n                return PLYValue.SH_9;\r\n            case \"f_rest_10\":\r\n                return PLYValue.SH_10;\r\n            case \"f_rest_11\":\r\n                return PLYValue.SH_11;\r\n            case \"f_rest_12\":\r\n                return PLYValue.SH_12;\r\n            case \"f_rest_13\":\r\n                return PLYValue.SH_13;\r\n            case \"f_rest_14\":\r\n                return PLYValue.SH_14;\r\n            case \"f_rest_15\":\r\n                return PLYValue.SH_15;\r\n            case \"f_rest_16\":\r\n                return PLYValue.SH_16;\r\n            case \"f_rest_17\":\r\n                return PLYValue.SH_17;\r\n            case \"f_rest_18\":\r\n                return PLYValue.SH_18;\r\n            case \"f_rest_19\":\r\n                return PLYValue.SH_19;\r\n            case \"f_rest_20\":\r\n                return PLYValue.SH_20;\r\n            case \"f_rest_21\":\r\n                return PLYValue.SH_21;\r\n            case \"f_rest_22\":\r\n                return PLYValue.SH_22;\r\n            case \"f_rest_23\":\r\n                return PLYValue.SH_23;\r\n            case \"f_rest_24\":\r\n                return PLYValue.SH_24;\r\n            case \"f_rest_25\":\r\n                return PLYValue.SH_25;\r\n            case \"f_rest_26\":\r\n                return PLYValue.SH_26;\r\n            case \"f_rest_27\":\r\n                return PLYValue.SH_27;\r\n            case \"f_rest_28\":\r\n                return PLYValue.SH_28;\r\n            case \"f_rest_29\":\r\n                return PLYValue.SH_29;\r\n            case \"f_rest_30\":\r\n                return PLYValue.SH_30;\r\n            case \"f_rest_31\":\r\n                return PLYValue.SH_31;\r\n            case \"f_rest_32\":\r\n                return PLYValue.SH_32;\r\n            case \"f_rest_33\":\r\n                return PLYValue.SH_33;\r\n            case \"f_rest_34\":\r\n                return PLYValue.SH_34;\r\n            case \"f_rest_35\":\r\n                return PLYValue.SH_35;\r\n            case \"f_rest_36\":\r\n                return PLYValue.SH_36;\r\n            case \"f_rest_37\":\r\n                return PLYValue.SH_37;\r\n            case \"f_rest_38\":\r\n                return PLYValue.SH_38;\r\n            case \"f_rest_39\":\r\n                return PLYValue.SH_39;\r\n            case \"f_rest_40\":\r\n                return PLYValue.SH_40;\r\n            case \"f_rest_41\":\r\n                return PLYValue.SH_41;\r\n            case \"f_rest_42\":\r\n                return PLYValue.SH_42;\r\n            case \"f_rest_43\":\r\n                return PLYValue.SH_43;\r\n            case \"f_rest_44\":\r\n                return PLYValue.SH_44;\r\n        }\r\n\r\n        return PLYValue.UNDEFINED;\r\n    }\r\n    /**\r\n     * Parse a PLY file header and returns metas infos on splats and chunks\r\n     * @param data the loaded buffer\r\n     * @returns a PLYHeader\r\n     */\r\n    static ParseHeader(data: ArrayBuffer): PLYHeader | null {\r\n        const ubuf = new Uint8Array(data);\r\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\r\n        const headerEnd = \"end_header\\n\";\r\n        const headerEndIndex = header.indexOf(headerEnd);\r\n        if (headerEndIndex < 0 || !header) {\r\n            // standard splat\r\n            return null;\r\n        }\r\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)![1]);\r\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\r\n        let chunkCount = 0;\r\n        if (chunkElement) {\r\n            chunkCount = parseInt(chunkElement[1]);\r\n        }\r\n        let rowVertexOffset = 0;\r\n        let rowChunkOffset = 0;\r\n        const offsets: Record<string, number> = {\r\n            double: 8,\r\n            int: 4,\r\n            uint: 4,\r\n            float: 4,\r\n            short: 2,\r\n            ushort: 2,\r\n            uchar: 1,\r\n            list: 0,\r\n        };\r\n\r\n        const enum ElementMode {\r\n            Vertex = 0,\r\n            Chunk = 1,\r\n        }\r\n        let chunkMode = ElementMode.Chunk;\r\n        const vertexProperties: PlyProperty[] = [];\r\n        const chunkProperties: PlyProperty[] = [];\r\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\r\n        let shDegree = 0;\r\n        for (const prop of filtered) {\r\n            if (prop.startsWith(\"property \")) {\r\n                const [, typeName, name] = prop.split(\" \");\r\n\r\n                const value = GaussianSplattingMesh._ValueNameToEnum(name);\r\n                // SH degree 1,2 or 3 for 9, 24 or 45 values\r\n                if (value >= PLYValue.SH_44) {\r\n                    shDegree = 3;\r\n                } else if (value >= PLYValue.SH_24) {\r\n                    shDegree = 2;\r\n                } else if (value >= PLYValue.SH_8) {\r\n                    shDegree = 1;\r\n                }\r\n                const type = GaussianSplattingMesh._TypeNameToEnum(typeName);\r\n                if (chunkMode == ElementMode.Chunk) {\r\n                    chunkProperties.push({ value, type, offset: rowChunkOffset });\r\n                    rowChunkOffset += offsets[typeName];\r\n                } else if (chunkMode == ElementMode.Vertex) {\r\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\r\n                    rowVertexOffset += offsets[typeName];\r\n                }\r\n\r\n                if (!offsets[typeName]) {\r\n                    Logger.Warn(`Unsupported property type: ${typeName}.`);\r\n                }\r\n            } else if (prop.startsWith(\"element \")) {\r\n                const [, type] = prop.split(\" \");\r\n                if (type == \"chunk\") {\r\n                    chunkMode = ElementMode.Chunk;\r\n                } else if (type == \"vertex\") {\r\n                    chunkMode = ElementMode.Vertex;\r\n                }\r\n            }\r\n        }\r\n\r\n        const dataView = new DataView(data, headerEndIndex + headerEnd.length);\r\n        const buffer = new ArrayBuffer(GaussianSplattingMesh._RowOutputLength * vertexCount);\r\n\r\n        let shBuffer = null;\r\n        let shCoefficientCount = 0;\r\n        if (shDegree) {\r\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;\r\n            shCoefficientCount = shVectorCount * 3;\r\n            shBuffer = new ArrayBuffer(shCoefficientCount * vertexCount);\r\n        }\r\n\r\n        return {\r\n            vertexCount: vertexCount,\r\n            chunkCount: chunkCount,\r\n            rowVertexLength: rowVertexOffset,\r\n            rowChunkLength: rowChunkOffset,\r\n            vertexProperties: vertexProperties,\r\n            chunkProperties: chunkProperties,\r\n            dataView: dataView,\r\n            buffer: buffer,\r\n            shDegree: shDegree,\r\n            shCoefficientCount: shCoefficientCount,\r\n            shBuffer: shBuffer,\r\n        };\r\n    }\r\n    private static _GetCompressedChunks(header: PLYHeader, offset: { value: number }): Array<CompressedPLYChunk> | null {\r\n        if (!header.chunkCount) {\r\n            return null;\r\n        }\r\n        const dataView = header.dataView;\r\n        const compressedChunks = new Array<CompressedPLYChunk>(header.chunkCount);\r\n        for (let i = 0; i < header.chunkCount; i++) {\r\n            const currentChunk = {\r\n                min: new Vector3(),\r\n                max: new Vector3(),\r\n                minScale: new Vector3(),\r\n                maxScale: new Vector3(),\r\n                minColor: new Vector3(0, 0, 0),\r\n                maxColor: new Vector3(1, 1, 1),\r\n            };\r\n            compressedChunks[i] = currentChunk;\r\n            for (let propertyIndex = 0; propertyIndex < header.chunkProperties.length; propertyIndex++) {\r\n                const property = header.chunkProperties[propertyIndex];\r\n                let value;\r\n                switch (property.type) {\r\n                    case PLYType.FLOAT:\r\n                        value = dataView.getFloat32(property.offset + offset.value, true);\r\n                        break;\r\n                    default:\r\n                        continue;\r\n                }\r\n\r\n                switch (property.value) {\r\n                    case PLYValue.MIN_X:\r\n                        currentChunk.min.x = value;\r\n                        break;\r\n                    case PLYValue.MIN_Y:\r\n                        currentChunk.min.y = value;\r\n                        break;\r\n                    case PLYValue.MIN_Z:\r\n                        currentChunk.min.z = value;\r\n                        break;\r\n                    case PLYValue.MAX_X:\r\n                        currentChunk.max.x = value;\r\n                        break;\r\n                    case PLYValue.MAX_Y:\r\n                        currentChunk.max.y = value;\r\n                        break;\r\n                    case PLYValue.MAX_Z:\r\n                        currentChunk.max.z = value;\r\n                        break;\r\n                    case PLYValue.MIN_SCALE_X:\r\n                        currentChunk.minScale.x = value;\r\n                        break;\r\n                    case PLYValue.MIN_SCALE_Y:\r\n                        currentChunk.minScale.y = value;\r\n                        break;\r\n                    case PLYValue.MIN_SCALE_Z:\r\n                        currentChunk.minScale.z = value;\r\n                        break;\r\n                    case PLYValue.MAX_SCALE_X:\r\n                        currentChunk.maxScale.x = value;\r\n                        break;\r\n                    case PLYValue.MAX_SCALE_Y:\r\n                        currentChunk.maxScale.y = value;\r\n                        break;\r\n                    case PLYValue.MAX_SCALE_Z:\r\n                        currentChunk.maxScale.z = value;\r\n                        break;\r\n                    case PLYValue.MIN_COLOR_R:\r\n                        currentChunk.minColor.x = value;\r\n                        break;\r\n                    case PLYValue.MIN_COLOR_G:\r\n                        currentChunk.minColor.y = value;\r\n                        break;\r\n                    case PLYValue.MIN_COLOR_B:\r\n                        currentChunk.minColor.z = value;\r\n                        break;\r\n                    case PLYValue.MAX_COLOR_R:\r\n                        currentChunk.maxColor.x = value;\r\n                        break;\r\n                    case PLYValue.MAX_COLOR_G:\r\n                        currentChunk.maxColor.y = value;\r\n                        break;\r\n                    case PLYValue.MAX_COLOR_B:\r\n                        currentChunk.maxColor.z = value;\r\n                        break;\r\n                }\r\n            }\r\n            offset.value += header.rowChunkLength;\r\n        }\r\n        return compressedChunks;\r\n    }\r\n\r\n    private static _GetSplat(header: PLYHeader, index: number, compressedChunks: Array<CompressedPLYChunk> | null, offset: { value: number }): void {\r\n        const q = TmpVectors.Quaternion[0];\r\n        const temp3 = TmpVectors.Vector3[0];\r\n\r\n        const rowOutputLength = GaussianSplattingMesh._RowOutputLength;\r\n        const buffer = header.buffer;\r\n        const dataView = header.dataView;\r\n        const position = new Float32Array(buffer, index * rowOutputLength, 3);\r\n        const scale = new Float32Array(buffer, index * rowOutputLength + 12, 3);\r\n        const rgba = new Uint8ClampedArray(buffer, index * rowOutputLength + 24, 4);\r\n        const rot = new Uint8ClampedArray(buffer, index * rowOutputLength + 28, 4);\r\n        let sh = null;\r\n        if (header.shBuffer) {\r\n            sh = new Uint8ClampedArray(header.shBuffer, index * header.shCoefficientCount, header.shCoefficientCount);\r\n        }\r\n        const chunkIndex = index >> 8;\r\n        let r0: number = 255;\r\n        let r1: number = 0;\r\n        let r2: number = 0;\r\n        let r3: number = 0;\r\n\r\n        for (let propertyIndex = 0; propertyIndex < header.vertexProperties.length; propertyIndex++) {\r\n            const property = header.vertexProperties[propertyIndex];\r\n            let value;\r\n            switch (property.type) {\r\n                case PLYType.FLOAT:\r\n                    value = dataView.getFloat32(offset.value + property.offset, true);\r\n                    break;\r\n                case PLYType.INT:\r\n                    value = dataView.getInt32(offset.value + property.offset, true);\r\n                    break;\r\n                case PLYType.UINT:\r\n                    value = dataView.getUint32(offset.value + property.offset, true);\r\n                    break;\r\n                case PLYType.DOUBLE:\r\n                    value = dataView.getFloat64(offset.value + property.offset, true);\r\n                    break;\r\n                case PLYType.UCHAR:\r\n                    value = dataView.getUint8(offset.value + property.offset);\r\n                    break;\r\n                default:\r\n                    continue;\r\n            }\r\n\r\n            switch (property.value) {\r\n                case PLYValue.PACKED_POSITION:\r\n                    {\r\n                        const compressedChunk = compressedChunks![chunkIndex];\r\n                        unpack111011(value, temp3);\r\n                        position[0] = Scalar.Lerp(compressedChunk.min.x, compressedChunk.max.x, temp3.x);\r\n                        position[1] = Scalar.Lerp(compressedChunk.min.y, compressedChunk.max.y, temp3.y);\r\n                        position[2] = Scalar.Lerp(compressedChunk.min.z, compressedChunk.max.z, temp3.z);\r\n                    }\r\n                    break;\r\n                case PLYValue.PACKED_ROTATION:\r\n                    {\r\n                        unpackRot(value, q);\r\n                        r0 = q.w;\r\n                        r1 = -q.z;\r\n                        r2 = q.y;\r\n                        r3 = -q.x;\r\n                    }\r\n                    break;\r\n                case PLYValue.PACKED_SCALE:\r\n                    {\r\n                        const compressedChunk = compressedChunks![chunkIndex];\r\n                        unpack111011(value, temp3);\r\n                        scale[0] = Math.exp(Scalar.Lerp(compressedChunk.minScale.x, compressedChunk.maxScale.x, temp3.x));\r\n                        scale[1] = Math.exp(Scalar.Lerp(compressedChunk.minScale.y, compressedChunk.maxScale.y, temp3.y));\r\n                        scale[2] = Math.exp(Scalar.Lerp(compressedChunk.minScale.z, compressedChunk.maxScale.z, temp3.z));\r\n                    }\r\n                    break;\r\n                case PLYValue.PACKED_COLOR:\r\n                    {\r\n                        const compressedChunk = compressedChunks![chunkIndex];\r\n                        unpack8888(value, rgba);\r\n                        rgba[0] = Scalar.Lerp(compressedChunk.minColor.x, compressedChunk.maxColor.x, rgba[0] / 255) * 255;\r\n                        rgba[1] = Scalar.Lerp(compressedChunk.minColor.y, compressedChunk.maxColor.y, rgba[1] / 255) * 255;\r\n                        rgba[2] = Scalar.Lerp(compressedChunk.minColor.z, compressedChunk.maxColor.z, rgba[2] / 255) * 255;\r\n                    }\r\n                    break;\r\n                case PLYValue.X:\r\n                    position[0] = value;\r\n                    break;\r\n                case PLYValue.Y:\r\n                    position[1] = value;\r\n                    break;\r\n                case PLYValue.Z:\r\n                    position[2] = value;\r\n                    break;\r\n                case PLYValue.SCALE_0:\r\n                    scale[0] = Math.exp(value);\r\n                    break;\r\n                case PLYValue.SCALE_1:\r\n                    scale[1] = Math.exp(value);\r\n                    break;\r\n                case PLYValue.SCALE_2:\r\n                    scale[2] = Math.exp(value);\r\n                    break;\r\n                case PLYValue.DIFFUSE_RED:\r\n                    rgba[0] = value;\r\n                    break;\r\n                case PLYValue.DIFFUSE_GREEN:\r\n                    rgba[1] = value;\r\n                    break;\r\n                case PLYValue.DIFFUSE_BLUE:\r\n                    rgba[2] = value;\r\n                    break;\r\n                case PLYValue.F_DC_0:\r\n                    rgba[0] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\r\n                    break;\r\n                case PLYValue.F_DC_1:\r\n                    rgba[1] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\r\n                    break;\r\n                case PLYValue.F_DC_2:\r\n                    rgba[2] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\r\n                    break;\r\n                case PLYValue.F_DC_3:\r\n                    rgba[3] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\r\n                    break;\r\n                case PLYValue.OPACITY:\r\n                    rgba[3] = (1 / (1 + Math.exp(-value))) * 255;\r\n                    break;\r\n                case PLYValue.ROT_0:\r\n                    r0 = value;\r\n                    break;\r\n                case PLYValue.ROT_1:\r\n                    r1 = value;\r\n                    break;\r\n                case PLYValue.ROT_2:\r\n                    r2 = value;\r\n                    break;\r\n                case PLYValue.ROT_3:\r\n                    r3 = value;\r\n                    break;\r\n            }\r\n            if (sh && property.value >= PLYValue.SH_0 && property.value <= PLYValue.SH_44) {\r\n                const clampedValue = Scalar.Clamp(value * 127.5 + 127.5, 0, 255);\r\n                const shIndex = property.value - PLYValue.SH_0;\r\n                sh[shIndex] = clampedValue;\r\n            }\r\n        }\r\n\r\n        q.set(r1, r2, r3, r0);\r\n        q.normalize();\r\n        rot[0] = q.w * 128 + 128;\r\n        rot[1] = q.x * 128 + 128;\r\n        rot[2] = q.y * 128 + 128;\r\n        rot[3] = q.z * 128 + 128;\r\n        offset.value += header.rowVertexLength;\r\n    }\r\n\r\n    /**\r\n     * Converts a .ply data with SH coefficients splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @param useCoroutine use coroutine and yield\r\n     * @returns the loaded splat buffer and optional array of sh coefficients\r\n     */\r\n    public static *ConvertPLYWithSHToSplat(data: ArrayBuffer, useCoroutine = false) {\r\n        const header = GaussianSplattingMesh.ParseHeader(data);\r\n        if (!header) {\r\n            return { buffer: data };\r\n        }\r\n\r\n        const offset = { value: 0 };\r\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\r\n\r\n        for (let i = 0; i < header.vertexCount; i++) {\r\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\r\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        let sh = null;\r\n        // make SH texture buffers\r\n        if (header.shDegree && header.shBuffer) {\r\n            const textureCount = Math.ceil(header.shCoefficientCount / 16); // 4 components can be stored per texture, 4 sh per component\r\n            let shIndexRead = 0;\r\n            const ubuf = new Uint8Array(header.shBuffer);\r\n\r\n            // sh is an array of uint8array that will be used to create sh textures\r\n            sh = [];\r\n\r\n            const splatCount = header.vertexCount;\r\n            const engine = EngineStore.LastCreatedEngine;\r\n            if (engine) {\r\n                const width = engine.getCaps().maxTextureSize;\r\n                const height = Math.ceil(splatCount / width);\r\n                // create array for the number of textures needed.\r\n                for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\r\n                    const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\r\n                    sh.push(texture);\r\n                }\r\n\r\n                for (let i = 0; i < splatCount; i++) {\r\n                    for (let shIndexWrite = 0; shIndexWrite < header.shCoefficientCount; shIndexWrite++) {\r\n                        const shValue = ubuf[shIndexRead++];\r\n\r\n                        const textureIndex = Math.floor(shIndexWrite / 16);\r\n                        const shArray = sh[textureIndex];\r\n\r\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n                        shArray[byteIndexInTexture + offsetPerSplat] = shValue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return { buffer: header.buffer, sh: sh };\r\n    }\r\n\r\n    /**\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @param useCoroutine use coroutine and yield\r\n     * @returns the loaded splat buffer without SH coefficient, whether ply contains or not SH.\r\n     */\r\n    public static *ConvertPLYToSplat(data: ArrayBuffer, useCoroutine = false) {\r\n        const header = GaussianSplattingMesh.ParseHeader(data);\r\n        if (!header) {\r\n            return data;\r\n        }\r\n\r\n        const offset = { value: 0 };\r\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\r\n\r\n        for (let i = 0; i < header.vertexCount; i++) {\r\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\r\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        return header.buffer;\r\n    }\r\n\r\n    /**\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer\r\n     */\r\n    public static async ConvertPLYToSplatAsync(data: ArrayBuffer) {\r\n        return runCoroutineAsync(GaussianSplattingMesh.ConvertPLYToSplat(data, true), createYieldingScheduler());\r\n    }\r\n\r\n    /**\r\n     * Converts a .ply with SH data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer with SH\r\n     */\r\n    public static async ConvertPLYWithSHToSplatAsync(data: ArrayBuffer) {\r\n        return runCoroutineAsync(GaussianSplattingMesh.ConvertPLYWithSHToSplat(data, true), createYieldingScheduler());\r\n    }\r\n    /**\r\n     * Loads a .splat Gaussian Splatting array buffer asynchronously\r\n     * @param data arraybuffer containing splat file\r\n     * @returns a promise that resolves when the operation is complete\r\n     */\r\n\r\n    public loadDataAsync(data: ArrayBuffer): Promise<void> {\r\n        return this.updateDataAsync(data);\r\n    }\r\n\r\n    /**\r\n     * Loads a .splat Gaussian or .ply Splatting file asynchronously\r\n     * @param url path to the splat file to load\r\n     * @returns a promise that resolves when the operation is complete\r\n     * @deprecated Please use SceneLoader.ImportMeshAsync instead\r\n     */\r\n    public loadFileAsync(url: string): Promise<void> {\r\n        return Tools.LoadFileAsync(url, true).then(async (plyBuffer) => {\r\n            (GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(plyBuffer) as any).then((splatsData: PLYConversionBuffers) => {\r\n                this.updateDataAsync(splatsData.buffer, splatsData.sh);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean): void {\r\n        this._covariancesATexture?.dispose();\r\n        this._covariancesBTexture?.dispose();\r\n        this._centersTexture?.dispose();\r\n        this._colorsTexture?.dispose();\r\n        if (this._shTextures) {\r\n            this._shTextures.forEach((shTexture) => {\r\n                shTexture.dispose();\r\n            });\r\n        }\r\n\r\n        this._covariancesATexture = null;\r\n        this._covariancesBTexture = null;\r\n        this._centersTexture = null;\r\n        this._colorsTexture = null;\r\n        this._shTextures = null;\r\n\r\n        this._worker?.terminate();\r\n        this._worker = null;\r\n\r\n        super.dispose(doNotRecurse, true);\r\n    }\r\n\r\n    private _copyTextures(source: GaussianSplattingMesh): void {\r\n        this._covariancesATexture = source.covariancesATexture?.clone()!;\r\n        this._covariancesBTexture = source.covariancesBTexture?.clone()!;\r\n        this._centersTexture = source.centersTexture?.clone()!;\r\n        this._colorsTexture = source.colorsTexture?.clone()!;\r\n        if (source._shTextures) {\r\n            this._shTextures = [];\r\n            this._shTextures.forEach((shTexture) => {\r\n                this._shTextures?.push(shTexture.clone()!);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new Mesh object generated from the current mesh properties.\r\n     * @param name is a string, the name given to the new mesh\r\n     * @returns a new Gaussian Splatting Mesh\r\n     */\r\n    public override clone(name: string = \"\"): GaussianSplattingMesh {\r\n        const newGS = new GaussianSplattingMesh(name, undefined, this.getScene());\r\n        newGS._copySource(this);\r\n        newGS.makeGeometryUnique();\r\n        newGS._vertexCount = this._vertexCount;\r\n        newGS._copyTextures(this);\r\n        newGS._modelViewMatrix = Matrix.Identity();\r\n        newGS._splatPositions = this._splatPositions;\r\n        newGS._readyToDisplay = false;\r\n        newGS._instanciateWorker();\r\n\r\n        const binfo = this.getBoundingInfo();\r\n        newGS.getBoundingInfo().reConstruct(binfo.minimum, binfo.maximum, this.getWorldMatrix());\r\n\r\n        newGS.forcedInstanceCount = newGS._vertexCount;\r\n        newGS.setEnabled(true);\r\n        return newGS;\r\n    }\r\n\r\n    private static _CreateWorker = function (self: Worker) {\r\n        let vertexCount = 0;\r\n        let positions: Float32Array;\r\n        let depthMix: BigInt64Array;\r\n        let indices: Uint32Array;\r\n        let floatMix: Float32Array;\r\n\r\n        self.onmessage = (e: any) => {\r\n            // updated on init\r\n            if (e.data.positions) {\r\n                positions = e.data.positions;\r\n                vertexCount = e.data.vertexCount;\r\n            }\r\n            // udpate on view changed\r\n            else {\r\n                const viewProj = e.data.view;\r\n                if (!positions || !viewProj) {\r\n                    // Sanity check, it shouldn't happen!\r\n                    throw new Error(\"positions or view is not defined!\");\r\n                }\r\n\r\n                depthMix = e.data.depthMix;\r\n                indices = new Uint32Array(depthMix.buffer);\r\n                floatMix = new Float32Array(depthMix.buffer);\r\n\r\n                // Sort\r\n                for (let j = 0; j < vertexCount; j++) {\r\n                    indices[2 * j] = j;\r\n                }\r\n\r\n                let depthFactor = -1;\r\n                if (e.data.useRightHandedSystem) {\r\n                    depthFactor = 1;\r\n                }\r\n\r\n                for (let j = 0; j < vertexCount; j++) {\r\n                    floatMix[2 * j + 1] = 10000 + (viewProj[2] * positions[4 * j + 0] + viewProj[6] * positions[4 * j + 1] + viewProj[10] * positions[4 * j + 2]) * depthFactor;\r\n                }\r\n\r\n                depthMix.sort();\r\n\r\n                self.postMessage({ depthMix }, [depthMix.buffer]);\r\n            }\r\n        };\r\n    };\r\n\r\n    private _makeSplat(\r\n        index: number,\r\n        fBuffer: Float32Array,\r\n        uBuffer: Uint8Array,\r\n        covA: Uint16Array,\r\n        covB: Uint16Array,\r\n        colorArray: Uint8Array,\r\n        minimum: Vector3,\r\n        maximum: Vector3\r\n    ): void {\r\n        const matrixRotation = TmpVectors.Matrix[0];\r\n        const matrixScale = TmpVectors.Matrix[1];\r\n        const quaternion = TmpVectors.Quaternion[0];\r\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\r\n\r\n        const x = fBuffer[8 * index + 0];\r\n        const y = -fBuffer[8 * index + 1];\r\n        const z = fBuffer[8 * index + 2];\r\n\r\n        this._splatPositions![4 * index + 0] = x;\r\n        this._splatPositions![4 * index + 1] = y;\r\n        this._splatPositions![4 * index + 2] = z;\r\n\r\n        minimum.minimizeInPlaceFromFloats(x, y, z);\r\n        maximum.maximizeInPlaceFromFloats(x, y, z);\r\n\r\n        quaternion.set(\r\n            (uBuffer[32 * index + 28 + 1] - 127.5) / 127.5,\r\n            (uBuffer[32 * index + 28 + 2] - 127.5) / 127.5,\r\n            (uBuffer[32 * index + 28 + 3] - 127.5) / 127.5,\r\n            -(uBuffer[32 * index + 28 + 0] - 127.5) / 127.5\r\n        );\r\n        quaternion.toRotationMatrix(matrixRotation);\r\n\r\n        Matrix.ScalingToRef(fBuffer[8 * index + 3 + 0] * 2, fBuffer[8 * index + 3 + 1] * 2, fBuffer[8 * index + 3 + 2] * 2, matrixScale);\r\n\r\n        const M = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;\r\n\r\n        const covariances = this._tmpCovariances;\r\n        covariances[0] = M[0] * M[0] + M[1] * M[1] + M[2] * M[2];\r\n        covariances[1] = M[0] * M[4] + M[1] * M[5] + M[2] * M[6];\r\n        covariances[2] = M[0] * M[8] + M[1] * M[9] + M[2] * M[10];\r\n        covariances[3] = M[4] * M[4] + M[5] * M[5] + M[6] * M[6];\r\n        covariances[4] = M[4] * M[8] + M[5] * M[9] + M[6] * M[10];\r\n        covariances[5] = M[8] * M[8] + M[9] * M[9] + M[10] * M[10];\r\n\r\n        // normalize covA, covB\r\n        let factor = -10000;\r\n        for (let covIndex = 0; covIndex < 6; covIndex++) {\r\n            factor = Math.max(factor, Math.abs(covariances[covIndex]));\r\n        }\r\n\r\n        this._splatPositions![4 * index + 3] = factor;\r\n        const transform = factor;\r\n\r\n        covA[index * 4 + 0] = ToHalfFloat(covariances[0] / transform);\r\n        covA[index * 4 + 1] = ToHalfFloat(covariances[1] / transform);\r\n        covA[index * 4 + 2] = ToHalfFloat(covariances[2] / transform);\r\n        covA[index * 4 + 3] = ToHalfFloat(covariances[3] / transform);\r\n        covB[index * covBSItemSize + 0] = ToHalfFloat(covariances[4] / transform);\r\n        covB[index * covBSItemSize + 1] = ToHalfFloat(covariances[5] / transform);\r\n\r\n        // colors\r\n        colorArray[index * 4 + 0] = uBuffer[32 * index + 24 + 0];\r\n        colorArray[index * 4 + 1] = uBuffer[32 * index + 24 + 1];\r\n        colorArray[index * 4 + 2] = uBuffer[32 * index + 24 + 2];\r\n        colorArray[index * 4 + 3] = uBuffer[32 * index + 24 + 3];\r\n    }\r\n\r\n    private _updateTextures(covA: Uint16Array, covB: Uint16Array, colorArray: Uint8Array, sh?: Uint8Array[]): void {\r\n        const textureSize = this._getTextureSize(this._vertexCount);\r\n        // Update the textures\r\n        const createTextureFromData = (data: Float32Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\r\n        };\r\n\r\n        const createTextureFromDataU8 = (data: Uint8Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_BYTE);\r\n        };\r\n\r\n        const createTextureFromDataU32 = (data: Uint32Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_INTEGER);\r\n        };\r\n\r\n        const createTextureFromDataF16 = (data: Uint16Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_HALF_FLOAT);\r\n        };\r\n\r\n        if (this._covariancesATexture) {\r\n            this._delayedTextureUpdate = { covA: covA, covB: covB, colors: colorArray, centers: this._splatPositions!, sh: sh };\r\n            const positions = Float32Array.from(this._splatPositions!);\r\n            const vertexCount = this._vertexCount;\r\n            this._worker!.postMessage({ positions, vertexCount }, [positions.buffer]);\r\n\r\n            this._postToWorker(true);\r\n        } else {\r\n            this._covariancesATexture = createTextureFromDataF16(covA, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n            this._covariancesBTexture = createTextureFromDataF16(\r\n                covB,\r\n                textureSize.x,\r\n                textureSize.y,\r\n                this._useRGBACovariants ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_RG\r\n            );\r\n            this._centersTexture = createTextureFromData(this._splatPositions!, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n            this._colorsTexture = createTextureFromDataU8(colorArray, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n            if (sh) {\r\n                this._shTextures = [];\r\n                sh.forEach((shData) => {\r\n                    const buffer = new Uint32Array(shData.buffer);\r\n                    const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA_INTEGER);\r\n                    shTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    shTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    this._shTextures!.push(shTexture);\r\n                });\r\n            }\r\n            this._instanciateWorker();\r\n        }\r\n    }\r\n\r\n    private *_updateData(data: ArrayBuffer, isAsync: boolean, sh?: Uint8Array[]): Coroutine<void> {\r\n        // if a covariance texture is present, then it's not a creation but an update\r\n        if (!this._covariancesATexture) {\r\n            this._readyToDisplay = false;\r\n        }\r\n\r\n        // Parse the data\r\n        const uBuffer = new Uint8Array(data);\r\n        const fBuffer = new Float32Array(uBuffer.buffer);\r\n\r\n        if (this._keepInRam) {\r\n            this._splatsData = data;\r\n            if (sh) {\r\n                this._sh = sh;\r\n            }\r\n        }\r\n\r\n        const vertexCount = uBuffer.length / GaussianSplattingMesh._RowOutputLength;\r\n        if (vertexCount != this._vertexCount) {\r\n            this._updateSplatIndexBuffer(vertexCount);\r\n        }\r\n        this._vertexCount = vertexCount;\r\n        // degree == 1 for 1 texture (3 terms), 2 for 2 textures(8 terms) and 3 for 3 textures (15 terms)\r\n        this._shDegree = sh ? sh.length : 0;\r\n\r\n        const textureSize = this._getTextureSize(vertexCount);\r\n        const textureLength = textureSize.x * textureSize.y;\r\n        const lineCountUpdate = GaussianSplattingMesh.ProgressiveUpdateAmount ?? textureSize.y;\r\n        const textureLengthPerUpdate = textureSize.x * lineCountUpdate;\r\n\r\n        this._splatPositions = new Float32Array(4 * textureLength);\r\n        const covA = new Uint16Array(textureLength * 4);\r\n        const covB = new Uint16Array((this._useRGBACovariants ? 4 : 2) * textureLength);\r\n        const colorArray = new Uint8Array(textureLength * 4);\r\n\r\n        const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        if (GaussianSplattingMesh.ProgressiveUpdateAmount) {\r\n            // create textures with not filled-yet array, then update directly portions of it\r\n            this._updateTextures(covA, covB, colorArray, sh);\r\n            this.setEnabled(true);\r\n\r\n            const partCount = Math.ceil(textureSize.y / lineCountUpdate);\r\n            for (let partIndex = 0; partIndex < partCount; partIndex++) {\r\n                const updateLine = partIndex * lineCountUpdate;\r\n                const splatIndexBase = updateLine * textureSize.x;\r\n                for (let i = 0; i < textureLengthPerUpdate; i++) {\r\n                    this._makeSplat(splatIndexBase + i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);\r\n                }\r\n                this._updateSubTextures(this._splatPositions, covA, covB, colorArray, updateLine, Math.min(lineCountUpdate, textureSize.y - updateLine));\r\n                // Update the binfo\r\n                this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\r\n                if (isAsync) {\r\n                    yield;\r\n                }\r\n            }\r\n\r\n            // sort will be dirty here as just finished filled positions will not be sorted\r\n            const positions = Float32Array.from(this._splatPositions!);\r\n            const vertexCount = this._vertexCount;\r\n            this._worker!.postMessage({ positions, vertexCount }, [positions.buffer]);\r\n            this._sortIsDirty = true;\r\n        } else {\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                this._makeSplat(i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);\r\n                if (isAsync && i % GaussianSplattingMesh._SplatBatchSize === 0) {\r\n                    yield;\r\n                }\r\n            }\r\n            // textures\r\n            this._updateTextures(covA, covB, colorArray, sh);\r\n            // Update the binfo\r\n            this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\r\n            this.setEnabled(true);\r\n        }\r\n        this._postToWorker(true);\r\n    }\r\n\r\n    /**\r\n     * Update asynchronously the buffer\r\n     * @param data array buffer containing center, color, orientation and scale of splats\r\n     * @param sh optional array of uint8 array for SH data\r\n     * @returns a promise\r\n     */\r\n    public async updateDataAsync(data: ArrayBuffer, sh?: Uint8Array[]): Promise<void> {\r\n        return runCoroutineAsync(this._updateData(data, true, sh), createYieldingScheduler());\r\n    }\r\n\r\n    /**\r\n     * @experimental\r\n     * Update data from GS (position, orientation, color, scaling)\r\n     * @param data array that contain all the datas\r\n     * @param sh optional array of uint8 array for SH data\r\n     */\r\n    public updateData(data: ArrayBuffer, sh?: Uint8Array[]): void {\r\n        runCoroutineSync(this._updateData(data, false, sh));\r\n    }\r\n\r\n    /**\r\n     * Refreshes the bounding info, taking into account all the thin instances defined\r\n     * @returns the current Gaussian Splatting\r\n     */\r\n    public override refreshBoundingInfo(): Mesh {\r\n        this.thinInstanceRefreshBoundingInfo(false);\r\n        return this;\r\n    }\r\n\r\n    // in case size is different\r\n    private _updateSplatIndexBuffer(vertexCount: number): void {\r\n        if (!this._splatIndex || vertexCount > this._splatIndex.length) {\r\n            this._splatIndex = new Float32Array(vertexCount);\r\n\r\n            this.thinInstanceSetBuffer(\"splatIndex\", this._splatIndex, 1, false);\r\n        }\r\n        this.forcedInstanceCount = vertexCount;\r\n    }\r\n\r\n    private _updateSubTextures(centers: Float32Array, covA: Uint16Array, covB: Uint16Array, colors: Uint8Array, lineStart: number, lineCount: number, sh?: Uint8Array[]): void {\r\n        const updateTextureFromData = (texture: BaseTexture, data: ArrayBufferView, width: number, lineStart: number, lineCount: number) => {\r\n            (this.getEngine() as ThinEngine).updateTextureData(texture.getInternalTexture()!, data, 0, lineStart, width, lineCount, 0, 0, false);\r\n        };\r\n\r\n        const textureSize = this._getTextureSize(this._vertexCount);\r\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\r\n        const texelStart = lineStart * textureSize.x;\r\n        const texelCount = lineCount * textureSize.x;\r\n        const covAView = new Uint16Array(covA.buffer, texelStart * 4 * Uint16Array.BYTES_PER_ELEMENT, texelCount * 4);\r\n        const covBView = new Uint16Array(covB.buffer, texelStart * covBSItemSize * Uint16Array.BYTES_PER_ELEMENT, texelCount * covBSItemSize);\r\n        const colorsView = new Uint8Array(colors.buffer, texelStart * 4, texelCount * 4);\r\n        const centersView = new Float32Array(centers.buffer, texelStart * 4 * Float32Array.BYTES_PER_ELEMENT, texelCount * 4);\r\n        updateTextureFromData(this._covariancesATexture!, covAView, textureSize.x, lineStart, lineCount);\r\n        updateTextureFromData(this._covariancesBTexture!, covBView, textureSize.x, lineStart, lineCount);\r\n        updateTextureFromData(this._centersTexture!, centersView, textureSize.x, lineStart, lineCount);\r\n        updateTextureFromData(this._colorsTexture!, colorsView, textureSize.x, lineStart, lineCount);\r\n        if (sh) {\r\n            for (let i = 0; i < sh.length; i++) {\r\n                const componentCount = 4;\r\n                const shView = new Uint8Array(this._sh![i].buffer, texelStart * componentCount, texelCount * componentCount);\r\n                updateTextureFromData(this._shTextures![i], shView, textureSize.x, lineStart, lineCount);\r\n            }\r\n        }\r\n    }\r\n    private _instanciateWorker(): void {\r\n        if (!this._vertexCount) {\r\n            return;\r\n        }\r\n        this._updateSplatIndexBuffer(this._vertexCount);\r\n\r\n        // Start the worker thread\r\n        this._worker?.terminate();\r\n        this._worker = new Worker(\r\n            URL.createObjectURL(\r\n                new Blob([\"(\", GaussianSplattingMesh._CreateWorker.toString(), \")(self)\"], {\r\n                    type: \"application/javascript\",\r\n                })\r\n            )\r\n        );\r\n\r\n        this._depthMix = new BigInt64Array(this._vertexCount);\r\n        const positions = Float32Array.from(this._splatPositions!);\r\n        const vertexCount = this._vertexCount;\r\n\r\n        this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\r\n\r\n        this._worker.onmessage = (e) => {\r\n            this._depthMix = e.data.depthMix;\r\n            const indexMix = new Uint32Array(e.data.depthMix.buffer);\r\n            if (this._splatIndex) {\r\n                for (let j = 0; j < this._vertexCount; j++) {\r\n                    this._splatIndex[j] = indexMix[2 * j];\r\n                }\r\n            }\r\n            if (this._delayedTextureUpdate) {\r\n                const textureSize = this._getTextureSize(vertexCount);\r\n                this._updateSubTextures(\r\n                    this._delayedTextureUpdate.centers,\r\n                    this._delayedTextureUpdate.covA,\r\n                    this._delayedTextureUpdate.covB,\r\n                    this._delayedTextureUpdate.colors,\r\n                    0,\r\n                    textureSize.y,\r\n                    this._delayedTextureUpdate.sh\r\n                );\r\n                this._delayedTextureUpdate = null;\r\n            }\r\n            this.thinInstanceBufferUpdated(\"splatIndex\");\r\n            this._canPostToWorker = true;\r\n            this._readyToDisplay = true;\r\n            // sort is dirty when GS is visible for progressive update with a this message arriving but positions were partially filled\r\n            // another update needs to be kicked. The kick can't happen just when the position buffer is ready because _canPostToWorker might be false.\r\n            if (this._sortIsDirty) {\r\n                this._postToWorker(true);\r\n                this._sortIsDirty = false;\r\n            }\r\n        };\r\n    }\r\n\r\n    private _getTextureSize(length: number): Vector2 {\r\n        const engine = this._scene.getEngine();\r\n        const width = engine.getCaps().maxTextureSize;\r\n\r\n        let height = 1;\r\n\r\n        if (engine.version === 1 && !engine.isWebGPU) {\r\n            while (width * height < length) {\r\n                height *= 2;\r\n            }\r\n        } else {\r\n            height = Math.ceil(length / width);\r\n        }\r\n\r\n        if (height > width) {\r\n            Logger.Error(\"GaussianSplatting texture size: (\" + width + \", \" + height + \"), maxTextureSize: \" + width);\r\n            height = width;\r\n        }\r\n\r\n        return new Vector2(width, height);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math\";\r\nimport { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { PointsCloudSystem } from \"./pointsCloudSystem\";\r\n/**\r\n * Represents one particle of a points cloud system.\r\n */\r\nexport class CloudPoint {\r\n    /**\r\n     * particle global index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * The color of the particle\r\n     */\r\n    public color: Nullable<Color4> = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * The world space position of the particle.\r\n     */\r\n    public position: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\r\n    public rotation: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation quaternion of the particle.\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The uv of the particle.\r\n     */\r\n    public uv: Nullable<Vector2> = new Vector2(0.0, 0.0);\r\n    /**\r\n     * The current speed of the particle.\r\n     */\r\n    public velocity: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\r\n    public pivot: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\r\n    public translateFromPivot: boolean = false;\r\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @internal\r\n     */\r\n    public _pos: number = 0;\r\n    /**\r\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\r\n     */\r\n    public _ind: number = 0;\r\n    /**\r\n     * Group this particle belongs to\r\n     */\r\n    public _group: PointsGroup;\r\n    /**\r\n     * Group id of this particle\r\n     */\r\n    public groupId: number = 0;\r\n    /**\r\n     * Index of the particle in its group id (Internal use)\r\n     */\r\n    public idxInGroup: number = 0;\r\n    /**\r\n     * @internal Particle BoundingInfo object (Internal use)\r\n     */\r\n    public _boundingInfo: BoundingInfo;\r\n    /**\r\n     * @internal Reference to the PCS that the particle belongs to (Internal use)\r\n     */\r\n    public _pcs: PointsCloudSystem;\r\n    /**\r\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\r\n     */\r\n    public _stillInvisible: boolean = false;\r\n    /**\r\n     * @internal Last computed particle rotation matrix\r\n     */\r\n    public _rotationMatrix: number[] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\r\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\r\n    public parentId: Nullable<number> = null;\r\n    /**\r\n     * @internal Internal global position in the PCS.\r\n     */\r\n    public _globalPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a Point Cloud object.\r\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\r\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\r\n     * @param group (PointsGroup) is the group the particle belongs to\r\n     * @param groupId (integer) is the group identifier in the PCS.\r\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\r\n     * @param pcs defines the PCS it is associated to\r\n     */\r\n    constructor(particleIndex: number, group: PointsGroup, groupId: number, idxInGroup: number, pcs: PointsCloudSystem) {\r\n        this.idx = particleIndex;\r\n        this._group = group;\r\n        this.groupId = groupId;\r\n        this.idxInGroup = idxInGroup;\r\n        this._pcs = pcs;\r\n    }\r\n\r\n    /**\r\n     * get point size\r\n     */\r\n    public get size(): Vector3 {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Set point size\r\n     */\r\n    public set size(scale: Vector3) {\r\n        this.size = scale;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public get quaternion(): Nullable<Quaternion> {\r\n        return this.rotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public set quaternion(q: Nullable<Quaternion>) {\r\n        this.rotationQuaternion = q;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean. True if the particle intersects a mesh, else false\r\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\r\n     * @param target is the object (point or mesh) what the intersection is computed against\r\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\r\n     * @returns true if it intersects\r\n     */\r\n    public intersectsMesh(target: Mesh, isSphere: boolean): boolean {\r\n        if (!target.hasBoundingInfo) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._pcs.mesh) {\r\n            throw new Error(\"Point Cloud System doesnt contain the Mesh\");\r\n        }\r\n\r\n        if (isSphere) {\r\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\r\n        }\r\n\r\n        const bbox = target.getBoundingInfo().boundingBox;\r\n\r\n        const maxX = bbox.maximumWorld.x;\r\n        const minX = bbox.minimumWorld.x;\r\n        const maxY = bbox.maximumWorld.y;\r\n        const minY = bbox.minimumWorld.y;\r\n        const maxZ = bbox.maximumWorld.z;\r\n        const minZ = bbox.minimumWorld.z;\r\n\r\n        const x = this.position.x + this._pcs.mesh.position.x;\r\n        const y = this.position.y + this._pcs.mesh.position.y;\r\n        const z = this.position.z + this._pcs.mesh.position.z;\r\n\r\n        return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\r\n    }\r\n\r\n    /**\r\n     * get the rotation matrix of the particle\r\n     * @internal\r\n     */\r\n    public getRotationMatrix(m: Matrix) {\r\n        let quaternion: Quaternion;\r\n        if (this.rotationQuaternion) {\r\n            quaternion = this.rotationQuaternion;\r\n        } else {\r\n            quaternion = TmpVectors.Quaternion[0];\r\n            const rotation = this.rotation;\r\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n        }\r\n\r\n        quaternion.toRotationMatrix(m);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a group of points in a points cloud system\r\n *  * PCS internal tool, don't use it manually.\r\n */\r\nexport class PointsGroup {\r\n    /**\r\n     * Get or set the groupId\r\n     * @deprecated Please use groupId instead\r\n     */\r\n    public get groupID(): number {\r\n        return this.groupId;\r\n    }\r\n    public set groupID(groupID: number) {\r\n        this.groupId = groupID;\r\n    }\r\n    /**\r\n     * The group id\r\n     * @internal\r\n     */\r\n    public groupId: number;\r\n    /**\r\n     * image data for group (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImageData: Nullable<ArrayBufferView>;\r\n    /**\r\n     * Image Width (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImgWidth: number;\r\n    /**\r\n     * Image Height (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImgHeight: number;\r\n    /**\r\n     * Custom position function (internal use)\r\n     * @internal\r\n     */\r\n    public _positionFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>;\r\n    /**\r\n     * density per facet for surface points\r\n     * @internal\r\n     */\r\n    public _groupDensity: number[];\r\n    /**\r\n     * Only when points are colored by texture carries pointer to texture list array\r\n     * @internal\r\n     */\r\n    public _textureNb: number;\r\n\r\n    /**\r\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\r\n     * PCS internal tool, don't use it manually.\r\n     * @internal\r\n     */\r\n    constructor(id: number, posFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>) {\r\n        this.groupId = id;\r\n        this._positionFunction = posFunction;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\n\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\n\r\nimport type { MeshPredicate, TrianglePickingPredicate, Ray } from \"./ray.core\";\r\nimport {\r\n    AddRayExtensions,\r\n    CreatePickingRayInCameraSpace,\r\n    CreatePickingRayInCameraSpaceToRef,\r\n    CreatePickingRayToRef,\r\n    MultiPick,\r\n    MultiPickWithRay,\r\n    Pick,\r\n    PickWithBoundingInfo,\r\n    PickWithRay,\r\n} from \"./ray.core\";\r\n\r\nexport * from \"./ray.core\";\r\n\r\n// Picking\r\nAddRayExtensions(Scene, Camera);\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    return CreatePickingRayToRef(this, x, y, world, result, camera, cameraViewSpace, enableDistantPicking);\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    return CreatePickingRayInCameraSpace(this, x, y, camera);\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    return CreatePickingRayInCameraSpaceToRef(this, x, y, result, camera);\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (x: number, y: number, predicate?: MeshPredicate, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n    return PickWithBoundingInfo(this, x, y, predicate, fastCheck, camera);\r\n};\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    return Pick(this, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking);\r\n};\r\n\r\nScene.prototype.pickWithRay = function (ray: Ray, predicate?: MeshPredicate, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    return PickWithRay(this, ray, predicate, fastCheck, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPick = function (x: number, y: number, predicate?: MeshPredicate, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return MultiPick(this, x, y, predicate, camera, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: MeshPredicate, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return MultiPickWithRay(this, ray, predicate, trianglePredicate);\r\n};\r\n", "import type { IndicesArray, FloatArray } from \"../types\";\r\nimport { Color4, Color3 } from \"../Maths/math\";\r\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\r\nimport { RandomRange } from \"../Maths/math.scalar.functions\";\r\nimport type { Material } from \"../Materials/material\";\r\n\r\n/** Defines the 4 color options */\r\nexport const enum PointColor {\r\n    /** color value */\r\n    Color = 2,\r\n    /** uv value */\r\n    UV = 1,\r\n    /** random value */\r\n    Random = 0,\r\n    /** stated value */\r\n    Stated = 3,\r\n}\r\n\r\n/**\r\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\r\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : TO BE ENTERED\r\n */\r\nexport class PointsCloudSystem implements IDisposable {\r\n    /**\r\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\r\n    public particles: CloudPoint[] = new Array<CloudPoint>();\r\n    /**\r\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\r\n     */\r\n    public nbParticles: number = 0;\r\n    /**\r\n     * This a counter for your own usage. It's not set by any SPS functions.\r\n     */\r\n    public counter: number = 0;\r\n    /**\r\n     * The PCS name. This name is also given to the underlying mesh.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The PCS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are available.\r\n     */\r\n    public mesh?: Mesh;\r\n    /**\r\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read :\r\n     */\r\n    public vars: any = {};\r\n    /**\r\n     * @internal\r\n     */\r\n    public _size: number; //size of each point particle\r\n\r\n    private _scene: Scene;\r\n    private _promises: Array<Promise<any>> = [];\r\n    private _positions: number[] = new Array<number>();\r\n    private _indices: number[] = new Array<number>();\r\n    private _normals: number[] = new Array<number>();\r\n    private _colors: number[] = new Array<number>();\r\n    private _uvs: number[] = new Array<number>();\r\n    private _indices32: IndicesArray; // used as depth sorted array if depth sort enabled, else used as typed indices\r\n    private _positions32: Float32Array; // updated positions for the VBO\r\n    private _colors32: Float32Array;\r\n    private _uvs32: Float32Array;\r\n    private _updatable: boolean = true;\r\n    private _isVisibilityBoxLocked = false;\r\n    private _alwaysVisible: boolean = false;\r\n    private _groups: number[] = new Array<number>(); //start indices for each group of particles\r\n    private _groupCounter: number = 0;\r\n    private _computeParticleColor: boolean = true;\r\n    private _computeParticleTexture: boolean = true;\r\n    private _computeParticleRotation: boolean = true;\r\n    private _computeBoundingBox: boolean = false;\r\n    private _isReady: boolean = false;\r\n\r\n    /**\r\n     * Gets the particle positions computed by the Point Cloud System\r\n     */\r\n    public get positions(): Float32Array {\r\n        return this._positions32;\r\n    }\r\n\r\n    /**\r\n     * Gets the particle colors computed by the Point Cloud System\r\n     */\r\n    public get colors(): Float32Array {\r\n        return this._colors32;\r\n    }\r\n\r\n    /**\r\n     * Gets the particle uvs computed by the Point Cloud System\r\n     */\r\n    public get uvs(): Float32Array {\r\n        return this._uvs32;\r\n    }\r\n\r\n    /**\r\n     * Creates a PCS (Points Cloud System) object\r\n     * @param name (String) is the PCS name, this will be the underlying mesh name\r\n     * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\r\n     * @param scene (Scene) is the scene in which the PCS is added\r\n     * @param options defines the options of the PCS e.g.\r\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\r\n     */\r\n    constructor(name: string, pointSize: number, scene: Scene, options?: { updatable?: boolean }) {\r\n        this.name = name;\r\n        this._size = pointSize;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        if (options && options.updatable !== undefined) {\r\n            this._updatable = options.updatable;\r\n        } else {\r\n            this._updatable = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\r\n     * If no points were added to the PCS, the returned mesh is just a single point.\r\n     * @param material The material to use to render the mesh. If not provided, will create a default one\r\n     * @returns a promise for the created mesh\r\n     */\r\n    public buildMeshAsync(material?: Material): Promise<Mesh> {\r\n        return Promise.all(this._promises).then(() => {\r\n            this._isReady = true;\r\n            return this._buildMesh(material);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _buildMesh(material?: Material): Promise<Mesh> {\r\n        if (this.nbParticles === 0) {\r\n            this.addPoints(1);\r\n        }\r\n\r\n        this._positions32 = new Float32Array(this._positions);\r\n        this._uvs32 = new Float32Array(this._uvs);\r\n        this._colors32 = new Float32Array(this._colors);\r\n\r\n        const vertexData = new VertexData();\r\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\r\n\r\n        if (this._uvs32.length > 0) {\r\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\r\n        }\r\n        let ec = 0; //emissive color value 0 for UVs, 1 for color\r\n        if (this._colors32.length > 0) {\r\n            ec = 1;\r\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\r\n        }\r\n        const mesh = new Mesh(this.name, this._scene);\r\n        vertexData.applyToMesh(mesh, this._updatable);\r\n        this.mesh = mesh;\r\n\r\n        // free memory\r\n        (<any>this._positions) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n\r\n        if (!this._updatable) {\r\n            this.particles.length = 0;\r\n        }\r\n\r\n        let mat = material;\r\n\r\n        if (!mat) {\r\n            mat = new StandardMaterial(\"point cloud material\", this._scene);\r\n            (<StandardMaterial>mat).emissiveColor = new Color3(ec, ec, ec);\r\n            (<StandardMaterial>mat).disableLighting = true;\r\n            (<StandardMaterial>mat).pointsCloud = true;\r\n            (<StandardMaterial>mat).pointSize = this._size;\r\n        }\r\n        mesh.material = mat;\r\n\r\n        return new Promise((resolve) => resolve(mesh));\r\n    }\r\n\r\n    // adds a new particle object in the particles array\r\n    private _addParticle(idx: number, group: PointsGroup, groupId: number, idxInGroup: number): CloudPoint {\r\n        const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\r\n        this.particles.push(cp);\r\n        return cp;\r\n    }\r\n\r\n    private _randomUnitVector(particle: CloudPoint): void {\r\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\r\n        particle.color = new Color4(1, 1, 1, 1);\r\n    }\r\n\r\n    private _getColorIndicesForCoord(pointsGroup: PointsGroup, x: number, y: number, width: number): Color4 {\r\n        const imageData = <Uint8Array>pointsGroup._groupImageData;\r\n        const color = y * (width * 4) + x * 4;\r\n        const colorIndices = [color, color + 1, color + 2, color + 3];\r\n        const redIndex = colorIndices[0];\r\n        const greenIndex = colorIndices[1];\r\n        const blueIndex = colorIndices[2];\r\n        const alphaIndex = colorIndices[3];\r\n        const redForCoord = imageData[redIndex];\r\n        const greenForCoord = imageData[greenIndex];\r\n        const blueForCoord = imageData[blueIndex];\r\n        const alphaForCoord = imageData[alphaIndex];\r\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\r\n    }\r\n\r\n    private _setPointsColorOrUV(\r\n        mesh: Mesh,\r\n        pointsGroup: PointsGroup,\r\n        isVolume: boolean,\r\n        colorFromTexture?: boolean,\r\n        hasTexture?: boolean,\r\n        color?: Color4,\r\n        range?: number,\r\n        uvSetIndex?: number\r\n    ): void {\r\n        uvSetIndex = uvSetIndex ?? 0;\r\n\r\n        if (isVolume) {\r\n            mesh.updateFacetData();\r\n        }\r\n\r\n        const boundInfo = mesh.getBoundingInfo();\r\n        const diameter = 2 * boundInfo.boundingSphere.radius;\r\n\r\n        let meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n        const meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind + (uvSetIndex ? uvSetIndex + 1 : \"\"));\r\n        const meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const place = Vector3.Zero();\r\n        mesh.computeWorldMatrix();\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        if (!meshMatrix.isIdentity()) {\r\n            meshPos = meshPos.slice(0);\r\n            for (let p = 0; p < meshPos.length / 3; p++) {\r\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\r\n                meshPos[3 * p] = place.x;\r\n                meshPos[3 * p + 1] = place.y;\r\n                meshPos[3 * p + 2] = place.z;\r\n            }\r\n        }\r\n\r\n        let idxPoints: number = 0;\r\n\r\n        let id0: number = 0;\r\n        let id1: number = 0;\r\n        let id2: number = 0;\r\n        let v0X: number = 0;\r\n        let v0Y: number = 0;\r\n        let v0Z: number = 0;\r\n        let v1X: number = 0;\r\n        let v1Y: number = 0;\r\n        let v1Z: number = 0;\r\n        let v2X: number = 0;\r\n        let v2Y: number = 0;\r\n        let v2Z: number = 0;\r\n        const vertex0 = Vector3.Zero();\r\n        const vertex1 = Vector3.Zero();\r\n        const vertex2 = Vector3.Zero();\r\n        const vec0 = Vector3.Zero();\r\n        const vec1 = Vector3.Zero();\r\n\r\n        let uv0X: number = 0;\r\n        let uv0Y: number = 0;\r\n        let uv1X: number = 0;\r\n        let uv1Y: number = 0;\r\n        let uv2X: number = 0;\r\n        let uv2Y: number = 0;\r\n        const uv0 = Vector2.Zero();\r\n        const uv1 = Vector2.Zero();\r\n        const uv2 = Vector2.Zero();\r\n        const uvec0 = Vector2.Zero();\r\n        const uvec1 = Vector2.Zero();\r\n\r\n        let col0X: number = 0;\r\n        let col0Y: number = 0;\r\n        let col0Z: number = 0;\r\n        let col0A: number = 0;\r\n        let col1X: number = 0;\r\n        let col1Y: number = 0;\r\n        let col1Z: number = 0;\r\n        let col1A: number = 0;\r\n        let col2X: number = 0;\r\n        let col2Y: number = 0;\r\n        let col2Z: number = 0;\r\n        let col2A: number = 0;\r\n        const col0 = Vector4.Zero();\r\n        const col1 = Vector4.Zero();\r\n        const col2 = Vector4.Zero();\r\n        const colvec0 = Vector4.Zero();\r\n        const colvec1 = Vector4.Zero();\r\n\r\n        let lamda: number = 0;\r\n        let mu: number = 0;\r\n        range = range ? range : 0;\r\n\r\n        let facetPoint: Vector3;\r\n        let uvPoint: Vector2;\r\n        let colPoint: Vector4 = new Vector4(0, 0, 0, 0);\r\n\r\n        let norm = Vector3.Zero();\r\n        let tang = Vector3.Zero();\r\n        let biNorm = Vector3.Zero();\r\n        let angle = 0;\r\n        let facetPlaneVec = Vector3.Zero();\r\n\r\n        let gap = 0;\r\n        let distance = 0;\r\n        const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\r\n        let pickInfo: PickingInfo;\r\n        let direction = Vector3.Zero();\r\n\r\n        for (let index = 0; index < meshInd.length / 3; index++) {\r\n            id0 = meshInd[3 * index];\r\n            id1 = meshInd[3 * index + 1];\r\n            id2 = meshInd[3 * index + 2];\r\n            v0X = meshPos[3 * id0];\r\n            v0Y = meshPos[3 * id0 + 1];\r\n            v0Z = meshPos[3 * id0 + 2];\r\n            v1X = meshPos[3 * id1];\r\n            v1Y = meshPos[3 * id1 + 1];\r\n            v1Z = meshPos[3 * id1 + 2];\r\n            v2X = meshPos[3 * id2];\r\n            v2Y = meshPos[3 * id2 + 1];\r\n            v2Z = meshPos[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n\r\n            if (meshUV) {\r\n                uv0X = meshUV[2 * id0];\r\n                uv0Y = meshUV[2 * id0 + 1];\r\n                uv1X = meshUV[2 * id1];\r\n                uv1Y = meshUV[2 * id1 + 1];\r\n                uv2X = meshUV[2 * id2];\r\n                uv2Y = meshUV[2 * id2 + 1];\r\n                uv0.set(uv0X, uv0Y);\r\n                uv1.set(uv1X, uv1Y);\r\n                uv2.set(uv2X, uv2Y);\r\n                uv1.subtractToRef(uv0, uvec0);\r\n                uv2.subtractToRef(uv1, uvec1);\r\n            }\r\n\r\n            if (meshCol && colorFromTexture) {\r\n                col0X = meshCol[4 * id0];\r\n                col0Y = meshCol[4 * id0 + 1];\r\n                col0Z = meshCol[4 * id0 + 2];\r\n                col0A = meshCol[4 * id0 + 3];\r\n                col1X = meshCol[4 * id1];\r\n                col1Y = meshCol[4 * id1 + 1];\r\n                col1Z = meshCol[4 * id1 + 2];\r\n                col1A = meshCol[4 * id1 + 3];\r\n                col2X = meshCol[4 * id2];\r\n                col2Y = meshCol[4 * id2 + 1];\r\n                col2Z = meshCol[4 * id2 + 2];\r\n                col2A = meshCol[4 * id2 + 3];\r\n                col0.set(col0X, col0Y, col0Z, col0A);\r\n                col1.set(col1X, col1Y, col1Z, col1A);\r\n                col2.set(col2X, col2Y, col2Z, col2A);\r\n                col1.subtractToRef(col0, colvec0);\r\n                col2.subtractToRef(col1, colvec1);\r\n            }\r\n\r\n            let width: number;\r\n            let height: number;\r\n            let deltaS: number;\r\n            let deltaV: number;\r\n            let h: number;\r\n            let s: number;\r\n            let v: number;\r\n            let hsvCol: Color3;\r\n            const statedColor: Color3 = new Color3(0, 0, 0);\r\n            const colPoint3: Color3 = new Color3(0, 0, 0);\r\n            let pointColors: Color4;\r\n            let particle: CloudPoint;\r\n\r\n            for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\r\n                idxPoints = this.particles.length;\r\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\r\n                particle = this.particles[idxPoints];\r\n                //form a point inside the facet v0, v1, v2;\r\n                lamda = Math.sqrt(RandomRange(0, 1));\r\n                mu = RandomRange(0, 1);\r\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\r\n                if (isVolume) {\r\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\r\n                    tang = vec0.clone().normalize();\r\n                    biNorm = Vector3.Cross(norm, tang);\r\n                    angle = RandomRange(0, 2 * Math.PI);\r\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\r\n                    angle = RandomRange(0.1, Math.PI / 2);\r\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\r\n\r\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\r\n                    ray.direction = direction;\r\n                    ray.length = diameter;\r\n                    pickInfo = ray.intersectsMesh(mesh);\r\n                    if (pickInfo.hit) {\r\n                        distance = pickInfo.pickedPoint!.subtract(facetPoint).length();\r\n                        gap = RandomRange(0, 1) * distance;\r\n                        facetPoint.addInPlace(direction.scale(gap));\r\n                    }\r\n                }\r\n                particle.position = facetPoint.clone();\r\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\r\n                if (colorFromTexture !== undefined) {\r\n                    if (meshUV) {\r\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\r\n                        if (colorFromTexture) {\r\n                            //Set particle color to texture color\r\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\r\n                                width = pointsGroup._groupImgWidth;\r\n                                height = pointsGroup._groupImgHeight;\r\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\r\n                                particle.color = pointColors;\r\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\r\n                            } else {\r\n                                if (meshCol) {\r\n                                    //failure in texture and colors available\r\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                } else {\r\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            //Set particle uv based on a mesh uv\r\n                            particle.uv = uvPoint.clone();\r\n                            this._uvs.push(particle.uv.x, particle.uv.y);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (color) {\r\n                        statedColor.set(color.r, color.g, color.b);\r\n                        deltaS = RandomRange(-range, range);\r\n                        deltaV = RandomRange(-range, range);\r\n                        hsvCol = statedColor.toHSV();\r\n                        h = hsvCol.r;\r\n                        s = hsvCol.g + deltaS;\r\n                        v = hsvCol.b + deltaV;\r\n                        if (s < 0) {\r\n                            s = 0;\r\n                        }\r\n                        if (s > 1) {\r\n                            s = 1;\r\n                        }\r\n                        if (v < 0) {\r\n                            v = 0;\r\n                        }\r\n                        if (v > 1) {\r\n                            v = 1;\r\n                        }\r\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\r\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\r\n                    } else {\r\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                    }\r\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // stores mesh texture in dynamic texture for color pixel retrieval\r\n    // when pointColor type is color for surface points\r\n    private _colorFromTexture(mesh: Mesh, pointsGroup: PointsGroup, isVolume: boolean): void {\r\n        if (mesh.material === null) {\r\n            Logger.Warn(mesh.name + \"has no material.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        const mat = mesh.material;\r\n        const textureList: BaseTexture[] = mat.getActiveTextures();\r\n        if (textureList.length === 0) {\r\n            Logger.Warn(mesh.name + \"has no usable texture.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        const clone = <Mesh>mesh.clone();\r\n        clone.setEnabled(false);\r\n        this._promises.push(\r\n            new Promise((resolve: (_: void) => void) => {\r\n                BaseTexture.WhenAllReady(textureList, () => {\r\n                    let n = pointsGroup._textureNb;\r\n                    if (n < 0) {\r\n                        n = 0;\r\n                    }\r\n                    if (n > textureList.length - 1) {\r\n                        n = textureList.length - 1;\r\n                    }\r\n                    const finalize = () => {\r\n                        pointsGroup._groupImgWidth = textureList[n].getSize().width;\r\n                        pointsGroup._groupImgHeight = textureList[n].getSize().height;\r\n                        this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true, undefined, undefined, textureList[n].coordinatesIndex);\r\n                        clone.dispose();\r\n                        resolve();\r\n                    };\r\n                    pointsGroup._groupImageData = null;\r\n                    const dataPromise = textureList[n].readPixels();\r\n                    if (!dataPromise) {\r\n                        finalize();\r\n                    } else {\r\n                        dataPromise.then((data) => {\r\n                            pointsGroup._groupImageData = data;\r\n                            finalize();\r\n                        });\r\n                    }\r\n                });\r\n            })\r\n        );\r\n    }\r\n\r\n    // calculates the point density per facet of a mesh for surface points\r\n    private _calculateDensity(nbPoints: number, positions: FloatArray, indices: IndicesArray): number[] {\r\n        let id0: number;\r\n        let id1: number;\r\n        let id2: number;\r\n        let v0X: number;\r\n        let v0Y: number;\r\n        let v0Z: number;\r\n        let v1X: number;\r\n        let v1Y: number;\r\n        let v1Z: number;\r\n        let v2X: number;\r\n        let v2Y: number;\r\n        let v2Z: number;\r\n        const vertex0 = Vector3.Zero();\r\n        const vertex1 = Vector3.Zero();\r\n        const vertex2 = Vector3.Zero();\r\n        const vec0 = Vector3.Zero();\r\n        const vec1 = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n\r\n        let area: number;\r\n        const cumulativeAreas: number[] = [];\r\n        let surfaceArea: number = 0;\r\n\r\n        const nbFacets = indices.length / 3;\r\n\r\n        //surface area\r\n        for (let index = 0; index < nbFacets; index++) {\r\n            id0 = indices[3 * index];\r\n            id1 = indices[3 * index + 1];\r\n            id2 = indices[3 * index + 2];\r\n            v0X = positions[3 * id0];\r\n            v0Y = positions[3 * id0 + 1];\r\n            v0Z = positions[3 * id0 + 2];\r\n            v1X = positions[3 * id1];\r\n            v1Y = positions[3 * id1 + 1];\r\n            v1Z = positions[3 * id1 + 2];\r\n            v2X = positions[3 * id2];\r\n            v2Y = positions[3 * id2 + 1];\r\n            v2Z = positions[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n            Vector3.CrossToRef(vec0, vec1, normal);\r\n            area = 0.5 * normal.length();\r\n            surfaceArea += area;\r\n            cumulativeAreas[index] = surfaceArea;\r\n        }\r\n\r\n        const density: number[] = new Array<number>(nbFacets);\r\n        let remainingPoints = nbPoints;\r\n        for (let index = nbFacets - 1; index > 0; index--) {\r\n            const cumulativeArea = cumulativeAreas[index];\r\n            if (cumulativeArea === 0) {\r\n                // avoiding division by 0 upon degenerate triangles\r\n                density[index] = 0;\r\n            } else {\r\n                const area = cumulativeArea - cumulativeAreas[index - 1];\r\n                const facetPointsWithFraction = (area / cumulativeArea) * remainingPoints;\r\n                const floored = Math.floor(facetPointsWithFraction);\r\n                const fraction = facetPointsWithFraction - floored;\r\n                const extraPoint = Number(Math.random() < fraction);\r\n                const facetPoints = floored + extraPoint;\r\n                density[index] = facetPoints;\r\n                remainingPoints -= facetPoints;\r\n            }\r\n        }\r\n        density[0] = remainingPoints;\r\n\r\n        return density;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS in random positions within a unit sphere\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addPoints(nb: number, pointFunction: any = this._randomUnitVector): number {\r\n        const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\r\n        let cp: CloudPoint;\r\n\r\n        // particles\r\n        let idx = this.nbParticles;\r\n        for (let i = 0; i < nb; i++) {\r\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\r\n            if (pointsGroup && pointsGroup._positionFunction) {\r\n                pointsGroup._positionFunction(cp, idx, i);\r\n            }\r\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\r\n            if (cp.color) {\r\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\r\n            }\r\n            if (cp.uv) {\r\n                this._uvs.push(cp.uv.x, cp.uv.y);\r\n            }\r\n            idx++;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS from the surface of the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addSurfacePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        let colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) || colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        } else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS inside the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addVolumePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        let colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) || colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        } else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n     *  This method calls `updateParticle()` for each particle of the SPS.\r\n     *  For an animated SPS, it is usually called within the render loop.\r\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n     * @returns the PCS.\r\n     */\r\n    public setParticles(start: number = 0, end: number = this.nbParticles - 1, update: boolean = true): PointsCloudSystem {\r\n        if (!this._updatable || !this._isReady) {\r\n            return this;\r\n        }\r\n\r\n        // custom beforeUpdate\r\n        this.beforeUpdateParticles(start, end, update);\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const mesh = this.mesh;\r\n        const colors32 = this._colors32;\r\n        const positions32 = this._positions32;\r\n        const uvs32 = this._uvs32;\r\n\r\n        const tempVectors = TmpVectors.Vector3;\r\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\r\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\r\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\r\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\r\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\r\n\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        let idx = 0; // current index of the particle\r\n\r\n        if (this.mesh?.isFacetDataEnabled) {\r\n            this._computeBoundingBox = true;\r\n        }\r\n\r\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\r\n        if (this._computeBoundingBox) {\r\n            if (start != 0 || end != this.nbParticles - 1) {\r\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\r\n                const boundingInfo = this.mesh?.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    minimum.copyFrom(boundingInfo.minimum);\r\n                    maximum.copyFrom(boundingInfo.maximum);\r\n                }\r\n            }\r\n        }\r\n\r\n        idx = 0; // particle index\r\n        let pindex = 0; //index in positions array\r\n        let cindex = 0; //index in color array\r\n        let uindex = 0; //index in uv array\r\n\r\n        // particle loop\r\n        for (let p = start; p <= end; p++) {\r\n            const particle = this.particles[p];\r\n            idx = particle.idx;\r\n            pindex = 3 * idx;\r\n            cindex = 4 * idx;\r\n            uindex = 2 * idx;\r\n\r\n            // call to custom user function to update the particle properties\r\n            this.updateParticle(particle);\r\n\r\n            const particleRotationMatrix = particle._rotationMatrix;\r\n            const particlePosition = particle.position;\r\n            const particleGlobalPosition = particle._globalPosition;\r\n\r\n            if (this._computeParticleRotation) {\r\n                particle.getRotationMatrix(rotMatrix);\r\n            }\r\n\r\n            const particleHasParent = particle.parentId !== null;\r\n            if (particleHasParent) {\r\n                const parent = this.particles[particle.parentId!];\r\n                const parentRotationMatrix = parent._rotationMatrix;\r\n                const parentGlobalPosition = parent._globalPosition;\r\n\r\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\r\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\r\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\r\n\r\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\r\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\r\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[1] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[2] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[3] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[4] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[5] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[6] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[7] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[8] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\r\n                }\r\n            } else {\r\n                particleGlobalPosition.x = 0;\r\n                particleGlobalPosition.y = 0;\r\n                particleGlobalPosition.z = 0;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] = rotMatrixValues[0];\r\n                    particleRotationMatrix[1] = rotMatrixValues[1];\r\n                    particleRotationMatrix[2] = rotMatrixValues[2];\r\n                    particleRotationMatrix[3] = rotMatrixValues[4];\r\n                    particleRotationMatrix[4] = rotMatrixValues[5];\r\n                    particleRotationMatrix[5] = rotMatrixValues[6];\r\n                    particleRotationMatrix[6] = rotMatrixValues[8];\r\n                    particleRotationMatrix[7] = rotMatrixValues[9];\r\n                    particleRotationMatrix[8] = rotMatrixValues[10];\r\n                }\r\n            }\r\n\r\n            const pivotBackTranslation = tempVectors[11];\r\n            if (particle.translateFromPivot) {\r\n                pivotBackTranslation.setAll(0.0);\r\n            } else {\r\n                pivotBackTranslation.copyFrom(particle.pivot);\r\n            }\r\n\r\n            // positions\r\n            const tmpVertex = tempVectors[0];\r\n            tmpVertex.copyFrom(particle.position);\r\n            const vertexX = tmpVertex.x - particle.pivot.x;\r\n            const vertexY = tmpVertex.y - particle.pivot.y;\r\n            const vertexZ = tmpVertex.z - particle.pivot.z;\r\n\r\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\r\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\r\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\r\n\r\n            rotatedX += pivotBackTranslation.x;\r\n            rotatedY += pivotBackTranslation.y;\r\n            rotatedZ += pivotBackTranslation.z;\r\n\r\n            const px = (positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\r\n            const py = (positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\r\n            const pz = (positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\r\n\r\n            if (this._computeBoundingBox) {\r\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\r\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\r\n            }\r\n\r\n            if (this._computeParticleColor && particle.color) {\r\n                const color = particle.color;\r\n                const colors32 = this._colors32;\r\n                colors32[cindex] = color.r;\r\n                colors32[cindex + 1] = color.g;\r\n                colors32[cindex + 2] = color.b;\r\n                colors32[cindex + 3] = color.a;\r\n            }\r\n            if (this._computeParticleTexture && particle.uv) {\r\n                const uv = particle.uv;\r\n                const uvs32 = this._uvs32;\r\n                uvs32[uindex] = uv.x;\r\n                uvs32[uindex + 1] = uv.y;\r\n            }\r\n        }\r\n\r\n        // if the VBO must be updated\r\n        if (mesh) {\r\n            if (update) {\r\n                if (this._computeParticleColor) {\r\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\r\n                }\r\n                if (this._computeParticleTexture) {\r\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\r\n                }\r\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\r\n            }\r\n\r\n            if (this._computeBoundingBox) {\r\n                if (mesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\r\n                } else {\r\n                    mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\r\n                }\r\n            }\r\n        }\r\n        this.afterUpdateParticles(start, end, update);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the PCS.\r\n     */\r\n    public dispose(): void {\r\n        this.mesh?.dispose();\r\n        this.vars = null;\r\n        // drop references to internal big arrays for the GC\r\n        (<any>this._positions) = null;\r\n        (<any>this._indices) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n        (<any>this._indices32) = null;\r\n        (<any>this._positions32) = null;\r\n        (<any>this._uvs32) = null;\r\n        (<any>this._colors32) = null;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\r\n     * doc :\r\n     * @returns the PCS.\r\n     */\r\n    public refreshVisibleSize(): PointsCloudSystem {\r\n        if (!this._isVisibilityBoxLocked) {\r\n            this.mesh?.refreshBoundingInfo();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n     * @param size the size (float) of the visibility box\r\n     * note : this doesn't lock the PCS mesh bounding box.\r\n     * doc :\r\n     */\r\n    public setVisibilityBox(size: number): void {\r\n        if (!this.mesh) {\r\n            return;\r\n        }\r\n\r\n        const vis = size / 2;\r\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the PCS is always visible or not\r\n     * doc :\r\n     */\r\n    public get isAlwaysVisible(): boolean {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the PCS as always visible or not\r\n     * doc :\r\n     */\r\n    public set isAlwaysVisible(val: boolean) {\r\n        if (!this.mesh) {\r\n            return;\r\n        }\r\n\r\n        this._alwaysVisible = val;\r\n        this.mesh.alwaysSelectAsActiveMesh = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not\r\n     * Default value : false. The PCS is faster when it's set to false\r\n     * Note : particle rotations are only applied to parent particles\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\r\n     */\r\n    public set computeParticleRotation(val: boolean) {\r\n        this._computeParticleRotation = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public set computeParticleColor(val: boolean) {\r\n        this._computeParticleColor = val;\r\n    }\r\n\r\n    public set computeParticleTexture(val: boolean) {\r\n        this._computeParticleTexture = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleColor(): boolean {\r\n        return this._computeParticleColor;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleTexture(): boolean {\r\n        return this._computeParticleTexture;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public set computeBoundingBox(val: boolean) {\r\n        this._computeBoundingBox = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public get computeBoundingBox(): boolean {\r\n        return this._computeBoundingBox;\r\n    }\r\n\r\n    // =======================================================================\r\n    // Particle behavior logic\r\n    // these following methods may be overwritten by users to fit their needs\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to set all the particle first values.\r\n     * The PCS doesn't call this function, you may have to call it by your own.\r\n     * doc :\r\n     */\r\n    public initParticles(): void {}\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to recycle a particle\r\n     * The PCS doesn't call this function, you can to call it\r\n     * doc :\r\n     * @param particle The particle to recycle\r\n     * @returns the recycled particle\r\n     */\r\n    public recycleParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a particle : this function should  be overwritten by the user.\r\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n     * doc :\r\n     * @example : just set a particle position or velocity and recycle conditions\r\n     * @param particle The particle to update\r\n     * @returns the updated particle\r\n     */\r\n    public updateParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n    /**\r\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n     * This will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public afterUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n}\r\n"],
  "mappings": "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,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AACA,EAAAA,UAAAA,UAAA,OAAA,IAAA,EAAA,IAAA;AAEA,EAA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",
  "names": ["result", "PLYType", "PLYValue", "ElementMode", "_a", "vertexCount", "lineStart", "lineCount", "PointColor", "area", "rotatedY", "rotatedX", "rotatedZ", "colors32", "uvs32"]
}
