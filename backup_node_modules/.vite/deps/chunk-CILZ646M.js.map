{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/coroutine.ts", "../../../dev/core/src/Collisions/intersectionInfo.ts", "../../../dev/core/src/Culling/boundingBox.ts", "../../../dev/core/src/Culling/boundingSphere.ts", "../../../dev/core/src/Culling/boundingInfo.ts", "../../../dev/core/src/Meshes/subMesh.ts", "../../../dev/core/src/Meshes/mesh.vertexData.ts", "../../../dev/core/src/Meshes/transformNode.ts", "../../../dev/core/src/Collisions/meshCollisionData.ts", "../../../dev/core/src/Meshes/abstractMesh.ts", "../../../dev/core/src/Materials/materialStencilState.ts", "../../../dev/core/src/Materials/material.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\n// \"Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed.\"\r\n// https://en.wikipedia.org/wiki/Coroutine\r\n\r\n// In this implementation, coroutines are typically created via generator functions (function* with yield statements).\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\r\n\r\n// In this implementation, the generator function (possibly parameterized) is referred to as a coroutine factory, and the returned iterator is referred to as the coroutine.\r\n// Technically yielding generator functions are not required - anything that implements the contract of Coroutine<T> can be run as a coroutine.\r\n\r\n// The coroutine is started with the first call to next on the iterator, it is suspended with yield statements, and it is resumed with additional calls to next on the iterator.\r\n// To create an object satisfying the Coroutine<T> contract with a generator function, it must not yield values, but rather only void via a plain \"yield;\" statement.\r\n// Coroutines can call other coroutines via:\r\n// 1. yield* someOtherCoroutine(); // If the called coroutine does not return a value\r\n// 2. const result = yield* someOtherCoroutine(); // If the called coroutine returns a value\r\n\r\n// Coroutines are run with the runCoroutine function, which takes a Coroutine<T>, a CoroutineScheduler<T>, and a success and error callback.\r\n// A scheduler is responsible for scheduling the next step of a coroutine, either synchronously or asynchronously.\r\n\r\n/**\r\n * A Coroutine<T> is the intersection of:\r\n * 1. An Iterator that yields void, returns a T, and is not passed values with calls to next.\r\n * 2. An IterableIterator of void (since it only yields void).\r\n */\r\ntype CoroutineBase<TStep, TReturn> = Iterator<TStep, TReturn, void> & IterableIterator<TStep>;\r\n/** @internal */\r\nexport type Coroutine<T> = CoroutineBase<void, T>;\r\n/** @internal */\r\nexport type AsyncCoroutine<T> = CoroutineBase<void | Promise<void>, T>;\r\n\r\n// A CoroutineStep<T> represents a single step of a coroutine, and is an IteratorResult as returned from Coroutine<T>.next().\r\n/** @internal */\r\nexport type CoroutineStep<T> = IteratorResult<void, T>;\r\n\r\n// A CoroutineScheduler<T> is responsible for scheduling the call to Coroutine<T>.next and invokes the success or error callback after next is called.\r\n/** @internal */\r\nexport type CoroutineScheduler<T> = (coroutine: AsyncCoroutine<T>, onStep: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => void;\r\n\r\n// The inline scheduler simply steps the coroutine synchronously. This is useful for running a coroutine synchronously, and also as a helper function for other schedulers.\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function inlineScheduler<T>(coroutine: AsyncCoroutine<T>, onStep: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) {\r\n    try {\r\n        const step = coroutine.next();\r\n\r\n        if (step.done) {\r\n            onStep(step);\r\n        } else if (!step.value) {\r\n            // NOTE: The properties of step have been narrowed, but the type of step itself is not narrowed, so the cast below is the most type safe way to deal with this without instantiating a new object to hold the values.\r\n            onStep(step as { done: typeof step.done; value: typeof step.value });\r\n        } else {\r\n            step.value.then(() => {\r\n                step.value = undefined;\r\n                onStep(step as { done: typeof step.done; value: typeof step.value });\r\n            }, onError);\r\n        }\r\n    } catch (error) {\r\n        onError(error);\r\n    }\r\n}\r\n\r\n// The yielding scheduler steps the coroutine synchronously until the specified time interval has elapsed, then yields control so other operations can be performed.\r\n// A single instance of a yielding scheduler could be shared across multiple coroutines to yield when their collective work exceeds the threshold.\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function createYieldingScheduler<T>(yieldAfterMS = 25) {\r\n    let startTime: number | undefined;\r\n    return (coroutine: AsyncCoroutine<T>, onStep: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => {\r\n        const currentTime = performance.now();\r\n\r\n        if (startTime === undefined || currentTime - startTime > yieldAfterMS) {\r\n            // If this is the first coroutine step, or if the time interval has elapsed, record a new start time, and schedule the coroutine step to happen later, effectively yielding control of the execution context.\r\n            startTime = currentTime;\r\n            setTimeout(() => {\r\n                inlineScheduler(coroutine, onStep, onError);\r\n            }, 0);\r\n        } else {\r\n            // Otherwise it is not time to yield yet, so step the coroutine synchronously.\r\n            inlineScheduler(coroutine, onStep, onError);\r\n        }\r\n    };\r\n}\r\n\r\n// Runs the specified coroutine with the specified scheduler. The success or error callback will be invoked when the coroutine finishes.\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function runCoroutine<T>(\r\n    coroutine: AsyncCoroutine<T>,\r\n    scheduler: CoroutineScheduler<T>,\r\n    onSuccess: (result: T) => void,\r\n    onError: (error: any) => void,\r\n    abortSignal?: AbortSignal\r\n) {\r\n    const resume = () => {\r\n        let reschedule: boolean | undefined;\r\n\r\n        const onStep = (stepResult: CoroutineStep<T>) => {\r\n            if (stepResult.done) {\r\n                // If the coroutine is done, report success.\r\n                onSuccess(stepResult.value);\r\n            } else {\r\n                // If the coroutine is not done, resume the coroutine (via the scheduler).\r\n                if (reschedule === undefined) {\r\n                    // If reschedule is undefined at this point, then the coroutine must have stepped synchronously, so just flag another loop iteration.\r\n                    reschedule = true;\r\n                } else {\r\n                    // If reschedule is defined at this point, then the coroutine must have stepped asynchronously, so call resume to restart the step loop.\r\n                    resume();\r\n                }\r\n            }\r\n        };\r\n\r\n        do {\r\n            reschedule = undefined;\r\n\r\n            if (!abortSignal || !abortSignal.aborted) {\r\n                scheduler(coroutine, onStep, onError);\r\n            } else {\r\n                onError(new Error(\"Aborted\"));\r\n            }\r\n\r\n            if (reschedule === undefined) {\r\n                // If reschedule is undefined at this point, then the coroutine must have stepped asynchronously, so stop looping and let the coroutine be resumed later.\r\n                reschedule = false;\r\n            }\r\n        } while (reschedule);\r\n    };\r\n\r\n    resume();\r\n}\r\n\r\n// Runs the specified coroutine synchronously.\r\n/**\r\n * @internal\r\n */\r\nexport function runCoroutineSync<T>(coroutine: Coroutine<T>, abortSignal?: AbortSignal): T {\r\n    // Run the coroutine with the inline scheduler, storing the returned value, or re-throwing the error (since the error callback will be called synchronously by the inline scheduler).\r\n    let result: T | undefined;\r\n    runCoroutine(\r\n        coroutine,\r\n        inlineScheduler,\r\n        (r: T) => (result = r),\r\n        (e: any) => {\r\n            throw e;\r\n        },\r\n        abortSignal\r\n    );\r\n\r\n    // Synchronously return the result of the coroutine.\r\n    return result!;\r\n}\r\n\r\n// Runs the specified coroutine asynchronously with the specified scheduler.\r\n/**\r\n * @internal\r\n */\r\nexport function runCoroutineAsync<T>(coroutine: AsyncCoroutine<T>, scheduler: CoroutineScheduler<T>, abortSignal?: AbortSignal): Promise<T> {\r\n    // Run the coroutine with a yielding scheduler, resolving or rejecting the result promise when the coroutine finishes.\r\n    return new Promise((resolve, reject) => {\r\n        runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);\r\n    });\r\n}\r\n\r\n/**\r\n * Given a function that returns a Coroutine<T>, produce a function with the same parameters that returns a T.\r\n * The returned function runs the coroutine synchronously.\r\n * @param coroutineFactory A function that returns a Coroutine<T>.\r\n * @param abortSignal\r\n * @returns A function that runs the coroutine synchronously.\r\n * @internal\r\n */\r\nexport function makeSyncFunction<TParams extends unknown[], TReturn>(\r\n    coroutineFactory: (...params: TParams) => Coroutine<TReturn>,\r\n    abortSignal?: AbortSignal\r\n): (...params: TParams) => TReturn {\r\n    return (...params: TParams) => {\r\n        // Run the coroutine synchronously.\r\n        return runCoroutineSync(coroutineFactory(...params), abortSignal);\r\n    };\r\n}\r\n\r\n/**\r\n * Given a function that returns a Coroutine<T>, product a function with the same parameters that returns a Promise<T>.\r\n * The returned function runs the coroutine asynchronously, yield control of the execution context occasionally to enable a more responsive experience.\r\n * @param coroutineFactory A function that returns a Coroutine<T>.\r\n * @param scheduler\r\n * @param abortSignal\r\n * @returns A function that runs the coroutine asynchronously.\r\n * @internal\r\n */\r\nexport function makeAsyncFunction<TParams extends unknown[], TReturn>(\r\n    coroutineFactory: (...params: TParams) => AsyncCoroutine<TReturn>,\r\n    scheduler: CoroutineScheduler<TReturn>,\r\n    abortSignal?: AbortSignal\r\n): (...params: TParams) => Promise<TReturn> {\r\n    return (...params: TParams) => {\r\n        // Run the coroutine asynchronously.\r\n        return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal);\r\n    };\r\n}\r\n", "import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class IntersectionInfo {\r\n    public faceId = 0;\r\n    public subMeshId = 0;\r\n\r\n    constructor(\r\n        public bu: Nullable<number>,\r\n        public bv: Nullable<number>,\r\n        public distance: number\r\n    ) {}\r\n}\r\n", "import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in local space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in world space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/**\r\n * Class used to store bounding sphere information\r\n */\r\nexport class BoundingSphere {\r\n    /**\r\n     * Gets the center of the bounding sphere in local space\r\n     */\r\n    public readonly center = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in local space\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Gets the center of the bounding sphere in world space\r\n     */\r\n    public readonly centerWorld = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in world space\r\n     */\r\n    public radiusWorld: number;\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * Creates a new bounding sphere\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding sphere from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.minimum.copyFrom(min);\r\n        this.maximum.copyFrom(max);\r\n\r\n        const distance = Vector3.Distance(min, max);\r\n\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        this.radius = distance * 0.5;\r\n\r\n        this._update(worldMatrix || Matrix.IdentityReadOnly);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding sphere by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingSphere {\r\n        const newRadius = this.radius * factor;\r\n        const tmpVectors = BoundingSphere._TmpVector3;\r\n        const tempRadiusVector = tmpVectors[0].setAll(newRadius);\r\n        const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);\r\n        const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(worldMatrix: DeepImmutable<Matrix>): void {\r\n        if (!worldMatrix.isIdentity()) {\r\n            Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);\r\n            const tempVector = BoundingSphere._TmpVector3[0];\r\n            Vector3.TransformNormalFromFloatsToRef(1.0, 1.0, 1.0, worldMatrix, tempVector);\r\n            this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;\r\n        } else {\r\n            this.centerWorld.copyFrom(this.center);\r\n            this.radiusWorld = this.radius;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        const radius = this.radiusWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) <= -radius) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere center is in between the frustum planes.\r\n     * Used for optimistic fast inclusion.\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if the sphere center is in between the frustum planes\r\n     */\r\n    public isCenterInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding sphere\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding sphere\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);\r\n        if (this.radiusWorld * this.radiusWorld < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Checks if two sphere intersect\r\n     * @param sphere0 sphere 0\r\n     * @param sphere1 sphere 1\r\n     * @returns true if the spheres intersect\r\n     */\r\n    public static Intersects(sphere0: DeepImmutable<BoundingSphere>, sphere1: DeepImmutable<BoundingSphere>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);\r\n        const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;\r\n\r\n        if (radiusSum * radiusSum < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a sphere from a center and a radius\r\n     * @param center The center\r\n     * @param radius radius\r\n     * @param matrix Optional worldMatrix\r\n     * @returns The sphere\r\n     */\r\n    public static CreateFromCenterAndRadius(center: DeepImmutable<Vector3>, radius: number, matrix?: DeepImmutable<Matrix>): BoundingSphere {\r\n        this._TmpVector3[0].copyFrom(center);\r\n        this._TmpVector3[1].copyFromFloats(0, 0, radius);\r\n        this._TmpVector3[2].copyFrom(center);\r\n        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);\r\n        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);\r\n\r\n        const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);\r\n\r\n        if (matrix) {\r\n            sphere._worldMatrix = matrix;\r\n        } else {\r\n            sphere._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        return sphere;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { TmpVectors } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\nconst _result0 = { min: 0, max: 0 };\r\nconst _result1 = { min: 0, max: 0 };\r\nconst computeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number; max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst axisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    computeBoxExtents(axis, box0, _result0);\r\n    computeBoxExtents(axis, box1, _result1);\r\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly _TmpVector3 = BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to include the given point.\r\n     * @param point The point that will be included in the current bounding info (in local space)\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulate(point: Vector3): BoundingInfo {\r\n        const minimum = Vector3.Minimize(this.minimum, point);\r\n        const maximum = Vector3.Maximize(this.maximum, point);\r\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to encapsulate the given bounding info.\r\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulateBoundingInfo(toEncapsulate: BoundingInfo): BoundingInfo {\r\n        const invw = TmpVectors.Matrix[0];\r\n        this.boundingBox.getWorldMatrix().invertToRef(invw);\r\n\r\n        const v = TmpVectors.Vector3[0];\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * The different strategies available are:\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = Constants.MESHES_CULLINGSTRATEGY_STANDARD): boolean {\r\n        const inclusionTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        const bSphereOnlyTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        const box0 = this.boundingBox;\r\n        const box1 = boundingInfo.boundingBox;\r\n\r\n        if (!axisOverlap(box0.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "import type { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport type { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { AbstractMesh } from \"./abstractMesh\";\r\nimport type { Mesh } from \"./mesh\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { TrianglePickingPredicate } from \"../Culling/ray\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    private _engine: AbstractEngine;\r\n    /** @internal */\r\n    public _drawWrappers: Array<DrawWrapper>; // index in this array = pass id\r\n    private _mainDrawWrapperOverride: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._mainDrawWrapperOverride ? (this._mainDrawWrapperOverride.defines as MaterialDefines) : (this._getDrawWrapper()?.defines as Nullable<MaterialDefines>);\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n        drawWrapper.defines = defines;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDrawWrapper(passId?: number, createIfNotExisting = false): DrawWrapper | undefined {\r\n        passId = passId ?? this._engine.currentRenderPassId;\r\n        let drawWrapper = this._drawWrappers[passId];\r\n        if (!drawWrapper && createIfNotExisting) {\r\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\r\n        }\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeDrawWrapper(passId: number, disposeWrapper = true, immediate = false): void {\r\n        if (disposeWrapper) {\r\n            this._drawWrappers[passId]?.dispose(immediate);\r\n        }\r\n        this._drawWrappers[passId] = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Gets associated (main) effect (possibly the effect override if defined)\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (this._getDrawWrapper()?.effect ?? null);\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapper(): DrawWrapper {\r\n        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapperOverride(): Nullable<DrawWrapper> {\r\n        return this._mainDrawWrapperOverride;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setMainDrawWrapperOverride(wrapper: Nullable<DrawWrapper>): void {\r\n        this._mainDrawWrapperOverride = wrapper;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     * @param materialContext material context associated to the effect\r\n     * @param resetContext true to reset the draw context\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<string | MaterialDefines> = null, materialContext?: IMaterialContext, resetContext = true) {\r\n        const drawWrapper = this._drawWrapper;\r\n        drawWrapper.setEffect(effect, defines, resetContext);\r\n        if (materialContext !== undefined) {\r\n            drawWrapper.materialContext = materialContext;\r\n        }\r\n        if (!effect) {\r\n            drawWrapper.defines = null;\r\n            drawWrapper.materialContext = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     * @param immediate If true, the draw wrapper will dispose the effect immediately (false by default)\r\n     */\r\n    public resetDrawCache(passId?: number, immediate = false): void {\r\n        if (this._drawWrappers) {\r\n            if (passId !== undefined) {\r\n                this._removeDrawWrapper(passId, true, immediate);\r\n                return;\r\n            } else {\r\n                for (const drawWrapper of this._drawWrappers) {\r\n                    drawWrapper?.dispose(immediate);\r\n                }\r\n            }\r\n        }\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    /** @internal */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @internal */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @internal */\r\n    public _trianglePlanes: Plane[];\r\n    /** @internal */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /** @internal */\r\n    public _renderId = 0;\r\n    /** @internal */\r\n    public _alphaIndex: number = 0;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(\r\n        materialIndex: number,\r\n        verticesStart: number,\r\n        verticesCount: number,\r\n        indexStart: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true,\r\n        addToMesh = true\r\n    ) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._engine = this._mesh.getScene().getEngine();\r\n        this.resetDrawCache();\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get IsGlobal(): boolean {\r\n        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoundingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal || this._mesh.hasThinInstances) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @returns the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(getDefaultMaterial = true): Nullable<Material> {\r\n        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\r\n\r\n        if (!rootMaterial) {\r\n            return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\r\n        } else if (this._isMultiMaterial(rootMaterial)) {\r\n            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this.resetDrawCache();\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _isMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        const indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        let extend: { minimum: Vector3; maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            const boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: AbstractEngine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            const adjustedIndexCount = Math.floor(this.indexCount / 3) * 6;\r\n            const shouldUseUint32 = this.verticesStart + this.verticesCount > 65535;\r\n            const linesIndices = shouldUseUint32 ? new Uint32Array(adjustedIndexCount) : new Uint16Array(adjustedIndexCount);\r\n\r\n            let offset = 0;\r\n            if (indices.length === 0) {\r\n                // Unindexed mesh\r\n                for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                    linesIndices[offset++] = index;\r\n                    linesIndices[offset++] = index + 1;\r\n                    linesIndices[offset++] = index + 1;\r\n                    linesIndices[offset++] = index + 2;\r\n                    linesIndices[offset++] = index + 2;\r\n                    linesIndices[offset++] = index;\r\n                }\r\n            } else {\r\n                for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                    linesIndices[offset++] = indices[index];\r\n                    linesIndices[offset++] = indices[index + 1];\r\n                    linesIndices[offset++] = indices[index + 1];\r\n                    linesIndices[offset++] = indices[index + 2];\r\n                    linesIndices[offset++] = indices[index + 2];\r\n                    linesIndices[offset++] = indices[index];\r\n                }\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return null;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        } else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            const p0 = positions[indices[index]];\r\n            const p1 = positions[indices[index + 1]];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        step: number,\r\n        checkStopper: boolean,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceId = -1;\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n            faceId++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xffffffff) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            const p0 = positions[indexA];\r\n            const p1 = positions[indexB];\r\n            const p2 = positions[indexC];\r\n\r\n            // stay defensive and don't check against undefined positions.\r\n            if (!p0 || !p1 || !p2) {\r\n                continue;\r\n            }\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceId;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n            const p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     * @param immediate If true, the effect will be disposed immediately (false by default)\r\n     */\r\n    public dispose(immediate = false): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        const index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n\r\n        this.resetDrawCache(undefined, immediate);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(\r\n        materialIndex: number,\r\n        startIndex: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        let minVertexIndex = Number.MAX_VALUE;\r\n        let maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = renderingMesh || mesh;\r\n        const indices = whatWillRender!.getIndices()!;\r\n\r\n        for (let index = startIndex; index < startIndex + indexCount; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n}\r\n", "/* eslint-disable jsdoc/require-returns-check */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport type { Coroutine } from \"../Misc/coroutine\";\r\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine\";\r\nimport type { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { SubMesh } from \"./subMesh\";\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/** Class used to attach material info to sub section of a vertex data class */\r\nexport class VertexDataMaterialInfo {\r\n    /** Defines the material index to use */\r\n    public materialIndex: number;\r\n    /** Defines vertex index start*/\r\n    public verticesStart: number;\r\n    /** Defines vertices count */\r\n    public verticesCount: number;\r\n    /** Defines index start */\r\n    public indexStart: number;\r\n    /** Defines indices count */\r\n    public indexCount: number;\r\n}\r\n\r\n/**\r\n * Interface used to define a object like a vertex data structure\r\n */\r\nexport interface IVertexDataLike {\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    normals?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    tangents?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs2?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs3?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs4?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs5?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    uvs6?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    colors?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    matricesIndices?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    matricesWeights?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    matricesIndicesExtra?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    matricesWeightsExtra?: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    indices?: Nullable<IndicesArray>;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData implements IVertexDataLike {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    private static _UniqueIDGenerator = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * An array defining material association for sub sections of the vertex data\r\n     */\r\n    public materialInfos: Nullable<Array<VertexDataMaterialInfo>>;\r\n\r\n    /**\r\n     * Gets the unique ID of this vertex Data\r\n     */\r\n    public uniqueId = 0;\r\n\r\n    /**\r\n     * Metadata used to store contextual values\r\n     */\r\n    public metadata: any = {};\r\n\r\n    /**\r\n     * Gets or sets a value indicating that the mesh must be flagged with hasVertexAlpha = true\r\n     */\r\n    public hasVertexAlpha: boolean;\r\n\r\n    /**\r\n     * Creates a new VertexData\r\n     */\r\n    public constructor() {\r\n        this.uniqueId = VertexData._UniqueIDGenerator;\r\n        VertexData._UniqueIDGenerator++;\r\n    }\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private readonly _applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_applyToCoroutine(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false, isAsync: boolean): Coroutine<VertexData> {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\r\n            if (this.hasVertexAlpha && (meshOrGeometry as any).hasVertexAlpha !== undefined) {\r\n                (meshOrGeometry as any).hasVertexAlpha = true;\r\n            }\r\n\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        if ((meshOrGeometry as Mesh).subMeshes && this.materialInfos && this.materialInfos.length > 1) {\r\n            const mesh = meshOrGeometry as Mesh;\r\n            mesh.subMeshes = [];\r\n            for (const matInfo of this.materialInfos) {\r\n                new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    @nativeOverride.filter((...[coordinates]: Parameters<typeof VertexData._TransformVector3Coordinates>) => !Array.isArray(coordinates))\r\n    private static _TransformVector3Coordinates(coordinates: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = coordinates.length) {\r\n        const coordinate = TmpVectors.Vector3[0];\r\n        const transformedCoordinate = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(coordinates, index, coordinate);\r\n            Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\r\n            coordinates[index] = transformedCoordinate.x;\r\n            coordinates[index + 1] = transformedCoordinate.y;\r\n            coordinates[index + 2] = transformedCoordinate.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector3Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector3Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector3[0];\r\n        const transformedNormal = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector4Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector4Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector4[0];\r\n        const transformedNormal = TmpVectors.Vector4[1];\r\n        for (let index = offset; index < offset + length; index += 4) {\r\n            Vector4.FromArrayToRef(normals, index, normal);\r\n            Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n            normals[index + 3] = transformedNormal.w;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[indices]: Parameters<typeof VertexData._FlipFaces>) => !Array.isArray(indices))\r\n    private static _FlipFaces(indices: IndicesArray, offset = 0, length = indices.length) {\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            const tmp = indices[index + 1];\r\n            indices[index + 1] = indices[index + 2];\r\n            indices[index + 2] = tmp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        const flip = matrix.determinant() < 0;\r\n        if (this.positions) {\r\n            VertexData._TransformVector3Coordinates(this.positions, matrix);\r\n        }\r\n\r\n        if (this.normals) {\r\n            VertexData._TransformVector3Normals(this.normals, matrix);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            VertexData._TransformVector4Normals(this.tangents, matrix);\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            VertexData._FlipFaces(this.indices);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Generates an array of vertex data where each vertex data only has one material info\r\n     * @returns An array of VertexData\r\n     */\r\n    public splitBasedOnMaterialID() {\r\n        if (!this.materialInfos || this.materialInfos.length < 2) {\r\n            return [this];\r\n        }\r\n\r\n        const result: VertexData[] = [];\r\n        for (const materialInfo of this.materialInfos) {\r\n            const vertexData = new VertexData();\r\n\r\n            if (this.positions) {\r\n                vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\r\n            }\r\n\r\n            if (this.normals) {\r\n                vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\r\n            }\r\n\r\n            if (this.tangents) {\r\n                vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.colors) {\r\n                vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.uvs) {\r\n                vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs2) {\r\n                vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs3) {\r\n                vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs4) {\r\n                vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs5) {\r\n                vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.uvs6) {\r\n                vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\r\n            }\r\n\r\n            if (this.matricesIndices) {\r\n                vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesIndicesExtra) {\r\n                vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesWeights) {\r\n                vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.matricesWeightsExtra) {\r\n                vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\r\n            }\r\n\r\n            if (this.indices) {\r\n                vertexData.indices = [];\r\n                for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {\r\n                    vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);\r\n                }\r\n            }\r\n\r\n            const newMaterialInfo = new VertexDataMaterialInfo();\r\n            newMaterialInfo.indexStart = 0;\r\n            newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;\r\n            newMaterialInfo.materialIndex = materialInfo.materialIndex;\r\n            newMaterialInfo.verticesStart = 0;\r\n            newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;\r\n            vertexData.materialInfos = [newMaterialInfo];\r\n\r\n            result.push(vertexData);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param others the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\r\n     * @param mergeMaterialIds defines a boolean indicating if we need to merge the material infos\r\n     * @param enableCompletion defines a boolean indicating if the vertex data should be completed to be compatible\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(others: VertexData | VertexData[], use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {\r\n        const vertexDatas: { vertexData: VertexData; transform?: Matrix }[] = Array.isArray(others)\r\n            ? others.map((other) => {\r\n                  return { vertexData: other };\r\n              })\r\n            : [{ vertexData: others }];\r\n        return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_mergeCoroutine(\r\n        transform: Matrix | undefined,\r\n        vertexDatas: { vertexData: VertexData; transform?: Matrix }[],\r\n        use32BitsIndices = false,\r\n        isAsync: boolean,\r\n        forceCloneIndices: boolean,\r\n        mergeMaterialIds = false,\r\n        enableCompletion = false\r\n    ): Coroutine<VertexData> {\r\n        this._validate();\r\n\r\n        let others = vertexDatas.map((vertexData) => vertexData.vertexData);\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        let root: VertexData = this;\r\n\r\n        if (enableCompletion) {\r\n            // First let's make sure we have the max set of attributes on the main vertex data\r\n            for (const other of others) {\r\n                if (!other) {\r\n                    continue;\r\n                }\r\n\r\n                other._validate();\r\n\r\n                if (!this.normals && other.normals) {\r\n                    this.normals = new Float32Array(this.positions!.length);\r\n                }\r\n\r\n                if (!this.tangents && other.tangents) {\r\n                    this.tangents = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (!this.uvs && other.uvs) {\r\n                    this.uvs = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs2 && other.uvs2) {\r\n                    this.uvs2 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs3 && other.uvs3) {\r\n                    this.uvs3 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs4 && other.uvs4) {\r\n                    this.uvs4 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs5 && other.uvs5) {\r\n                    this.uvs5 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.uvs6 && other.uvs6) {\r\n                    this.uvs6 = new Float32Array((this.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (!this.colors && other.colors) {\r\n                    this.colors = new Float32Array((this.positions!.length / 3) * 4);\r\n                    this.colors.fill(1); // Set to white by default\r\n                }\r\n\r\n                if (!this.matricesIndices && other.matricesIndices) {\r\n                    this.matricesIndices = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (!this.matricesWeights && other.matricesWeights) {\r\n                    this.matricesWeights = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (!this.matricesIndicesExtra && other.matricesIndicesExtra) {\r\n                    this.matricesIndicesExtra = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (!this.matricesWeightsExtra && other.matricesWeightsExtra) {\r\n                    this.matricesWeightsExtra = new Float32Array((this.positions!.length / 3) * 4);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const other of others) {\r\n            if (!other) {\r\n                continue;\r\n            }\r\n\r\n            if (!enableCompletion) {\r\n                other._validate();\r\n                if (\r\n                    !this.normals !== !other.normals ||\r\n                    !this.tangents !== !other.tangents ||\r\n                    !this.uvs !== !other.uvs ||\r\n                    !this.uvs2 !== !other.uvs2 ||\r\n                    !this.uvs3 !== !other.uvs3 ||\r\n                    !this.uvs4 !== !other.uvs4 ||\r\n                    !this.uvs5 !== !other.uvs5 ||\r\n                    !this.uvs6 !== !other.uvs6 ||\r\n                    !this.colors !== !other.colors ||\r\n                    !this.matricesIndices !== !other.matricesIndices ||\r\n                    !this.matricesWeights !== !other.matricesWeights ||\r\n                    !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n                    !this.matricesWeightsExtra !== !other.matricesWeightsExtra\r\n                ) {\r\n                    throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n                }\r\n            } else {\r\n                // Align the others with main set of attributes\r\n                if (this.normals && !other.normals) {\r\n                    other.normals = new Float32Array(other.positions!.length);\r\n                }\r\n\r\n                if (this.tangents && !other.tangents) {\r\n                    other.tangents = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (this.uvs && !other.uvs) {\r\n                    other.uvs = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.uvs2 && !other.uvs2) {\r\n                    other.uvs2 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.uvs3 && !other.uvs3) {\r\n                    other.uvs3 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.uvs4 && !other.uvs4) {\r\n                    other.uvs4 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n                if (this.uvs5 && !other.uvs5) {\r\n                    other.uvs5 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.uvs6 && !other.uvs6) {\r\n                    other.uvs6 = new Float32Array((other.positions!.length / 3) * 2);\r\n                }\r\n\r\n                if (this.colors && !other.colors) {\r\n                    other.colors = new Float32Array((other.positions!.length / 3) * 4);\r\n                    other.colors.fill(1); // Set to white by default\r\n                }\r\n\r\n                if (this.matricesIndices && !other.matricesIndices) {\r\n                    other.matricesIndices = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n                if (this.matricesWeights && !other.matricesWeights) {\r\n                    other.matricesWeights = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (this.matricesIndicesExtra && !other.matricesIndicesExtra) {\r\n                    other.matricesIndicesExtra = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n\r\n                if (this.matricesWeightsExtra && !other.matricesWeightsExtra) {\r\n                    other.matricesWeightsExtra = new Float32Array((other.positions!.length / 3) * 4);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (mergeMaterialIds) {\r\n            // Merge material infos\r\n            let materialIndex = 0;\r\n            let indexOffset = 0;\r\n            let vertexOffset = 0;\r\n            const materialInfos: VertexDataMaterialInfo[] = [];\r\n            let currentMaterialInfo: Nullable<VertexDataMaterialInfo> = null;\r\n            const vertexDataList: { vertexData: VertexData; transform?: Matrix }[] = [];\r\n\r\n            // We need to split vertexData with more than one materialInfo\r\n            for (const split of this.splitBasedOnMaterialID()) {\r\n                vertexDataList.push({ vertexData: split, transform: transform });\r\n            }\r\n\r\n            for (const data of vertexDatas) {\r\n                if (!data.vertexData) {\r\n                    continue;\r\n                }\r\n                for (const split of data.vertexData.splitBasedOnMaterialID()) {\r\n                    vertexDataList.push({ vertexData: split, transform: data.transform });\r\n                }\r\n            }\r\n\r\n            // Sort by material IDs\r\n            vertexDataList.sort((a, b) => {\r\n                const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;\r\n                const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;\r\n\r\n                if (matInfoA > matInfoB) {\r\n                    return 1;\r\n                }\r\n\r\n                if (matInfoA === matInfoB) {\r\n                    return 0;\r\n                }\r\n\r\n                return -1;\r\n            });\r\n\r\n            // Build the new material info\r\n            for (const vertexDataSource of vertexDataList) {\r\n                const vertexData = vertexDataSource.vertexData;\r\n                if (vertexData.materialInfos) {\r\n                    materialIndex = vertexData.materialInfos[0].materialIndex;\r\n                } else {\r\n                    materialIndex = 0;\r\n                }\r\n                if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {\r\n                    currentMaterialInfo.indexCount += vertexData.indices!.length;\r\n                    currentMaterialInfo.verticesCount += vertexData.positions!.length / 3;\r\n                } else {\r\n                    const materialInfo = new VertexDataMaterialInfo();\r\n                    materialInfo.materialIndex = materialIndex;\r\n                    materialInfo.indexStart = indexOffset;\r\n                    materialInfo.indexCount = vertexData.indices!.length;\r\n                    materialInfo.verticesStart = vertexOffset;\r\n                    materialInfo.verticesCount = vertexData.positions!.length / 3;\r\n\r\n                    materialInfos.push(materialInfo);\r\n                    currentMaterialInfo = materialInfo;\r\n                }\r\n                indexOffset += vertexData.indices!.length;\r\n                vertexOffset += vertexData.positions!.length / 3;\r\n            }\r\n            // Extract sorted values\r\n            const first = vertexDataList.splice(0, 1)[0];\r\n            root = first.vertexData;\r\n            transform = first.transform;\r\n            others = vertexDataList.map((v) => v.vertexData);\r\n            vertexDatas = vertexDataList;\r\n\r\n            this.materialInfos = materialInfos;\r\n        }\r\n\r\n        // Merge geometries\r\n        const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), root.indices?.length ?? 0);\r\n        const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === root.indices);\r\n        let indices = sliceIndices ? root.indices?.slice() : root.indices;\r\n        if (totalIndices > 0) {\r\n            let indicesOffset = indices?.length ?? 0;\r\n\r\n            if (!indices) {\r\n                indices = new Array<number>(totalIndices);\r\n            }\r\n\r\n            if (indices.length !== totalIndices) {\r\n                if (Array.isArray(indices)) {\r\n                    indices.length = totalIndices;\r\n                } else {\r\n                    const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\r\n                    temp.set(indices);\r\n                    indices = temp;\r\n                }\r\n\r\n                if (transform && transform.determinant() < 0) {\r\n                    VertexData._FlipFaces(indices, 0, indicesOffset);\r\n                }\r\n            }\r\n\r\n            let positionsOffset = root.positions ? root.positions.length / 3 : 0;\r\n            for (const { vertexData: other, transform } of vertexDatas) {\r\n                if (other.indices) {\r\n                    for (let index = 0; index < other.indices.length; index++) {\r\n                        indices[indicesOffset + index] = other.indices[index] + positionsOffset;\r\n                    }\r\n\r\n                    if (transform && transform.determinant() < 0) {\r\n                        VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\r\n                    }\r\n\r\n                    // The call to _validate already checked for positions\r\n                    positionsOffset += other.positions!.length / 3;\r\n                    indicesOffset += other.indices.length;\r\n\r\n                    if (isAsync) {\r\n                        yield;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.indices = indices!;\r\n\r\n        this.positions = VertexData._MergeElement(\r\n            VertexBuffer.PositionKind,\r\n            root.positions,\r\n            transform,\r\n            vertexDatas.map((other) => [other.vertexData.positions, other.transform])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        if (root.normals) {\r\n            this.normals = VertexData._MergeElement(\r\n                VertexBuffer.NormalKind,\r\n                root.normals,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.normals, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.tangents) {\r\n            this.tangents = VertexData._MergeElement(\r\n                VertexBuffer.TangentKind,\r\n                root.tangents,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.tangents, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs) {\r\n            this.uvs = VertexData._MergeElement(\r\n                VertexBuffer.UVKind,\r\n                root.uvs,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs2) {\r\n            this.uvs2 = VertexData._MergeElement(\r\n                VertexBuffer.UV2Kind,\r\n                root.uvs2,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs2, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs3) {\r\n            this.uvs3 = VertexData._MergeElement(\r\n                VertexBuffer.UV3Kind,\r\n                root.uvs3,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs3, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs4) {\r\n            this.uvs4 = VertexData._MergeElement(\r\n                VertexBuffer.UV4Kind,\r\n                root.uvs4,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs4, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs5) {\r\n            this.uvs5 = VertexData._MergeElement(\r\n                VertexBuffer.UV5Kind,\r\n                root.uvs5,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs5, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.uvs6) {\r\n            this.uvs6 = VertexData._MergeElement(\r\n                VertexBuffer.UV6Kind,\r\n                root.uvs6,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.uvs6, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.colors) {\r\n            this.colors = VertexData._MergeElement(\r\n                VertexBuffer.ColorKind,\r\n                root.colors,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.colors, other.transform])\r\n            );\r\n            if (root.hasVertexAlpha !== undefined || vertexDatas.some((other) => other.vertexData.hasVertexAlpha !== undefined)) {\r\n                this.hasVertexAlpha = root.hasVertexAlpha || vertexDatas.some((other) => other.vertexData.hasVertexAlpha);\r\n            }\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesIndices) {\r\n            this.matricesIndices = VertexData._MergeElement(\r\n                VertexBuffer.MatricesIndicesKind,\r\n                root.matricesIndices,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesIndices, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesWeights) {\r\n            this.matricesWeights = VertexData._MergeElement(\r\n                VertexBuffer.MatricesWeightsKind,\r\n                root.matricesWeights,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesWeights, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesIndicesExtra) {\r\n            this.matricesIndicesExtra = VertexData._MergeElement(\r\n                VertexBuffer.MatricesIndicesExtraKind,\r\n                root.matricesIndicesExtra,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesIndicesExtra, other.transform])\r\n            );\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n        if (root.matricesWeightsExtra) {\r\n            this.matricesWeightsExtra = VertexData._MergeElement(\r\n                VertexBuffer.MatricesWeightsExtraKind,\r\n                root.matricesWeightsExtra,\r\n                transform,\r\n                vertexDatas.map((other) => [other.vertexData.matricesWeightsExtra, other.transform])\r\n            );\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private static _MergeElement(\r\n        kind: string,\r\n        source: Nullable<FloatArray>,\r\n        transform: Matrix | undefined,\r\n        others: readonly (readonly [element: Nullable<FloatArray>, transform?: Matrix])[]\r\n    ): Nullable<FloatArray> {\r\n        const nonNullOthers = others.filter((other): other is [element: FloatArray, transform?: Matrix] => other[0] !== null && other[0] !== undefined);\r\n\r\n        // If there is no source to copy and no other non-null sources then skip this element.\r\n        if (!source && nonNullOthers.length == 0) {\r\n            return source;\r\n        }\r\n\r\n        if (!source) {\r\n            return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\r\n        }\r\n\r\n        const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\r\n\r\n        const transformRange =\r\n            kind === VertexBuffer.PositionKind\r\n                ? VertexData._TransformVector3Coordinates\r\n                : kind === VertexBuffer.NormalKind\r\n                  ? VertexData._TransformVector3Normals\r\n                  : kind === VertexBuffer.TangentKind\r\n                    ? VertexData._TransformVector4Normals\r\n                    : () => {};\r\n\r\n        if (source instanceof Float32Array) {\r\n            // use non-loop method when the source is Float32Array\r\n            const ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            transform && transformRange(ret32, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                ret32.set(vertexData, offset);\r\n                transform && transformRange(ret32, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret32;\r\n        } else {\r\n            // don't use concat as it is super slow, just loop for other cases\r\n            const ret = new Array<number>(len);\r\n            for (let i = 0; i < source.length; i++) {\r\n                ret[i] = source[i];\r\n            }\r\n            transform && transformRange(ret, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                for (let i = 0; i < vertexData.length; i++) {\r\n                    ret[offset + i] = vertexData[i];\r\n                }\r\n                transform && transformRange(ret, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if (values.length % stride !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) {\r\n            validateElementCount(VertexBuffer.NormalKind, this.normals);\r\n        }\r\n        if (this.tangents) {\r\n            validateElementCount(VertexBuffer.TangentKind, this.tangents);\r\n        }\r\n        if (this.uvs) {\r\n            validateElementCount(VertexBuffer.UVKind, this.uvs);\r\n        }\r\n        if (this.uvs2) {\r\n            validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\r\n        }\r\n        if (this.uvs3) {\r\n            validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\r\n        }\r\n        if (this.uvs4) {\r\n            validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\r\n        }\r\n        if (this.uvs5) {\r\n            validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\r\n        }\r\n        if (this.uvs6) {\r\n            validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\r\n        }\r\n        if (this.colors) {\r\n            validateElementCount(VertexBuffer.ColorKind, this.colors);\r\n        }\r\n        if (this.matricesIndices) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\r\n        }\r\n        if (this.matricesWeights) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\r\n        }\r\n        if (this.matricesIndicesExtra) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\r\n        }\r\n        if (this.matricesWeightsExtra) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current vertex data\r\n     * @returns a copy of the current data\r\n     */\r\n    public clone() {\r\n        const serializationObject = this.serialize();\r\n        return VertexData.Parse(serializationObject);\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = Array.from(this.positions);\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = Array.from(this.normals);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = Array.from(this.tangents);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = Array.from(this.uvs);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = Array.from(this.uvs2);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = Array.from(this.uvs3);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = Array.from(this.uvs4);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = Array.from(this.uvs5);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = Array.from(this.uvs6);\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = Array.from(this.colors);\r\n            serializationObject.hasVertexAlpha = this.hasVertexAlpha;\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = Array.from(this.matricesIndices);\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = Array.from(this.matricesWeights);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);\r\n            serializationObject.matricesIndicesExtra._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);\r\n        }\r\n\r\n        serializationObject.indices = this.indices ? Array.from(this.indices as number[]) : [];\r\n\r\n        if (this.materialInfos) {\r\n            serializationObject.materialInfos = [];\r\n            for (const materialInfo of this.materialInfos) {\r\n                const materialInfoSerializationObject = {\r\n                    indexStart: materialInfo.indexStart,\r\n                    indexCount: materialInfo.indexCount,\r\n                    materialIndex: materialInfo.materialIndex,\r\n                    verticesStart: materialInfo.verticesStart,\r\n                    verticesCount: materialInfo.verticesCount,\r\n                };\r\n                serializationObject.materialInfos.push(materialInfoSerializationObject);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        const result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            const geometry = (meshOrGeometry as Mesh).geometry || (meshOrGeometry as Geometry);\r\n            const vertexBuffer = geometry.getVertexBuffer(VertexBuffer.ColorKind)!;\r\n            const colors = geometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy)!;\r\n            if (vertexBuffer.getSize() === 3) {\r\n                const newColors = new Float32Array((colors.length * 4) / 3);\r\n                for (let i = 0, j = 0; i < colors.length; i += 3, j += 4) {\r\n                    newColors[j] = colors[i];\r\n                    newColors[j + 1] = colors[i + 1];\r\n                    newColors[j + 2] = colors[i + 2];\r\n                    newColors[j + 3] = 1;\r\n                }\r\n                result.colors = newColors;\r\n            } else if (vertexBuffer.getSize() === 4) {\r\n                result.colors = colors;\r\n            } else {\r\n                throw new Error(`Unexpected number of color components: ${vertexBuffer.getSize()}`);\r\n            }\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n     * * pathArray array of paths, each of which an array of successive Vector3\r\n     * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n     * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n     * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n     * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n     * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @returns the VertexData of the ribbon\r\n     * @deprecated use CreateRibbonVertexData instead\r\n     */\r\n    public static CreateRibbon(options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    }): VertexData {\r\n        throw _WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n     * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\r\n     */\r\n    public static CreateBox(options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param options.pattern\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateTiledBoxVertexData instead\r\n     */\r\n    public static CreateTiledBox(options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * pattern a limited pattern arrangement depending on the number\r\n     * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n     * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n     * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the tiled plane\r\n     * @deprecated use CreateTiledPlaneVertexData instead\r\n     */\r\n    public static CreateTiledPlane(options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * segments sets the number of horizontal strips optional, default 32\r\n     * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n     * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n     * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n     * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n     * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n     * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the ellipsoid\r\n     * @deprecated use CreateSphereVertexData instead\r\n     */\r\n    public static CreateSphere(options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * height sets the height (y direction) of the cylinder, optional, default 2\r\n     * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n     * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n     * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     * @deprecated please use CreateCylinderVertexData instead\r\n     */\r\n    public static CreateCylinder(options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * diameter the diameter of the torus, optional default 1\r\n     * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the torus\r\n     * @deprecated use CreateTorusVertexData instead\r\n     */\r\n    public static CreateTorus(options: {\r\n        diameter?: number;\r\n        thickness?: number;\r\n        tessellation?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @returns the VertexData of the LineSystem\r\n     * @deprecated use CreateLineSystemVertexData instead\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @returns the VertexData for the DashedLines\r\n     * @deprecated use CreateDashedLinesVertexData instead\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @returns the VertexData of the Ground\r\n     * @deprecated Please use CreateGroundVertexData instead\r\n     */\r\n    public static CreateGround(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     * * xmin the ground minimum X coordinate, optional, default -1\r\n     * * zmin the ground minimum Z coordinate, optional, default -1\r\n     * * xmax the ground maximum X coordinate, optional, default 1\r\n     * * zmax the ground maximum Z coordinate, optional, default 1\r\n     * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n     * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @returns the VertexData of the TiledGround\r\n     * @deprecated use CreateTiledGroundVertexData instead\r\n     */\r\n    public static CreateTiledGround(options: {\r\n        xmin: number;\r\n        zmin: number;\r\n        xmax: number;\r\n        zmax: number;\r\n        subdivisions?: { w: number; h: number };\r\n        precision?: { w: number; h: number };\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n     * * width the width (x direction) of the ground\r\n     * * height the height (z direction) of the ground\r\n     * * subdivisions the number of subdivisions per side\r\n     * * minHeight the minimum altitude on the ground, optional, default 0\r\n     * * maxHeight the maximum altitude on the ground, optional default 1\r\n     * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n     * * buffer the array holding the image color data\r\n     * * bufferWidth the width of image\r\n     * * bufferHeight the height of image\r\n     * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     * @deprecated use CreateGroundFromHeightMapVertexData instead\r\n     */\r\n    public static CreateGroundFromHeightMap(options: {\r\n        width: number;\r\n        height: number;\r\n        subdivisions: number;\r\n        minHeight: number;\r\n        maxHeight: number;\r\n        colorFilter: Color3;\r\n        buffer: Uint8Array;\r\n        bufferWidth: number;\r\n        bufferHeight: number;\r\n        alphaFilter: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n     * * size sets the width and height of the plane to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreatePlaneVertexData instead\r\n     */\r\n    public static CreatePlane(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n     * * radius the radius of the disc, optional default 0.5\r\n     * * tessellation the number of polygon sides, optional, default 64\r\n     * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreateDiscVertexData instead\r\n     */\r\n    public static CreateDisc(options: { radius?: number; tessellation?: number; arc?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     * @deprecated use CreatePolygonVertexData instead\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n     * * radius the radius of the IcoSphere, optional default 1\r\n     * * radiusX allows stretching in the x direction, optional, default radius\r\n     * * radiusY allows stretching in the y direction, optional, default radius\r\n     * * radiusZ allows stretching in the z direction, optional, default radius\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the IcoSphere\r\n     * @deprecated use CreateIcoSphereVertexData instead\r\n     */\r\n    public static CreateIcoSphere(options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the Polyhedron\r\n     * @deprecated use CreatePolyhedronVertexData instead\r\n     */\r\n    public static CreatePolyhedron(options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\r\n     */\r\n    public static CreateCapsule(\r\n        options: ICreateCapsuleOptions = {\r\n            orientation: Vector3.Up(),\r\n            subdivisions: 2,\r\n            tessellation: 16,\r\n            height: 1,\r\n            radius: 0.25,\r\n            capSubdivisions: 6,\r\n        }\r\n    ): VertexData {\r\n        throw _WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n     * * radius the radius of the torus knot, optional, default 2\r\n     * * tube the thickness of the tube, optional, default 0.5\r\n     * * radialSegments the number of sides on each tube segments, optional, default 32\r\n     * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n     * * p the number of windings around the z axis, optional,  default 2\r\n     * * q the number of windings around the x axis, optional,  default 3\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the Torus Knot\r\n     * @deprecated use CreateTorusKnotVertexData instead\r\n     */\r\n    public static CreateTorusKnot(options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n     * * facetNormals : optional array of facet normals (vector3)\r\n     * * facetPositions : optional array of facet positions (vector3)\r\n     * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n     * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n     * * bInfo : optional bounding info, required for facetPartitioning computation\r\n     * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n     * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\r\n     * * useRightHandedSystem: optional boolean to for right handed system computation\r\n     * * depthSort : optional boolean to enable the facet depth sort computation\r\n     * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n     * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     */\r\n    public static ComputeNormals(\r\n        positions: any,\r\n        indices: any,\r\n        normals: any,\r\n        options?: {\r\n            facetNormals?: any;\r\n            facetPositions?: any;\r\n            facetPartitioning?: any;\r\n            ratio?: number;\r\n            bInfo?: any;\r\n            bbSize?: Vector3;\r\n            subDiv?: any;\r\n            useRightHandedSystem?: boolean;\r\n            depthSort?: boolean;\r\n            distanceTo?: Vector3;\r\n            depthSortedFacets?: any;\r\n        }\r\n    ): void {\r\n        // temporary scalar variables\r\n        let index = 0; // facet index\r\n        let p1p2x = 0.0; // p1p2 vector x coordinate\r\n        let p1p2y = 0.0; // p1p2 vector y coordinate\r\n        let p1p2z = 0.0; // p1p2 vector z coordinate\r\n        let p3p2x = 0.0; // p3p2 vector x coordinate\r\n        let p3p2y = 0.0; // p3p2 vector y coordinate\r\n        let p3p2z = 0.0; // p3p2 vector z coordinate\r\n        let faceNormalx = 0.0; // facet normal x coordinate\r\n        let faceNormaly = 0.0; // facet normal y coordinate\r\n        let faceNormalz = 0.0; // facet normal z coordinate\r\n        let length = 0.0; // facet normal length before normalization\r\n        let v1x = 0; // vector1 x index in the positions array\r\n        let v1y = 0; // vector1 y index in the positions array\r\n        let v1z = 0; // vector1 z index in the positions array\r\n        let v2x = 0; // vector2 x index in the positions array\r\n        let v2y = 0; // vector2 y index in the positions array\r\n        let v2z = 0; // vector2 z index in the positions array\r\n        let v3x = 0; // vector3 x index in the positions array\r\n        let v3y = 0; // vector3 y index in the positions array\r\n        let v3z = 0; // vector3 z index in the positions array\r\n        let computeFacetNormals = false;\r\n        let computeFacetPositions = false;\r\n        let computeFacetPartitioning = false;\r\n        let computeDepthSort = false;\r\n        let faceNormalSign = 1;\r\n        let ratio = 0;\r\n        let distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = options.facetNormals ? true : false;\r\n            computeFacetPositions = options.facetPositions ? true : false;\r\n            computeFacetPartitioning = options.facetPartitioning ? true : false;\r\n            faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = options.depthSort ? true : false;\r\n            distanceTo = <Vector3>options.distanceTo;\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\r\n            //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = (options.subDiv.X * ratio) / options.bbSize.x;\r\n            ySubRatio = (options.subDiv.Y * ratio) / options.bbSize.y;\r\n            zSubRatio = (options.subDiv.Z * ratio) / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        const nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\r\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\r\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\r\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[block_idx_v1].push(index);\r\n                if (block_idx_v2 != block_idx_v1) {\r\n                    options.facetPartitioning[block_idx_v2].push(index);\r\n                }\r\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\r\n                    options.facetPartitioning[block_idx_v3].push(index);\r\n                }\r\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\r\n                    options.facetPartitioning[block_idx_o].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                const dsf = options.depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx; // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ComputeSides(\r\n        sideOrientation: number,\r\n        positions: FloatArray,\r\n        indices: FloatArray | IndicesArray,\r\n        normals: FloatArray,\r\n        uvs: FloatArray,\r\n        frontUVs?: Vector4,\r\n        backUVs?: Vector4\r\n    ) {\r\n        const li: number = indices.length;\r\n        const ln: number = normals.length;\r\n        let i: number;\r\n        let n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    const tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE: {\r\n                // positions\r\n                const lp: number = positions.length;\r\n                const l: number = lp / 3;\r\n                for (let p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                const lu: number = uvs.length;\r\n                let u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a VertexData from serialized data\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @returns a VertexData\r\n     */\r\n    public static Parse(parsedVertexData: any) {\r\n        const vertexData = new VertexData();\r\n\r\n        // positions\r\n        const positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        const normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        const tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        const uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        const uvs2 = parsedVertexData.uvs2;\r\n        if (uvs2) {\r\n            vertexData.set(uvs2, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        const uvs3 = parsedVertexData.uvs3;\r\n        if (uvs3) {\r\n            vertexData.set(uvs3, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        const uvs4 = parsedVertexData.uvs4;\r\n        if (uvs4) {\r\n            vertexData.set(uvs4, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        const uvs5 = parsedVertexData.uvs5;\r\n        if (uvs5) {\r\n            vertexData.set(uvs5, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        const uvs6 = parsedVertexData.uvs6;\r\n        if (uvs6) {\r\n            vertexData.set(uvs6, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        const colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n            if (parsedVertexData.hasVertexAlpha !== undefined) {\r\n                vertexData.hasVertexAlpha = parsedVertexData.hasVertexAlpha;\r\n            }\r\n        }\r\n\r\n        // matricesIndices\r\n        const matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        const matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        const indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        // MaterialInfos\r\n        const materialInfos = parsedVertexData.materialInfos;\r\n        if (materialInfos) {\r\n            vertexData.materialInfos = [];\r\n            for (const materialInfoFromJSON of materialInfos) {\r\n                const materialInfo = new VertexDataMaterialInfo();\r\n                materialInfo.indexCount = materialInfoFromJSON.indexCount;\r\n                materialInfo.indexStart = materialInfoFromJSON.indexStart;\r\n                materialInfo.verticesCount = materialInfoFromJSON.verticesCount;\r\n                materialInfo.verticesStart = materialInfoFromJSON.verticesStart;\r\n                materialInfo.materialIndex = materialInfoFromJSON.materialIndex;\r\n                vertexData.materialInfos.push(materialInfo);\r\n            }\r\n        }\r\n\r\n        return vertexData;\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        const vertexData = VertexData.Parse(parsedVertexData);\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n", "import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { serialize, serializeAsVector3, serializeAsQuaternion } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { Observable } from \"../Misc/observable\";\r\n\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Space } from \"../Maths/math.axis\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\nconst convertRHSToLHS = Matrix.Compose(Vector3.One(), Quaternion.FromEulerAngles(0, Math.PI, 0), Vector3.Zero());\r\n\r\n/**\r\n * A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/transform_node\r\n */\r\nexport class TransformNode extends Node {\r\n    // Statics\r\n    /**\r\n     * Object will not rotate to face the camera\r\n     */\r\n    public static BILLBOARDMODE_NONE = 0;\r\n    /**\r\n     * Object will rotate to face the camera but only on the x axis\r\n     */\r\n    public static BILLBOARDMODE_X = 1;\r\n    /**\r\n     * Object will rotate to face the camera but only on the y axis\r\n     */\r\n    public static BILLBOARDMODE_Y = 2;\r\n    /**\r\n     * Object will rotate to face the camera but only on the z axis\r\n     */\r\n    public static BILLBOARDMODE_Z = 4;\r\n    /**\r\n     * Object will rotate to face the camera\r\n     */\r\n    public static BILLBOARDMODE_ALL = 7;\r\n    /**\r\n     * Object will rotate to face the camera's position instead of orientation\r\n     */\r\n    public static BILLBOARDMODE_USE_POSITION = 128;\r\n    /**\r\n     * Child transform with Billboard flags should or should not apply parent rotation (default if off)\r\n     */\r\n    public static BillboardUseParentOrientation: boolean = false;\r\n\r\n    private static _TmpRotation = Quaternion.Zero();\r\n    private static _TmpScaling = Vector3.Zero();\r\n    private static _TmpTranslation = Vector3.Zero();\r\n\r\n    private _forward = new Vector3(0, 0, 1);\r\n    private _up = new Vector3(0, 1, 0);\r\n    private _right = new Vector3(1, 0, 0);\r\n\r\n    // Properties\r\n    @serializeAsVector3(\"position\")\r\n    private _position = Vector3.Zero();\r\n\r\n    @serializeAsVector3(\"rotation\")\r\n    private _rotation = Vector3.Zero();\r\n\r\n    @serializeAsQuaternion(\"rotationQuaternion\")\r\n    private _rotationQuaternion: Nullable<Quaternion> = null;\r\n\r\n    @serializeAsVector3(\"scaling\")\r\n    protected _scaling = Vector3.One();\r\n    private _transformToBoneReferal: Nullable<TransformNode> = null;\r\n    private _currentParentWhenAttachingToBone: Nullable<Node>;\r\n    private _isAbsoluteSynced = false;\r\n\r\n    @serialize(\"billboardMode\")\r\n    private _billboardMode = TransformNode.BILLBOARDMODE_NONE;\r\n\r\n    /**\r\n     * Gets or sets the billboard mode. Default is 0.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | BILLBOARDMODE_NONE |  |\r\n     * | 1 | BILLBOARDMODE_X |  |\r\n     * | 2 | BILLBOARDMODE_Y |  |\r\n     * | 4 | BILLBOARDMODE_Z |  |\r\n     * | 7 | BILLBOARDMODE_ALL |  |\r\n     *\r\n     */\r\n    public get billboardMode() {\r\n        return this._billboardMode;\r\n    }\r\n\r\n    public set billboardMode(value: number) {\r\n        if (this._billboardMode === value) {\r\n            return;\r\n        }\r\n        this._billboardMode = value;\r\n        this._cache.useBillboardPosition = (this._billboardMode & TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;\r\n        this._computeUseBillboardPath();\r\n    }\r\n\r\n    private _preserveParentRotationForBillboard = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that parent rotation should be preserved when using billboards.\r\n     * This could be useful for glTF objects where parent rotation helps converting from right handed to left handed\r\n     */\r\n    public get preserveParentRotationForBillboard() {\r\n        return this._preserveParentRotationForBillboard;\r\n    }\r\n\r\n    public set preserveParentRotationForBillboard(value: boolean) {\r\n        if (value === this._preserveParentRotationForBillboard) {\r\n            return;\r\n        }\r\n        this._preserveParentRotationForBillboard = value;\r\n        this._computeUseBillboardPath();\r\n    }\r\n\r\n    private _computeUseBillboardPath(): void {\r\n        this._cache.useBillboardPath = this._billboardMode !== TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;\r\n    }\r\n\r\n    /**\r\n     * Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube\r\n     */\r\n    @serialize()\r\n    public scalingDeterminant = 1;\r\n\r\n    @serialize(\"infiniteDistance\")\r\n    private _infiniteDistance = false;\r\n\r\n    /**\r\n     * Gets or sets the distance of the object to max, often used by skybox\r\n     */\r\n    public get infiniteDistance() {\r\n        return this._infiniteDistance;\r\n    }\r\n\r\n    public set infiniteDistance(value: boolean) {\r\n        if (this._infiniteDistance === value) {\r\n            return;\r\n        }\r\n\r\n        this._infiniteDistance = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.\r\n     * By default the system will update normals to compensate\r\n     */\r\n    @serialize()\r\n    public ignoreNonUniformScaling = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that even if rotationQuaternion is defined, you can keep updating rotation property and Babylon.js will just mix both\r\n     */\r\n    @serialize()\r\n    public reIntegrateRotationIntoRotationQuaternion = false;\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _poseMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _localMatrix = Matrix.Zero();\r\n\r\n    private _usePivotMatrix = false;\r\n    private _absolutePosition = Vector3.Zero();\r\n    private _absoluteScaling = Vector3.Zero();\r\n    private _absoluteRotationQuaternion = Quaternion.Identity();\r\n    private _pivotMatrix = Matrix.Identity();\r\n    private _pivotMatrixInverse: Matrix;\r\n    /** @internal */\r\n    public _postMultiplyPivotMatrix = false;\r\n\r\n    protected _isWorldMatrixFrozen = false;\r\n\r\n    /** @internal */\r\n    public _indexInSceneTransformNodesArray = -1;\r\n\r\n    /**\r\n     * An event triggered after the world matrix is updated\r\n     */\r\n    public onAfterWorldMatrixUpdateObservable = new Observable<TransformNode>();\r\n\r\n    constructor(name: string, scene: Nullable<Scene> = null, isPure = true) {\r\n        super(name, scene, false);\r\n\r\n        if (isPure) {\r\n            this.getScene().addTransformNode(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"TransformNode\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"TransformNode\";\r\n    }\r\n\r\n    /**\r\n     * Gets or set the node position (default is (0.0, 0.0, 0.0))\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._position = newPosition;\r\n        this._markAsDirtyInternal();\r\n    }\r\n\r\n    /**\r\n     * return true if a pivot has been set\r\n     * @returns true if a pivot matrix is used\r\n     */\r\n    public isUsingPivotMatrix(): boolean {\r\n        return this._usePivotMatrix;\r\n    }\r\n\r\n    /**\r\n     * @returns true if pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect.\r\n     */\r\n    public isUsingPostMultiplyPivotMatrix(): boolean {\r\n        return this._postMultiplyPivotMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).\r\n     * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion\r\n     */\r\n    public get rotation(): Vector3 {\r\n        return this._rotation;\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this._rotation = newRotation;\r\n        this._rotationQuaternion = null;\r\n        this._markAsDirtyInternal();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (1.0, 1.0, 1.0)).\r\n     */\r\n    public get scaling(): Vector3 {\r\n        return this._scaling;\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this._scaling = newScaling;\r\n        this._markAsDirtyInternal();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).\r\n     * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)\r\n     */\r\n    public get rotationQuaternion(): Nullable<Quaternion> {\r\n        return this._rotationQuaternion;\r\n    }\r\n\r\n    public set rotationQuaternion(quaternion: Nullable<Quaternion>) {\r\n        this._rotationQuaternion = quaternion;\r\n        //reset the rotation vector.\r\n        if (quaternion) {\r\n            this._rotation.setAll(0.0);\r\n        }\r\n        this._markAsDirtyInternal();\r\n    }\r\n\r\n    /**\r\n     * Allow user to specify custom mechanism for mark as dirty\r\n     */\r\n    public customMarkAsDirty: () => void;\r\n\r\n    private _markAsDirtyInternal(): void {\r\n        if (this._isDirty) {\r\n            return;\r\n        }\r\n        this._isDirty = true;\r\n\r\n        if (this.customMarkAsDirty) {\r\n            this.customMarkAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The forward direction of that transform in world space.\r\n     */\r\n    public get forward(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1.0 : 1.0, this.getWorldMatrix(), this._forward);\r\n        return this._forward.normalize();\r\n    }\r\n\r\n    /**\r\n     * The up direction of that transform in world space.\r\n     */\r\n    public get up(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);\r\n        return this._up.normalize();\r\n    }\r\n\r\n    /**\r\n     * The right direction of that transform in world space.\r\n     */\r\n    public get right(): Vector3 {\r\n        Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1.0 : 1.0, 0, 0, this.getWorldMatrix(), this._right);\r\n        return this._right.normalize();\r\n    }\r\n\r\n    /**\r\n     * Copies the parameter passed Matrix into the mesh Pose matrix.\r\n     * @param matrix the matrix to copy the pose from\r\n     * @returns this TransformNode.\r\n     */\r\n    public updatePoseMatrix(matrix: Matrix): TransformNode {\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = matrix.clone();\r\n            return this;\r\n        }\r\n        this._poseMatrix.copyFrom(matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh Pose matrix.\r\n     * @returns the pose matrix\r\n     */\r\n    public getPoseMatrix(): Matrix {\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = Matrix.Identity();\r\n        }\r\n        return this._poseMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _isSynchronized(): boolean {\r\n        const cache = this._cache;\r\n\r\n        if (this._billboardMode !== cache.billboardMode || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\r\n            return false;\r\n        }\r\n\r\n        if (cache.pivotMatrixUpdated) {\r\n            return false;\r\n        }\r\n\r\n        if (this._infiniteDistance) {\r\n            return false;\r\n        }\r\n\r\n        if (this._position._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        if (this._scaling._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        if ((this._rotationQuaternion && this._rotationQuaternion._isDirty) || this._rotation._isDirty) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _initCache() {\r\n        super._initCache();\r\n\r\n        const cache = this._cache;\r\n        cache.localMatrixUpdated = false;\r\n        cache.billboardMode = -1;\r\n        cache.infiniteDistance = false;\r\n        cache.useBillboardPosition = false;\r\n        cache.useBillboardPath = false;\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute position.\r\n     * Returns a Vector3.\r\n     */\r\n    public get absolutePosition(): Vector3 {\r\n        return this.getAbsolutePosition();\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute scaling.\r\n     * Returns a Vector3.\r\n     */\r\n    public get absoluteScaling(): Vector3 {\r\n        this._syncAbsoluteScalingAndRotation();\r\n        return this._absoluteScaling;\r\n    }\r\n\r\n    /**\r\n     * Returns the current mesh absolute rotation.\r\n     * Returns a Quaternion.\r\n     */\r\n    public get absoluteRotationQuaternion(): Quaternion {\r\n        this._syncAbsoluteScalingAndRotation();\r\n        return this._absoluteRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Sets a new matrix to apply before all other transformation\r\n     * @param matrix defines the transform matrix\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPreTransformMatrix(matrix: Matrix): TransformNode {\r\n        return this.setPivotMatrix(matrix, false);\r\n    }\r\n\r\n    /**\r\n     * Sets a new pivot matrix to the current node\r\n     * @param matrix defines the new pivot matrix to use\r\n     * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPivotMatrix(matrix: DeepImmutable<Matrix>, postMultiplyPivotMatrix = true): TransformNode {\r\n        this._pivotMatrix.copyFrom(matrix);\r\n        this._usePivotMatrix = !this._pivotMatrix.isIdentity();\r\n\r\n        this._cache.pivotMatrixUpdated = true;\r\n        this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;\r\n\r\n        if (this._postMultiplyPivotMatrix) {\r\n            if (!this._pivotMatrixInverse) {\r\n                this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);\r\n            } else {\r\n                this._pivotMatrix.invertToRef(this._pivotMatrixInverse);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh pivot matrix.\r\n     * Default : Identity.\r\n     * @returns the matrix\r\n     */\r\n    public getPivotMatrix(): Matrix {\r\n        return this._pivotMatrix;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean) },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Prevents the World matrix to be computed any longer\r\n     * @param newWorldMatrix defines an optional matrix to use as world matrix\r\n     * @param decompose defines whether to decompose the given newWorldMatrix or directly assign\r\n     * @returns the TransformNode.\r\n     */\r\n    public freezeWorldMatrix(newWorldMatrix: Nullable<Matrix> = null, decompose = false): TransformNode {\r\n        if (newWorldMatrix) {\r\n            if (decompose) {\r\n                this._rotation.setAll(0);\r\n                this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();\r\n                newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);\r\n                this.computeWorldMatrix(true);\r\n            } else {\r\n                this._worldMatrix = newWorldMatrix;\r\n                this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\r\n                this._afterComputeWorldMatrix();\r\n            }\r\n        } else {\r\n            this._isWorldMatrixFrozen = false; // no guarantee world is not already frozen, switch off temporarily\r\n            this.computeWorldMatrix(true);\r\n        }\r\n        this._isDirty = false;\r\n        this._isWorldMatrixFrozen = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Allows back the World matrix computation.\r\n     * @returns the TransformNode.\r\n     */\r\n    public unfreezeWorldMatrix() {\r\n        this._isWorldMatrixFrozen = false;\r\n        this.computeWorldMatrix(true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True if the World matrix has been frozen.\r\n     */\r\n    public get isWorldMatrixFrozen(): boolean {\r\n        return this._isWorldMatrixFrozen;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh absolute position in the World.\r\n     * @returns a Vector3.\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        this.computeWorldMatrix();\r\n        return this._absolutePosition;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh absolute position in the World from a Vector3 or an Array(3).\r\n     * @param absolutePosition the absolute position to set\r\n     * @returns the TransformNode.\r\n     */\r\n    public setAbsolutePosition(absolutePosition: Vector3): TransformNode {\r\n        if (!absolutePosition) {\r\n            return this;\r\n        }\r\n        let absolutePositionX;\r\n        let absolutePositionY;\r\n        let absolutePositionZ;\r\n        if (absolutePosition.x === undefined) {\r\n            if (arguments.length < 3) {\r\n                return this;\r\n            }\r\n            absolutePositionX = arguments[0];\r\n            absolutePositionY = arguments[1];\r\n            absolutePositionZ = arguments[2];\r\n        } else {\r\n            absolutePositionX = absolutePosition.x;\r\n            absolutePositionY = absolutePosition.y;\r\n            absolutePositionZ = absolutePosition.z;\r\n        }\r\n        if (this.parent) {\r\n            const invertParentWorldMatrix = TmpVectors.Matrix[0];\r\n            this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);\r\n            Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);\r\n        } else {\r\n            this.position.x = absolutePositionX;\r\n            this.position.y = absolutePositionY;\r\n            this.position.z = absolutePositionZ;\r\n        }\r\n\r\n        this._absolutePosition.copyFrom(absolutePosition);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh position in its local space.\r\n     * @param vector3 the position to set in localspace\r\n     * @returns the TransformNode.\r\n     */\r\n    public setPositionWithLocalVector(vector3: Vector3): TransformNode {\r\n        this.computeWorldMatrix();\r\n        this.position = Vector3.TransformNormal(vector3, this._localMatrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh position in the local space from the current World matrix values.\r\n     * @returns a new Vector3.\r\n     */\r\n    public getPositionExpressedInLocalSpace(): Vector3 {\r\n        this.computeWorldMatrix();\r\n        const invLocalWorldMatrix = TmpVectors.Matrix[0];\r\n        this._localMatrix.invertToRef(invLocalWorldMatrix);\r\n        return Vector3.TransformNormal(this.position, invLocalWorldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Translates the mesh along the passed Vector3 in its local space.\r\n     * @param vector3 the distance to translate in localspace\r\n     * @returns the TransformNode.\r\n     */\r\n    public locallyTranslate(vector3: Vector3): TransformNode {\r\n        this.computeWorldMatrix(true);\r\n        this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);\r\n        return this;\r\n    }\r\n\r\n    private static _LookAtVectorCache = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Orients a mesh towards a target point. Mesh must be drawn facing user.\r\n     * @param targetPoint the position (must be in same space as current mesh) to look at\r\n     * @param yawCor optional yaw (y-axis) correction in radians\r\n     * @param pitchCor optional pitch (x-axis) correction in radians\r\n     * @param rollCor optional roll (z-axis) correction in radians\r\n     * @param space the chosen space of the target\r\n     * @returns the TransformNode.\r\n     */\r\n    public lookAt(targetPoint: Vector3, yawCor: number = 0, pitchCor: number = 0, rollCor: number = 0, space: Space = Space.LOCAL): TransformNode {\r\n        const dv = TransformNode._LookAtVectorCache;\r\n        const pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();\r\n        targetPoint.subtractToRef(pos, dv);\r\n        this.setDirection(dv, yawCor, pitchCor, rollCor);\r\n\r\n        // Correct for parent's rotation offset\r\n        if (space === Space.WORLD && this.parent) {\r\n            if (this.rotationQuaternion) {\r\n                // Get local rotation matrix of the looking object\r\n                const rotationMatrix = TmpVectors.Matrix[0];\r\n                this.rotationQuaternion.toRotationMatrix(rotationMatrix);\r\n\r\n                // Offset rotation by parent's inverted rotation matrix to correct in world space\r\n                const parentRotationMatrix = TmpVectors.Matrix[1];\r\n                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\r\n                parentRotationMatrix.invert();\r\n                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\r\n                this.rotationQuaternion.fromRotationMatrix(rotationMatrix);\r\n            } else {\r\n                // Get local rotation matrix of the looking object\r\n                const quaternionRotation = TmpVectors.Quaternion[0];\r\n                Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);\r\n                const rotationMatrix = TmpVectors.Matrix[0];\r\n                quaternionRotation.toRotationMatrix(rotationMatrix);\r\n\r\n                // Offset rotation by parent's inverted rotation matrix to correct in world space\r\n                const parentRotationMatrix = TmpVectors.Matrix[1];\r\n                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\r\n                parentRotationMatrix.invert();\r\n                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\r\n                quaternionRotation.fromRotationMatrix(rotationMatrix);\r\n                quaternionRotation.toEulerAnglesToRef(this.rotation);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\r\n     * This Vector3 is expressed in the World space.\r\n     * @param localAxis axis to rotate\r\n     * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\r\n     */\r\n    public getDirection(localAxis: Vector3): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector3 \"result\" as the rotated Vector3 \"localAxis\" in the same rotation than the mesh.\r\n     * localAxis is expressed in the mesh local space.\r\n     * result is computed in the World space from the mesh World matrix.\r\n     * @param localAxis axis to rotate\r\n     * @param result the resulting transformnode\r\n     * @returns this TransformNode.\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, result: Vector3): TransformNode {\r\n        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets this transform node rotation to the given local axis.\r\n     * @param localAxis the axis in local space\r\n     * @param yawCor optional yaw (y-axis) correction in radians\r\n     * @param pitchCor optional pitch (x-axis) correction in radians\r\n     * @param rollCor optional roll (z-axis) correction in radians\r\n     * @returns this TransformNode\r\n     */\r\n    public setDirection(localAxis: Vector3, yawCor: number = 0, pitchCor: number = 0, rollCor: number = 0): TransformNode {\r\n        const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;\r\n        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\r\n        const pitch = -Math.atan2(localAxis.y, len);\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);\r\n        } else {\r\n            this.rotation.x = pitch + pitchCor;\r\n            this.rotation.y = yaw + yawCor;\r\n            this.rotation.z = rollCor;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a new pivot point to the current node\r\n     * @param point defines the new pivot point to use\r\n     * @param space defines if the point is in world or local space (local by default)\r\n     * @returns the current TransformNode\r\n     */\r\n    public setPivotPoint(point: Vector3, space: Space = Space.LOCAL): TransformNode {\r\n        if (this.getScene().getRenderId() == 0) {\r\n            this.computeWorldMatrix(true);\r\n        }\r\n\r\n        const wm = this.getWorldMatrix();\r\n\r\n        if (space == Space.WORLD) {\r\n            const tmat = TmpVectors.Matrix[0];\r\n            wm.invertToRef(tmat);\r\n            point = Vector3.TransformCoordinates(point, tmat);\r\n        }\r\n\r\n        return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.\r\n     * @returns the pivot point\r\n     */\r\n    public getPivotPoint(): Vector3 {\r\n        const point = Vector3.Zero();\r\n        this.getPivotPointToRef(point);\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Vector3 \"result\" with the coordinates of the mesh pivot point in the local space.\r\n     * @param result the vector3 to store the result\r\n     * @returns this TransformNode.\r\n     */\r\n    public getPivotPointToRef(result: Vector3): TransformNode {\r\n        result.x = -this._pivotMatrix.m[12];\r\n        result.y = -this._pivotMatrix.m[13];\r\n        result.z = -this._pivotMatrix.m[14];\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the mesh pivot point World coordinates.\r\n     * @returns a new Vector3 set with the mesh pivot point World coordinates.\r\n     */\r\n    public getAbsolutePivotPoint(): Vector3 {\r\n        const point = Vector3.Zero();\r\n        this.getAbsolutePivotPointToRef(point);\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector3 \"result\" coordinates with the mesh pivot point World coordinates.\r\n     * @param result vector3 to store the result\r\n     * @returns this TransformNode.\r\n     */\r\n    public getAbsolutePivotPointToRef(result: Vector3): TransformNode {\r\n        this.getPivotPointToRef(result);\r\n        Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Flag the transform node as dirty (Forcing it to update everything)\r\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\r\n     * @returns this  node\r\n     */\r\n    public override markAsDirty(property?: string): Node {\r\n        if (this._isDirty) {\r\n            return this;\r\n        }\r\n\r\n        // We need to explicitly update the children\r\n        // as the scene.evaluateActiveMeshes will not poll the transform nodes\r\n        if (this._children) {\r\n            for (const child of this._children) {\r\n                child.markAsDirty(property);\r\n            }\r\n        }\r\n        return super.markAsDirty(property);\r\n    }\r\n\r\n    /**\r\n     * Defines the passed node as the parent of the current node.\r\n     * The node will remain exactly where it is and its position / rotation will be updated accordingly.\r\n     * If you don't want to preserve the current rotation / position, assign the parent through parent accessor.\r\n     * Note that if the mesh has a pivot matrix / point defined it will be applied after the parent was updated.\r\n     * In that case the node will not remain in the same space as it is, as the pivot will be applied.\r\n     * To avoid this, you can set updatePivot to true and the pivot will be updated to identity\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/parent\r\n     * @param node the node ot set as the parent\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @param updatePivot if true, update the pivot matrix to keep the node in the same space as before\r\n     * @returns this TransformNode.\r\n     */\r\n    public setParent(node: Nullable<Node>, preserveScalingSign: boolean = false, updatePivot = false): TransformNode {\r\n        if (!node && !this.parent) {\r\n            return this;\r\n        }\r\n\r\n        const quatRotation = TmpVectors.Quaternion[0];\r\n        const position = TmpVectors.Vector3[0];\r\n        const scale = TmpVectors.Vector3[1];\r\n        const invParentMatrix = TmpVectors.Matrix[1];\r\n        Matrix.IdentityToRef(invParentMatrix);\r\n        const composedMatrix = TmpVectors.Matrix[0];\r\n        this.computeWorldMatrix(true);\r\n\r\n        let currentRotation = this.rotationQuaternion;\r\n        if (!currentRotation) {\r\n            currentRotation = TransformNode._TmpRotation;\r\n            Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);\r\n        }\r\n\r\n        // current global transformation without pivot\r\n        Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);\r\n        if (this.parent) {\r\n            composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);\r\n        }\r\n\r\n        // is a node was set, calculate the difference between this and the node\r\n        if (node) {\r\n            node.computeWorldMatrix(true).invertToRef(invParentMatrix);\r\n            composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);\r\n        }\r\n        composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : undefined);\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.copyFrom(quatRotation);\r\n        } else {\r\n            quatRotation.toEulerAnglesToRef(this.rotation);\r\n        }\r\n\r\n        this.scaling.copyFrom(scale);\r\n        this.position.copyFrom(position);\r\n\r\n        this.parent = node;\r\n\r\n        if (updatePivot) {\r\n            this.setPivotMatrix(Matrix.Identity());\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the passed mesh as a child to the current mesh.\r\n     * The node will remain exactly where it is and its position / rotation will be updated accordingly.\r\n     * This method is equivalent to calling setParent().\r\n     * @param mesh defines the child mesh\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @returns the current mesh\r\n     */\r\n    public addChild(mesh: TransformNode, preserveScalingSign: boolean = false): this {\r\n        mesh.setParent(this, preserveScalingSign);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the passed mesh from the current mesh children list\r\n     * @param mesh defines the child mesh\r\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\r\n     * @returns the current mesh\r\n     */\r\n    public removeChild(mesh: TransformNode, preserveScalingSign: boolean = false): this {\r\n        if (mesh.parent !== this) return this;\r\n        mesh.setParent(null, preserveScalingSign);\r\n        return this;\r\n    }\r\n\r\n    private _nonUniformScaling = false;\r\n    /**\r\n     * True if the scaling property of this object is non uniform eg. (1,2,1)\r\n     */\r\n    public get nonUniformScaling(): boolean {\r\n        return this._nonUniformScaling;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateNonUniformScalingState(value: boolean): boolean {\r\n        if (this._nonUniformScaling === value) {\r\n            return false;\r\n        }\r\n\r\n        this._nonUniformScaling = value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Attach the current TransformNode to another TransformNode associated with a bone\r\n     * @param bone Bone affecting the TransformNode\r\n     * @param affectedTransformNode TransformNode associated with the bone\r\n     * @returns this object\r\n     */\r\n    public attachToBone(bone: Bone, affectedTransformNode: TransformNode): TransformNode {\r\n        this._currentParentWhenAttachingToBone = this.parent;\r\n        this._transformToBoneReferal = affectedTransformNode;\r\n        this.parent = bone;\r\n\r\n        bone.getSkeleton().prepare(true); // make sure bone.getFinalMatrix() is up to date\r\n\r\n        if (bone.getFinalMatrix().determinant() < 0) {\r\n            this.scalingDeterminant *= -1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Detach the transform node if its associated with a bone\r\n     * @param resetToPreviousParent Indicates if the parent that was in effect when attachToBone was called should be set back or if we should set parent to null instead (defaults to the latter)\r\n     * @returns this object\r\n     */\r\n    public detachFromBone(resetToPreviousParent = false): TransformNode {\r\n        if (!this.parent) {\r\n            if (resetToPreviousParent) {\r\n                this.parent = this._currentParentWhenAttachingToBone;\r\n            }\r\n            return this;\r\n        }\r\n\r\n        if (this.parent.getWorldMatrix().determinant() < 0) {\r\n            this.scalingDeterminant *= -1;\r\n        }\r\n        this._transformToBoneReferal = null;\r\n        if (resetToPreviousParent) {\r\n            this.parent = this._currentParentWhenAttachingToBone;\r\n        } else {\r\n            this.parent = null;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private static _RotationAxisCache = new Quaternion();\r\n    /**\r\n     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.\r\n     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\r\n     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\r\n     * The passed axis is also normalized.\r\n     * @param axis the axis to rotate around\r\n     * @param amount the amount to rotate in radians\r\n     * @param space Space to rotate in (Default: local)\r\n     * @returns the TransformNode.\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space?: Space): TransformNode {\r\n        axis.normalize();\r\n        if (!this.rotationQuaternion) {\r\n            this.rotationQuaternion = this.rotation.toQuaternion();\r\n            this.rotation.setAll(0);\r\n        }\r\n        let rotationQuaternion: Quaternion;\r\n        if (!space || (space as any) === Space.LOCAL) {\r\n            rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\r\n            this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);\r\n        } else {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                const invertParentWorldMatrix = TmpVectors.Matrix[0];\r\n                parentWorldMatrix.invertToRef(invertParentWorldMatrix);\r\n                axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);\r\n\r\n                if (parentWorldMatrix.determinant() < 0) {\r\n                    amount *= -1;\r\n                }\r\n            }\r\n            rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\r\n            rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.\r\n     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\r\n     * The passed axis is also normalized. .\r\n     * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm\r\n     * @param point the point to rotate around\r\n     * @param axis the axis to rotate around\r\n     * @param amount the amount to rotate in radians\r\n     * @returns the TransformNode\r\n     */\r\n    public rotateAround(point: Vector3, axis: Vector3, amount: number): TransformNode {\r\n        axis.normalize();\r\n        if (!this.rotationQuaternion) {\r\n            this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\r\n            this.rotation.setAll(0);\r\n        }\r\n\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n        const finalScale = TmpVectors.Vector3[1];\r\n        const finalTranslation = TmpVectors.Vector3[2];\r\n\r\n        const finalRotation = TmpVectors.Quaternion[0];\r\n\r\n        const translationMatrix = TmpVectors.Matrix[0]; // T\r\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\r\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\r\n        const finalMatrix = TmpVectors.Matrix[3]; // T' x R x T\r\n\r\n        point.subtractToRef(this.position, tmpVector);\r\n        Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix); // T\r\n        Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv); // T'\r\n        Matrix.RotationAxisToRef(axis, amount, rotationMatrix); // R\r\n\r\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\r\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x T\r\n\r\n        finalMatrix.decompose(finalScale, finalRotation, finalTranslation);\r\n\r\n        this.position.addInPlace(finalTranslation);\r\n        finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Translates the mesh along the axis vector for the passed distance in the given space.\r\n     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\r\n     * @param axis the axis to translate in\r\n     * @param distance the distance to translate\r\n     * @param space Space to rotate in (Default: local)\r\n     * @returns the TransformNode.\r\n     */\r\n    public translate(axis: Vector3, distance: number, space?: Space): TransformNode {\r\n        const displacementVector = axis.scale(distance);\r\n        if (!space || (space as any) === Space.LOCAL) {\r\n            const tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);\r\n            this.setPositionWithLocalVector(tempV3);\r\n        } else {\r\n            this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a rotation step to the mesh current rotation.\r\n     * x, y, z are Euler angles expressed in radians.\r\n     * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.\r\n     * This means this rotation is made in the mesh local space only.\r\n     * It's useful to set a custom rotation order different from the BJS standard one YXZ.\r\n     * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.\r\n     * ```javascript\r\n     * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);\r\n     * ```\r\n     * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.\r\n     * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.\r\n     * @param x Rotation to add\r\n     * @param y Rotation to add\r\n     * @param z Rotation to add\r\n     * @returns the TransformNode.\r\n     */\r\n    public addRotation(x: number, y: number, z: number): TransformNode {\r\n        let rotationQuaternion;\r\n        if (this.rotationQuaternion) {\r\n            rotationQuaternion = this.rotationQuaternion;\r\n        } else {\r\n            rotationQuaternion = TmpVectors.Quaternion[1];\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);\r\n        }\r\n        const accumulation = TmpVectors.Quaternion[0];\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);\r\n        rotationQuaternion.multiplyInPlace(accumulation);\r\n        if (!this.rotationQuaternion) {\r\n            rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _getEffectiveParent(): Nullable<Node> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the transform node world matrix computation needs the camera information to be computed.\r\n     * This is the case when the node is a billboard or has an infinite distance for instance.\r\n     * @returns true if the world matrix computation needs the camera information to be computed\r\n     */\r\n    public isWorldMatrixCameraDependent(): boolean {\r\n        return (this._infiniteDistance && !this.parent) || (this._billboardMode !== TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard);\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @param camera defines the camera used if different from the scene active camera (This is used with modes like Billboard or infinite distance)\r\n     * @returns the world matrix\r\n     */\r\n    public override computeWorldMatrix(force: boolean = false, camera: Nullable<Camera> = null): Matrix {\r\n        if (this._isWorldMatrixFrozen && !this._isDirty) {\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        const currentRenderId = this.getScene().getRenderId();\r\n        if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {\r\n            this._currentRenderId = currentRenderId;\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        camera = camera || this.getScene().activeCamera;\r\n\r\n        this._updateCache();\r\n        const cache = this._cache;\r\n        cache.pivotMatrixUpdated = false;\r\n        cache.billboardMode = this.billboardMode;\r\n        cache.infiniteDistance = this.infiniteDistance;\r\n        cache.parent = this._parentNode;\r\n\r\n        this._currentRenderId = currentRenderId;\r\n        this._childUpdateId += 1;\r\n        this._isDirty = false;\r\n        this._position._isDirty = false;\r\n        this._rotation._isDirty = false;\r\n        this._scaling._isDirty = false;\r\n        const parent = this._getEffectiveParent();\r\n\r\n        // Scaling\r\n        const scaling: Vector3 = TransformNode._TmpScaling;\r\n        let translation: Vector3 = this._position;\r\n\r\n        // Translation\r\n        if (this._infiniteDistance) {\r\n            if (!this.parent && camera) {\r\n                const cameraWorldMatrix = camera.getWorldMatrix();\r\n                const cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);\r\n\r\n                translation = TransformNode._TmpTranslation;\r\n                translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);\r\n            }\r\n        }\r\n\r\n        // Scaling\r\n        scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);\r\n\r\n        // Rotation\r\n        let rotation: Quaternion;\r\n        if (this._rotationQuaternion) {\r\n            this._rotationQuaternion._isDirty = false;\r\n            rotation = this._rotationQuaternion;\r\n            if (this.reIntegrateRotationIntoRotationQuaternion) {\r\n                const len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));\r\n                    this._rotation.copyFromFloats(0, 0, 0);\r\n                }\r\n            }\r\n        } else {\r\n            rotation = TransformNode._TmpRotation;\r\n            Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);\r\n        }\r\n\r\n        // Compose\r\n        if (this._usePivotMatrix) {\r\n            const scaleMatrix = TmpVectors.Matrix[1];\r\n            Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);\r\n\r\n            // Rotation\r\n            const rotationMatrix = TmpVectors.Matrix[0];\r\n            rotation.toRotationMatrix(rotationMatrix);\r\n\r\n            // Composing transformations\r\n            this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\r\n            TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);\r\n\r\n            // Post multiply inverse of pivotMatrix\r\n            if (this._postMultiplyPivotMatrix) {\r\n                this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);\r\n            }\r\n\r\n            this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);\r\n        } else {\r\n            Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);\r\n        }\r\n\r\n        // Parent\r\n        if (parent && parent.getWorldMatrix) {\r\n            if (force) {\r\n                parent.computeWorldMatrix(force);\r\n            }\r\n            if (cache.useBillboardPath) {\r\n                if (this._transformToBoneReferal) {\r\n                    const bone = this.parent as Bone;\r\n                    bone.getSkeleton().prepare();\r\n                    bone.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);\r\n                } else {\r\n                    TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());\r\n                }\r\n\r\n                // Extract scaling and translation from parent\r\n                const translation = TmpVectors.Vector3[5];\r\n                const scale = TmpVectors.Vector3[6];\r\n                const orientation = TmpVectors.Quaternion[0];\r\n                TmpVectors.Matrix[7].decompose(scale, orientation, translation);\r\n                Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);\r\n                TmpVectors.Matrix[7].setTranslation(translation);\r\n\r\n                if (TransformNode.BillboardUseParentOrientation) {\r\n                    // set localMatrix translation to be transformed against parent's orientation.\r\n                    this._position.applyRotationQuaternionToRef(orientation, translation);\r\n                    this._localMatrix.setTranslation(translation);\r\n                }\r\n\r\n                this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);\r\n            } else {\r\n                if (this._transformToBoneReferal) {\r\n                    const bone = this.parent as Bone;\r\n                    bone.getSkeleton().prepare();\r\n                    this._localMatrix.multiplyToRef(bone.getFinalMatrix(), TmpVectors.Matrix[6]);\r\n                    TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);\r\n                } else {\r\n                    this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);\r\n                }\r\n            }\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._worldMatrix.copyFrom(this._localMatrix);\r\n        }\r\n\r\n        // Billboarding based on camera orientation (testing PG:http://www.babylonjs-playground.com/#UJEIL#13)\r\n        if (cache.useBillboardPath && camera && this.billboardMode && !cache.useBillboardPosition) {\r\n            const storedTranslation = TmpVectors.Vector3[0];\r\n            this._worldMatrix.getTranslationToRef(storedTranslation); // Save translation\r\n\r\n            // Cancel camera rotation\r\n            TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());\r\n\r\n            if (this._scene.useRightHandedSystem) {\r\n                TmpVectors.Matrix[1].multiplyToRef(convertRHSToLHS, TmpVectors.Matrix[1]);\r\n            }\r\n\r\n            TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);\r\n            TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);\r\n\r\n            if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\r\n                TmpVectors.Matrix[0].decompose(undefined, TmpVectors.Quaternion[0], undefined);\r\n                const eulerAngles = TmpVectors.Vector3[1];\r\n                TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\r\n                    eulerAngles.x = 0;\r\n                }\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\r\n                    eulerAngles.y = 0;\r\n                }\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\r\n                    eulerAngles.z = 0;\r\n                }\r\n\r\n                Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\r\n            }\r\n            this._worldMatrix.setTranslationFromFloats(0, 0, 0);\r\n            this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);\r\n\r\n            // Restore translation\r\n            this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\r\n        }\r\n        // Billboarding based on camera position\r\n        else if (cache.useBillboardPath && camera && cache.useBillboardPosition) {\r\n            const storedTranslation = TmpVectors.Vector3[0];\r\n            // Save translation\r\n            this._worldMatrix.getTranslationToRef(storedTranslation);\r\n\r\n            // Compute camera position in local space\r\n            const cameraPosition = camera.globalPosition;\r\n            this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);\r\n            const camInObjSpace = TmpVectors.Vector3[1];\r\n            Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);\r\n            camInObjSpace.normalize();\r\n\r\n            // Find the lookAt info in local space\r\n            const yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;\r\n            const len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);\r\n            const pitch = -Math.atan2(camInObjSpace.y, len);\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);\r\n\r\n            if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\r\n                const eulerAngles = TmpVectors.Vector3[1];\r\n                TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\r\n                    eulerAngles.x = 0;\r\n                }\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\r\n                    eulerAngles.y = 0;\r\n                }\r\n\r\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\r\n                    eulerAngles.z = 0;\r\n                }\r\n\r\n                Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\r\n            } else {\r\n                Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);\r\n            }\r\n\r\n            // Cancel translation\r\n            this._worldMatrix.setTranslationFromFloats(0, 0, 0);\r\n\r\n            // Rotate according to lookat (diff from local to lookat)\r\n            this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);\r\n\r\n            // Restore translation\r\n            this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\r\n        }\r\n\r\n        // Normal matrix\r\n        if (!this.ignoreNonUniformScaling) {\r\n            if (this._scaling.isNonUniformWithinEpsilon(0.000001)) {\r\n                this._updateNonUniformScalingState(true);\r\n            } else if (parent && (<TransformNode>parent)._nonUniformScaling) {\r\n                this._updateNonUniformScalingState((<TransformNode>parent)._nonUniformScaling);\r\n            } else {\r\n                this._updateNonUniformScalingState(false);\r\n            }\r\n        } else {\r\n            this._updateNonUniformScalingState(false);\r\n        }\r\n\r\n        this._afterComputeWorldMatrix();\r\n\r\n        // Absolute position\r\n        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\r\n        this._isAbsoluteSynced = false;\r\n\r\n        // Callbacks\r\n        this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);\r\n\r\n        if (!this._poseMatrix) {\r\n            this._poseMatrix = Matrix.Invert(this._worldMatrix);\r\n        }\r\n\r\n        // Cache the determinant\r\n        this._worldMatrixDeterminantIsDirty = true;\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Resets this nodeTransform's local matrix to Matrix.Identity().\r\n     * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.\r\n     */\r\n    public resetLocalMatrix(independentOfChildren: boolean = true): void {\r\n        this.computeWorldMatrix();\r\n        if (independentOfChildren) {\r\n            const children = this.getChildren();\r\n            for (let i = 0; i < children.length; ++i) {\r\n                const child = children[i] as TransformNode;\r\n                if (child) {\r\n                    child.computeWorldMatrix();\r\n                    const bakedMatrix = TmpVectors.Matrix[0];\r\n                    child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);\r\n                    const tmpRotationQuaternion = TmpVectors.Quaternion[0];\r\n                    bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);\r\n                    if (child.rotationQuaternion) {\r\n                        child.rotationQuaternion.copyFrom(tmpRotationQuaternion);\r\n                    } else {\r\n                        tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.scaling.copyFromFloats(1, 1, 1);\r\n        this.position.copyFromFloats(0, 0, 0);\r\n        this.rotation.copyFromFloats(0, 0, 0);\r\n\r\n        //only if quaternion is already set\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = Quaternion.Identity();\r\n        }\r\n        this._worldMatrix = Matrix.Identity();\r\n    }\r\n\r\n    protected _afterComputeWorldMatrix(): void {}\r\n\r\n    /**\r\n     * If you'd like to be called back after the mesh position, rotation or scaling has been updated.\r\n     * @param func callback function to add\r\n     *\r\n     * @returns the TransformNode.\r\n     */\r\n    public registerAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode {\r\n        this.onAfterWorldMatrixUpdateObservable.add(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a registered callback function.\r\n     * @param func callback function to remove\r\n     * @returns the TransformNode.\r\n     */\r\n    public unregisterAfterWorldMatrixUpdate(func: (mesh: TransformNode) => void): TransformNode {\r\n        this.onAfterWorldMatrixUpdateObservable.removeCallback(func);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the current mesh in camera space\r\n     * @param camera defines the camera to use\r\n     * @returns a position\r\n     */\r\n    public getPositionInCameraSpace(camera: Nullable<Camera> = null): Vector3 {\r\n        if (!camera) {\r\n            camera = <Camera>this.getScene().activeCamera;\r\n        }\r\n\r\n        return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());\r\n    }\r\n\r\n    /**\r\n     * Returns the distance from the mesh to the active camera\r\n     * @param camera defines the camera to use\r\n     * @returns the distance\r\n     */\r\n    public getDistanceToCamera(camera: Nullable<Camera> = null): number {\r\n        if (!camera) {\r\n            camera = <Camera>this.getScene().activeCamera;\r\n        }\r\n        return this.getAbsolutePosition().subtract(camera.globalPosition).length();\r\n    }\r\n\r\n    /**\r\n     * Clone the current transform node\r\n     * @param name Name of the new clone\r\n     * @param newParent New parent for the clone\r\n     * @param doNotCloneChildren Do not clone children hierarchy\r\n     * @returns the new transform node\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<TransformNode> {\r\n        const result = SerializationHelper.Clone(() => new TransformNode(name, this.getScene()), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            const directDescendants = this.getDescendants(true);\r\n            for (let index = 0; index < directDescendants.length; index++) {\r\n                const child = directDescendants[index];\r\n\r\n                if ((<any>child).clone) {\r\n                    (<any>child).clone(name + \".\" + child.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the objects information.\r\n     * @param currentSerializationObject defines the object to serialize in\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(currentSerializationObject?: any): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        serializationObject.localMatrix = this.getPivotMatrix().asArray();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new TransformNode object parsed from the source provided.\r\n     * @param parsedTransformNode is the source.\r\n     * @param scene the scene the object belongs to\r\n     * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with\r\n     * @returns a new TransformNode object parsed from the source provided.\r\n     */\r\n    public static Parse(parsedTransformNode: any, scene: Scene, rootUrl: string): TransformNode {\r\n        const transformNode = SerializationHelper.Parse(() => new TransformNode(parsedTransformNode.name, scene), parsedTransformNode, scene, rootUrl);\r\n\r\n        if (parsedTransformNode.localMatrix) {\r\n            transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));\r\n        } else if (parsedTransformNode.pivotMatrix) {\r\n            transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));\r\n        }\r\n\r\n        transformNode.setEnabled(parsedTransformNode.isEnabled);\r\n\r\n        transformNode._waitingParsedUniqueId = parsedTransformNode.uniqueId;\r\n\r\n        // Parent\r\n        if (parsedTransformNode.parentId !== undefined) {\r\n            transformNode._waitingParentId = parsedTransformNode.parentId;\r\n        }\r\n\r\n        if (parsedTransformNode.parentInstanceIndex !== undefined) {\r\n            transformNode._waitingParentInstanceIndex = parsedTransformNode.parentInstanceIndex;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTransformNode.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTransformNode.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTransformNode.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    transformNode.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(transformNode, parsedTransformNode, scene);\r\n        }\r\n\r\n        if (parsedTransformNode.autoAnimate) {\r\n            scene.beginAnimation(\r\n                transformNode,\r\n                parsedTransformNode.autoAnimateFrom,\r\n                parsedTransformNode.autoAnimateTo,\r\n                parsedTransformNode.autoAnimateLoop,\r\n                parsedTransformNode.autoAnimateSpeed || 1.0\r\n            );\r\n        }\r\n\r\n        return transformNode;\r\n    }\r\n\r\n    /**\r\n     * Get all child-transformNodes of this node\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns an array of TransformNode\r\n     */\r\n    public getChildTransformNodes(directDescendantsOnly?: boolean, predicate?: (node: Node) => boolean): TransformNode[] {\r\n        const results: Array<TransformNode> = [];\r\n        this._getDescendants(results, directDescendantsOnly, (node: Node) => {\r\n            return (!predicate || predicate(node)) && node instanceof TransformNode;\r\n        });\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this transform node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeTransformNode(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.transformNodes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.transformNodes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAfterWorldMatrixUpdateObservable.clear();\r\n\r\n        if (doNotRecurse) {\r\n            const transformNodes = this.getChildTransformNodes(true);\r\n            for (const transformNode of transformNodes) {\r\n                transformNode.parent = null;\r\n                transformNode.computeWorldMatrix(true);\r\n            }\r\n        }\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n     * @returns the current mesh\r\n     */\r\n    public normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate?: Nullable<(node: AbstractMesh) => boolean>): TransformNode {\r\n        let storedRotation: Nullable<Vector3> = null;\r\n        let storedRotationQuaternion: Nullable<Quaternion> = null;\r\n\r\n        if (ignoreRotation) {\r\n            if (this.rotationQuaternion) {\r\n                storedRotationQuaternion = this.rotationQuaternion.clone();\r\n                this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else if (this.rotation) {\r\n                storedRotation = this.rotation.clone();\r\n                this.rotation.copyFromFloats(0, 0, 0);\r\n            }\r\n        }\r\n\r\n        const boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);\r\n        const sizeVec = boundingVectors.max.subtract(boundingVectors.min);\r\n        const maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);\r\n\r\n        if (maxDimension === 0) {\r\n            return this;\r\n        }\r\n\r\n        const scale = 1 / maxDimension;\r\n\r\n        this.scaling.scaleInPlace(scale);\r\n\r\n        if (ignoreRotation) {\r\n            if (this.rotationQuaternion && storedRotationQuaternion) {\r\n                this.rotationQuaternion.copyFrom(storedRotationQuaternion);\r\n            } else if (this.rotation && storedRotation) {\r\n                this.rotation.copyFrom(storedRotation);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _syncAbsoluteScalingAndRotation(): void {\r\n        if (!this._isAbsoluteSynced) {\r\n            this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);\r\n            this._isAbsoluteSynced = true;\r\n        }\r\n    }\r\n}\r\n", "import type { Collider } from \"./collider\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _MeshCollisionData {\r\n    public _checkCollisions = false;\r\n    public _collisionMask = -1;\r\n    public _collisionGroup = -1;\r\n    public _surroundingMeshes: Nullable<AbstractMesh[]> = null;\r\n    public _collider: Nullable<Collider> = null;\r\n    public _oldPositionForCollisions = new Vector3(0, 0, 0);\r\n    public _diffPositionForCollisions = new Vector3(0, 0, 0);\r\n    public _onCollideObserver: Nullable<Observer<AbstractMesh>>;\r\n    public _onCollisionPositionChangeObserver: Nullable<Observer<Vector3>>;\r\n    public _collisionResponse = true;\r\n}\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { ScenePerformancePriority } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport type { MorphTargetManager } from \"../Morph/morphTargetManager\";\r\nimport type { IBakedVertexAnimationManager } from \"../BakedVertexAnimation/bakedVertexAnimationManager\";\r\nimport type { IEdgesRenderer } from \"../Rendering/edgesRenderer\";\r\nimport type { SolidParticle } from \"../Particles/solidParticle\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { AbstractActionManager } from \"../Actions/abstractActionManager\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { _MeshCollisionData } from \"../Collisions/meshCollisionData\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { TrianglePickingPredicate } from \"../Culling/ray\";\r\nimport type { RenderingGroup } from \"../Rendering/renderingGroup\";\r\nimport type { IEdgesRendererOptions } from \"../Rendering/edgesRenderer\";\r\nimport type { MorphTarget } from \"../Morph/morphTarget\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\nfunction applyMorph(data: FloatArray, kind: string, morphTargetManager: MorphTargetManager): void {\r\n    let getTargetData: Nullable<(target: MorphTarget) => Nullable<FloatArray>> = null;\r\n    switch (kind) {\r\n        case VertexBuffer.PositionKind:\r\n            getTargetData = (target) => target.getPositions();\r\n            break;\r\n        case VertexBuffer.NormalKind:\r\n            getTargetData = (target) => target.getNormals();\r\n            break;\r\n        case VertexBuffer.TangentKind:\r\n            getTargetData = (target) => target.getTangents();\r\n            break;\r\n        case VertexBuffer.UVKind:\r\n            getTargetData = (target) => target.getUVs();\r\n            break;\r\n        case VertexBuffer.UV2Kind:\r\n            getTargetData = (target) => target.getUV2s();\r\n            break;\r\n        case VertexBuffer.ColorKind:\r\n            getTargetData = (target) => target.getColors();\r\n            break;\r\n        default:\r\n            return;\r\n    }\r\n\r\n    for (let index = 0; index < data.length; index++) {\r\n        let value = data[index];\r\n        for (let targetCount = 0; targetCount < morphTargetManager.numTargets; targetCount++) {\r\n            const target = morphTargetManager.getTarget(targetCount);\r\n            const influence = target.influence;\r\n            if (influence !== 0) {\r\n                const targetData = getTargetData(target);\r\n                if (targetData) {\r\n                    value += (targetData[index] - data[index]) * influence;\r\n                }\r\n            }\r\n        }\r\n        data[index] = value;\r\n    }\r\n}\r\n\r\nfunction applySkeleton(\r\n    data: FloatArray,\r\n    kind: string,\r\n    skeletonMatrices: Float32Array,\r\n    matricesIndicesData: FloatArray,\r\n    matricesWeightsData: FloatArray,\r\n    matricesIndicesExtraData: Nullable<FloatArray>,\r\n    matricesWeightsExtraData: Nullable<FloatArray>\r\n): void {\r\n    const tempVector = TmpVectors.Vector3[0];\r\n    const finalMatrix = TmpVectors.Matrix[0];\r\n    const tempMatrix = TmpVectors.Matrix[1];\r\n\r\n    const transformFromFloatsToRef = kind === VertexBuffer.NormalKind ? Vector3.TransformNormalFromFloatsToRef : Vector3.TransformCoordinatesFromFloatsToRef;\r\n\r\n    for (let index = 0, matWeightIdx = 0; index < data.length; index += 3, matWeightIdx += 4) {\r\n        finalMatrix.reset();\r\n\r\n        let inf: number;\r\n        let weight: number;\r\n        for (inf = 0; inf < 4; inf++) {\r\n            weight = matricesWeightsData[matWeightIdx + inf];\r\n            if (weight > 0) {\r\n                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                finalMatrix.addToSelf(tempMatrix);\r\n            }\r\n        }\r\n        if (matricesIndicesExtraData && matricesWeightsExtraData) {\r\n            for (inf = 0; inf < 4; inf++) {\r\n                weight = matricesWeightsExtraData[matWeightIdx + inf];\r\n                if (weight > 0) {\r\n                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                    finalMatrix.addToSelf(tempMatrix);\r\n                }\r\n            }\r\n        }\r\n\r\n        transformFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\r\n        tempVector.toArray(data, index);\r\n    }\r\n}\r\n\r\n/**\r\n * Opaque cache when computing data about a mesh\r\n */\r\nexport interface IMeshDataCache {\r\n    /** @internal */\r\n    _outputData?: Float32Array;\r\n\r\n    /** @internal */\r\n    _vertexData?: { [kind: string]: Float32Array };\r\n}\r\n\r\n/**\r\n * Options when computing data about a mesh\r\n */\r\nexport interface IMeshDataOptions {\r\n    /** Apply skeleton when computing the bounding info. Defaults to false. */\r\n    applySkeleton?: boolean;\r\n\r\n    /** Apply morph when computing the bounding info. Defaults to false. */\r\n    applyMorph?: boolean;\r\n\r\n    /** Update the cached positions stored as a Vector3 array. Defaults to true. */\r\n    updatePositionsArray?: boolean;\r\n\r\n    /**\r\n     * Cache to avoid redundant allocations and computations when computing the bounding info multiple times. Pass in\r\n     * an initial empty object and continue with subsequent calls using the same object. Caching is disabled by default.\r\n     */\r\n    cache?: IMeshDataCache;\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _FacetDataStorage {\r\n    // facetData private properties\r\n    public facetPositions: Vector3[]; // facet local positions\r\n    public facetNormals: Vector3[]; // facet local normals\r\n    public facetPartitioning: number[][]; // partitioning array of facet index arrays\r\n    public facetNb: number = 0; // facet number\r\n    public partitioningSubdivisions: number = 10; // number of subdivisions per axis in the partitioning space\r\n    public partitioningBBoxRatio: number = 1.01; // the partitioning array space is by default 1% bigger than the bounding box\r\n    public facetDataEnabled: boolean = false; // is the facet data feature enabled on this mesh ?\r\n    public facetParameters: any = {}; // keep a reference to the object parameters to avoid memory re-allocation\r\n    public bbSize: Vector3 = Vector3.Zero(); // bbox size approximated for facet data\r\n    public subDiv = {\r\n        // actual number of subdivisions per axis for ComputeNormals()\r\n        max: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        X: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        Y: 1,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        Z: 1,\r\n    };\r\n\r\n    public facetDepthSort: boolean = false; // is the facet depth sort to be computed\r\n    public facetDepthSortEnabled: boolean = false; // is the facet depth sort initialized\r\n    public depthSortedIndices: IndicesArray; // copy of the indices array to store them once sorted\r\n    public depthSortedFacets: { ind: number; sqDistance: number }[]; // array of depth sorted facets\r\n    public facetDepthSortFunction: (f1: { ind: number; sqDistance: number }, f2: { ind: number; sqDistance: number }) => number; // facet depth sort function\r\n    public facetDepthSortFrom: Vector3; // location where to depth sort from\r\n    public facetDepthSortOrigin: Vector3; // same as facetDepthSortFrom but expressed in the mesh local space\r\n\r\n    public invertedMatrix: Matrix; // Inverted world matrix.\r\n}\r\n\r\n/**\r\n * @internal\r\n **/\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _InternalAbstractMeshDataInfo {\r\n    public _hasVertexAlpha = false;\r\n    public _useVertexColors = true;\r\n    public _numBoneInfluencers = 4;\r\n    public _applyFog = true;\r\n    public _receiveShadows = false;\r\n    public _facetData = new _FacetDataStorage();\r\n    public _visibility = 1.0;\r\n    public _skeleton: Nullable<Skeleton> = null;\r\n    public _layerMask: number = 0x0fffffff;\r\n    public _computeBonesUsingShaders = true;\r\n    public _isActive = false;\r\n    public _onlyForInstances = false;\r\n    public _isActiveIntermediate = false;\r\n    public _onlyForInstancesIntermediate = false;\r\n    public _actAsRegularMesh = false;\r\n    public _currentLOD: Map<Camera, [Nullable<AbstractMesh>, number]> = new Map();\r\n    public _collisionRetryCount: number = 3;\r\n    public _morphTargetManager: Nullable<MorphTargetManager> = null;\r\n    public _renderingGroupId = 0;\r\n    public _bakedVertexAnimationManager: Nullable<IBakedVertexAnimationManager> = null;\r\n    public _material: Nullable<Material> = null;\r\n    public _materialForRenderPass: Array<Material | undefined>; // map a render pass id (index in the array) to a Material\r\n    public _positions: Nullable<Vector3[]> = null;\r\n    public _pointerOverDisableMeshTesting: boolean = false;\r\n    // Collisions\r\n    public _meshCollisionData = new _MeshCollisionData();\r\n    public _enableDistantPicking = false;\r\n    /** @internal\r\n     * Bounding info that is unnafected by the addition of thin instances\r\n     */\r\n    public _rawBoundingInfo: Nullable<BoundingInfo> = null;\r\n    /** @internal\r\n     * This value will indicate us that at some point, the mesh was specifically used with the opposite winding order\r\n     * We use that as a clue to force the material to sideOrientation = null\r\n     */\r\n    public _sideOrientationHint = false;\r\n\r\n    /**\r\n     * @internal\r\n     * if this is set to true, the mesh will be visible only if its parent(s) are also visible\r\n     */\r\n    public _inheritVisibility = false;\r\n}\r\n\r\n/**\r\n * Class used to store all common mesh properties\r\n */\r\nexport abstract class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {\r\n    /** No occlusion */\r\n    public static OCCLUSION_TYPE_NONE = 0;\r\n    /** Occlusion set to optimistic */\r\n    public static OCCLUSION_TYPE_OPTIMISTIC = 1;\r\n    /** Occlusion set to strict */\r\n    public static OCCLUSION_TYPE_STRICT = 2;\r\n    /** Use an accurate occlusion algorithm */\r\n    public static OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\r\n    /** Use a conservative occlusion algorithm */\r\n    public static OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\r\n\r\n    /** Default culling strategy : this is an exclusion test and it's the more accurate.\r\n     *  Test order :\r\n     *  Is the bounding sphere outside the frustum ?\r\n     *  If not, are the bounding box vertices outside the frustum ?\r\n     *  It not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_STANDARD = Constants.MESHES_CULLINGSTRATEGY_STANDARD;\r\n    /** Culling strategy : Bounding Sphere Only.\r\n     *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\r\n     *  It's also less accurate than the standard because some not visible objects can still be selected.\r\n     *  Test : is the bounding sphere outside the frustum ?\r\n     *  If not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n    /** Culling strategy : Optimistic Inclusion.\r\n     *  This in an inclusion test first, then the standard exclusion test.\r\n     *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\r\n     *  Anyway, it's as accurate as the standard strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the default culling strategy.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION;\r\n    /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\r\n     *  This in an inclusion test first, then the bounding sphere only exclusion test.\r\n     *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\r\n     *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n\r\n    /**\r\n     * No billboard\r\n     */\r\n    public static override get BILLBOARDMODE_NONE(): number {\r\n        return TransformNode.BILLBOARDMODE_NONE;\r\n    }\r\n\r\n    /** Billboard on X axis */\r\n    public static override get BILLBOARDMODE_X(): number {\r\n        return TransformNode.BILLBOARDMODE_X;\r\n    }\r\n\r\n    /** Billboard on Y axis */\r\n    public static override get BILLBOARDMODE_Y(): number {\r\n        return TransformNode.BILLBOARDMODE_Y;\r\n    }\r\n\r\n    /** Billboard on Z axis */\r\n    public static override get BILLBOARDMODE_Z(): number {\r\n        return TransformNode.BILLBOARDMODE_Z;\r\n    }\r\n\r\n    /** Billboard on all axes */\r\n    public static override get BILLBOARDMODE_ALL(): number {\r\n        return TransformNode.BILLBOARDMODE_ALL;\r\n    }\r\n\r\n    /** Billboard on using position instead of orientation */\r\n    public static override get BILLBOARDMODE_USE_POSITION(): number {\r\n        return TransformNode.BILLBOARDMODE_USE_POSITION;\r\n    }\r\n\r\n    // Internal data\r\n    /** @internal */\r\n    public _internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\r\n\r\n    /** @internal */\r\n    public _waitingMaterialId: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    public _waitingMorphTargetManagerId: Nullable<number> = null;\r\n\r\n    /**\r\n     * The culling strategy to use to check whether the mesh must be rendered or not.\r\n     * This value can be changed at any time and will be used on the next render mesh selection.\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * Please read each static variable documentation to get details about the culling process.\r\n     * */\r\n    public cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n\r\n    /**\r\n     * Gets the number of facets in the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet\r\n     */\r\n    public get facetNb(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetNb;\r\n    }\r\n    /**\r\n     * Gets or set the number (integer) of subdivisions per axis in the partitioning space\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning\r\n     */\r\n    public get partitioningSubdivisions(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\r\n    }\r\n    public set partitioningSubdivisions(nb: number) {\r\n        this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\r\n    }\r\n    /**\r\n     * The ratio (float) to apply to the bounding box size to set to the partitioning space.\r\n     * Ex : 1.01 (default) the partitioning space is 1% bigger than the bounding box\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning\r\n     */\r\n    public get partitioningBBoxRatio(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\r\n    }\r\n    public set partitioningBBoxRatio(ratio: number) {\r\n        this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\r\n     * Works only for updatable meshes.\r\n     * Doesn't work with multi-materials\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort\r\n     */\r\n    public get mustDepthSortFacets(): boolean {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\r\n    }\r\n    public set mustDepthSortFacets(sort: boolean) {\r\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\r\n    }\r\n\r\n    /**\r\n     * The location (Vector3) where the facet depth sort must be computed from.\r\n     * By default, the active camera position.\r\n     * Used only when facet depth sort is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort\r\n     */\r\n    public get facetDepthSortFrom(): Vector3 {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\r\n    }\r\n    public set facetDepthSortFrom(location: Vector3) {\r\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\r\n    }\r\n\r\n    /** number of collision detection tries. Change this value if not all collisions are detected and handled properly */\r\n    public get collisionRetryCount(): number {\r\n        return this._internalAbstractMeshDataInfo._collisionRetryCount;\r\n    }\r\n    public set collisionRetryCount(retryCount: number) {\r\n        this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;\r\n    }\r\n    /**\r\n     * gets a boolean indicating if facetData is enabled\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet\r\n     */\r\n    public get isFacetDataEnabled(): boolean {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the morph target manager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n     */\r\n    public get morphTargetManager(): Nullable<MorphTargetManager> {\r\n        return this._internalAbstractMeshDataInfo._morphTargetManager;\r\n    }\r\n\r\n    public set morphTargetManager(value: Nullable<MorphTargetManager>) {\r\n        if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {\r\n            return;\r\n        }\r\n        this._internalAbstractMeshDataInfo._morphTargetManager = value;\r\n        this._syncGeometryWithMorphTargetManager();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the baked vertex animation manager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/baked_texture_animations\r\n     */\r\n    public get bakedVertexAnimationManager(): Nullable<IBakedVertexAnimationManager> {\r\n        return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;\r\n    }\r\n\r\n    public set bakedVertexAnimationManager(value: Nullable<IBakedVertexAnimationManager>) {\r\n        if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {\r\n            return;\r\n        }\r\n        this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncGeometryWithMorphTargetManager(): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateNonUniformScalingState(value: boolean): boolean {\r\n        if (!super._updateNonUniformScalingState(value)) {\r\n            return false;\r\n        }\r\n        this._markSubMeshesAsMiscDirty();\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public get rawBoundingInfo(): Nullable<BoundingInfo> {\r\n        return this._internalAbstractMeshDataInfo._rawBoundingInfo;\r\n    }\r\n    public set rawBoundingInfo(boundingInfo: Nullable<BoundingInfo>) {\r\n        this._internalAbstractMeshDataInfo._rawBoundingInfo = boundingInfo;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An event triggered when this mesh collides with another one\r\n     */\r\n    public onCollideObservable = new Observable<AbstractMesh>();\r\n\r\n    /** Set a function to call when this mesh collides with another one */\r\n    public set onCollide(callback: (collidedMesh?: AbstractMesh) => void) {\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {\r\n            this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);\r\n        }\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the collision's position changes\r\n     */\r\n    public onCollisionPositionChangeObservable = new Observable<Vector3>();\r\n\r\n    /** Set a function to call when the collision's position changes */\r\n    public set onCollisionPositionChange(callback: () => void) {\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {\r\n            this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);\r\n        }\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when material is changed\r\n     */\r\n    public onMaterialChangedObservable = new Observable<AbstractMesh>();\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets or sets the orientation for POV movement & rotation\r\n     */\r\n    public definedFacingForward = true;\r\n\r\n    /** @internal */\r\n    public _occlusionQuery: Nullable<WebGLQuery | number> = null;\r\n\r\n    /** @internal */\r\n    public _renderingGroup: Nullable<RenderingGroup> = null;\r\n\r\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\r\n    public get visibility(): number {\r\n        return this._internalAbstractMeshDataInfo._visibility;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\r\n    public set visibility(value: number) {\r\n        if (this._internalAbstractMeshDataInfo._visibility === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._internalAbstractMeshDataInfo._visibility;\r\n\r\n        this._internalAbstractMeshDataInfo._visibility = value;\r\n\r\n        if ((oldValue === 1 && value !== 1) || (oldValue !== 1 && value === 1)) {\r\n            this._markSubMeshesAsDirty((defines) => {\r\n                defines.markAsMiscDirty();\r\n                defines.markAsPrePassDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Gets or sets the alpha index used to sort transparent meshes\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#alpha-index\r\n     */\r\n    public alphaIndex = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * If set to true, a mesh will only be visible only if its parent(s) are also visible (default is false)\r\n     */\r\n    public get inheritVisibility(): boolean {\r\n        return this._internalAbstractMeshDataInfo._inheritVisibility;\r\n    }\r\n\r\n    public set inheritVisibility(value: boolean) {\r\n        this._internalAbstractMeshDataInfo._inheritVisibility = value;\r\n    }\r\n\r\n    private _isVisible = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true\r\n     */\r\n    public get isVisible(): boolean {\r\n        if (!this._isVisible || !this.inheritVisibility || !this._parentNode) {\r\n            return this._isVisible;\r\n        }\r\n        if (this._isVisible) {\r\n            let parent: Nullable<Node> = this._parentNode;\r\n            while (parent) {\r\n                const parentVisible = (parent as AbstractMesh).isVisible;\r\n                if (typeof parentVisible !== \"undefined\") {\r\n                    return parentVisible;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n        }\r\n        return this._isVisible;\r\n    }\r\n\r\n    public set isVisible(value: boolean) {\r\n        this._isVisible = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    public isPickable = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be near picked (touched by the XR controller or hands). Default is false\r\n     */\r\n    public isNearPickable = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be grabbed. Default is false.\r\n     * Setting this to true, while using the XR near interaction feature, will trigger a pointer event when the mesh is grabbed.\r\n     * Grabbing means that the controller is using the squeeze or main trigger button to grab the mesh.\r\n     * This is different from nearPickable which only triggers the event when the mesh is touched by the controller\r\n     */\r\n    public isNearGrabbable = false;\r\n\r\n    /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\r\n    public showSubMeshesBoundingBox = false;\r\n\r\n    /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n     */\r\n    public isBlocker = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\r\n     */\r\n    public enablePointerMoveEvents = false;\r\n\r\n    /**\r\n     * Gets or sets the property which disables the test that is checking that the mesh under the pointer is the same than the previous time we tested for it (default: false).\r\n     * Set this property to true if you want thin instances picking to be reported accurately when moving over the mesh.\r\n     * Note that setting this property to true will incur some performance penalties when dealing with pointer events for this mesh so use it sparingly.\r\n     */\r\n    public get pointerOverDisableMeshTesting() {\r\n        return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting;\r\n    }\r\n\r\n    public set pointerOverDisableMeshTesting(disable: boolean) {\r\n        this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = disable;\r\n    }\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#rendering-groups\r\n     */\r\n    public get renderingGroupId() {\r\n        return this._internalAbstractMeshDataInfo._renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        this._internalAbstractMeshDataInfo._renderingGroupId = value;\r\n    }\r\n\r\n    /** Gets or sets current material */\r\n    public get material(): Nullable<Material> {\r\n        return this._internalAbstractMeshDataInfo._material;\r\n    }\r\n    public set material(value: Nullable<Material>) {\r\n        this._setMaterial(value);\r\n    }\r\n\r\n    /** @internal */\r\n    protected _setMaterial(value: Nullable<Material>) {\r\n        if (this._internalAbstractMeshDataInfo._material === value) {\r\n            return;\r\n        }\r\n\r\n        // remove from material mesh map id needed\r\n        if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\r\n            this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._material = value;\r\n\r\n        if (value && value.meshMap) {\r\n            value.meshMap[this.uniqueId] = this;\r\n        }\r\n\r\n        if (this.onMaterialChangedObservable.hasObservers()) {\r\n            this.onMaterialChangedObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        this.resetDrawCache(undefined, value == null);\r\n        this._unBindEffect();\r\n    }\r\n\r\n    /**\r\n     * Gets the material used to render the mesh in a specific render pass\r\n     * @param renderPassId render pass id\r\n     * @returns material used for the render pass. If no specific material is used for this render pass, undefined is returned (meaning mesh.material is used for this pass)\r\n     */\r\n    public getMaterialForRenderPass(renderPassId: number): Material | undefined {\r\n        return this._internalAbstractMeshDataInfo._materialForRenderPass?.[renderPassId];\r\n    }\r\n\r\n    /**\r\n     * Sets the material to be used to render the mesh in a specific render pass\r\n     * @param renderPassId render pass id\r\n     * @param material material to use for this render pass. If undefined is passed, no specific material will be used for this render pass but the regular material will be used instead (mesh.material)\r\n     */\r\n    public setMaterialForRenderPass(renderPassId: number, material?: Material): void {\r\n        this.resetDrawCache(renderPassId);\r\n        if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {\r\n            this._internalAbstractMeshDataInfo._materialForRenderPass = [];\r\n        }\r\n        const currentMaterial = this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId];\r\n        if (currentMaterial?.meshMap?.[this.uniqueId]) {\r\n            currentMaterial.meshMap[this.uniqueId] = undefined;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;\r\n        if (material && material.meshMap) {\r\n            material.meshMap[this.uniqueId] = this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can receive realtime shadows\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._internalAbstractMeshDataInfo._receiveShadows;\r\n    }\r\n    public set receiveShadows(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._receiveShadows = value;\r\n        this._markSubMeshesAsLightDirty();\r\n    }\r\n\r\n    /** Defines color to use when rendering outline */\r\n    public outlineColor = Color3.Red();\r\n    /** Define width to use when rendering outline */\r\n    public outlineWidth = 0.02;\r\n\r\n    /** Defines color to use when rendering overlay */\r\n    public overlayColor = Color3.Red();\r\n    /** Defines alpha to use when rendering overlay */\r\n    public overlayAlpha = 0.5;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh needs to use vertex alpha data to render.\r\n     * This property is misnamed and should be `useVertexAlpha`. Note that the mesh will be rendered\r\n     * with alpha blending when this flag is set even if vertex alpha data is missing from the geometry.\r\n     */\r\n    public get hasVertexAlpha(): boolean {\r\n        return this._internalAbstractMeshDataInfo._hasVertexAlpha;\r\n    }\r\n    public set hasVertexAlpha(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\r\n    public get useVertexColors(): boolean {\r\n        return this._internalAbstractMeshDataInfo._useVertexColors;\r\n    }\r\n    public set useVertexColors(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._useVertexColors = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that bone animations must be computed by the GPU (true by default)\r\n     */\r\n    public get computeBonesUsingShaders(): boolean {\r\n        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\r\n    }\r\n    public set computeBonesUsingShaders(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\r\n    public get numBoneInfluencers(): number {\r\n        return this._internalAbstractMeshDataInfo._numBoneInfluencers;\r\n    }\r\n    public set numBoneInfluencers(value: number) {\r\n        if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\r\n    public get applyFog(): boolean {\r\n        return this._internalAbstractMeshDataInfo._applyFog;\r\n    }\r\n    public set applyFog(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._applyFog === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._applyFog = value;\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** When enabled, decompose picking matrices for better precision with large values for mesh position and scling */\r\n    public get enableDistantPicking(): boolean {\r\n        return this._internalAbstractMeshDataInfo._enableDistantPicking;\r\n    }\r\n    public set enableDistantPicking(value: boolean) {\r\n        this._internalAbstractMeshDataInfo._enableDistantPicking = value;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\r\n    public useOctreeForRenderingSelection = true;\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\r\n    public useOctreeForPicking = true;\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\r\n    public useOctreeForCollisions = true;\r\n    /**\r\n     * Gets or sets the current layer mask (default is 0x0FFFFFFF)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/layerMasksAndMultiCam\r\n     */\r\n    public get layerMask(): number {\r\n        return this._internalAbstractMeshDataInfo._layerMask;\r\n    }\r\n\r\n    public set layerMask(value: number) {\r\n        if (value === this._internalAbstractMeshDataInfo._layerMask) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._layerMask = value;\r\n        this._resyncLightSources();\r\n    }\r\n\r\n    /**\r\n     * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\r\n     */\r\n    public alwaysSelectAsActiveMesh = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\r\n     */\r\n    public doNotSyncBoundingInfo = false;\r\n\r\n    /**\r\n     * Gets or sets the current action manager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\r\n     */\r\n    public actionManager: Nullable<AbstractActionManager> = null;\r\n\r\n    /**\r\n     * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n    /**\r\n     * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets a collision mask used to mask collisions (default is -1).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a collision response flag (default is true).\r\n     * when collisionResponse is false, events are still triggered but colliding entity has no response\r\n     * This helps creating trigger volume when user wants collision feedback events but not position/velocity\r\n     * to respond to the collision.\r\n     */\r\n    public get collisionResponse(): boolean {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;\r\n    }\r\n\r\n    public set collisionResponse(response: boolean) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;\r\n    }\r\n    /**\r\n     * Gets or sets the current collision group mask (-1 by default).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\r\n    public get collisionGroup(): number {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;\r\n    }\r\n\r\n    public set collisionGroup(mask: number) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets current surrounding meshes (null by default).\r\n     *\r\n     * By default collision detection is tested against every mesh in the scene.\r\n     * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\r\n     * meshes will be tested for the collision.\r\n     *\r\n     * Note: if set to an empty array no collision will happen when this mesh is moved.\r\n     */\r\n    public get surroundingMeshes(): Nullable<AbstractMesh[]> {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;\r\n    }\r\n\r\n    public set surroundingMeshes(meshes: Nullable<AbstractMesh[]>) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;\r\n    }\r\n\r\n    // Edges\r\n    /**\r\n     * Defines edge width used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\r\n    public edgesWidth = 1;\r\n    /**\r\n     * Defines edge color used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\r\n    public edgesColor = new Color4(1, 0, 0, 1);\r\n    /** @internal */\r\n    public _edgesRenderer: Nullable<IEdgesRenderer> = null;\r\n\r\n    /** @internal */\r\n    public _masterMesh: Nullable<AbstractMesh> = null;\r\n    protected _boundingInfo: Nullable<BoundingInfo> = null;\r\n    protected _boundingInfoIsDirty = true;\r\n    /** @internal */\r\n    public _renderId = 0;\r\n\r\n    /**\r\n     * Gets or sets the list of subMeshes\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\r\n     */\r\n    public subMeshes: SubMesh[];\r\n\r\n    /** @internal */\r\n    public _intersectionsInProgress = new Array<AbstractMesh>();\r\n\r\n    /** @internal */\r\n    public _unIndexed = false;\r\n\r\n    /** @internal */\r\n    public _lightSources = new Array<Light>();\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._lightSources;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract get _positions(): Nullable<Vector3[]>;\r\n\r\n    // Loading properties\r\n    /** @internal */\r\n    public _waitingData: {\r\n        lods: Nullable<any>;\r\n        actions: Nullable<any>;\r\n        freezeWorldMatrix: Nullable<boolean>;\r\n    } = {\r\n        lods: null,\r\n        actions: null,\r\n        freezeWorldMatrix: null,\r\n    };\r\n\r\n    /** @internal */\r\n    public _bonesTransformMatrices: Nullable<Float32Array> = null;\r\n\r\n    /** @internal */\r\n    public _transformMatrixTexture: Nullable<RawTexture> = null;\r\n\r\n    /**\r\n     * Gets or sets a skeleton to apply skinning transformations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n     */\r\n    public set skeleton(value: Nullable<Skeleton>) {\r\n        const skeleton = this._internalAbstractMeshDataInfo._skeleton;\r\n        if (skeleton && skeleton.needInitialSkinMatrix) {\r\n            skeleton._unregisterMeshWithPoseMatrix(this);\r\n        }\r\n\r\n        if (value && value.needInitialSkinMatrix) {\r\n            value._registerMeshWithPoseMatrix(this);\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._skeleton = value;\r\n\r\n        if (!this._internalAbstractMeshDataInfo._skeleton) {\r\n            this._bonesTransformMatrices = null;\r\n        }\r\n\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._internalAbstractMeshDataInfo._skeleton;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the mesh is rebuilt.\r\n     */\r\n    public onRebuildObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * The current mesh uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    // Constructor\r\n\r\n    /**\r\n     * Creates a new AbstractMesh\r\n     * @param name defines the name of the mesh\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, scene: Nullable<Scene> = null) {\r\n        super(name, scene, false);\r\n\r\n        scene = this.getScene();\r\n\r\n        scene.addMesh(this);\r\n\r\n        this._resyncLightSources();\r\n\r\n        // Mesh Uniform Buffer.\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name, !this.getScene().getEngine().isWebGPU);\r\n        this._buildUniformLayout();\r\n\r\n        switch (scene.performancePriority) {\r\n            case ScenePerformancePriority.Aggressive:\r\n                this.doNotSyncBoundingInfo = true;\r\n            // eslint-disable-next-line no-fallthrough\r\n            case ScenePerformancePriority.Intermediate:\r\n                this.alwaysSelectAsActiveMesh = true;\r\n                this.isPickable = false;\r\n                break;\r\n        }\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"world\", 16);\r\n        this._uniformBuffer.addUniform(\"visibility\", 1);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Transfer the mesh values to its UBO.\r\n     * @param world The world matrix associated with the mesh\r\n     */\r\n    public transferToEffect(world: Matrix): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        ubo.updateMatrix(\"world\", world);\r\n        ubo.updateFloat(\"visibility\", this._internalAbstractMeshDataInfo._visibility);\r\n\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh uniform buffer.\r\n     * @returns the uniform buffer of the mesh.\r\n     */\r\n    public getMeshUniformBuffer(): UniformBuffer {\r\n        return this._uniformBuffer;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AbstractMesh\"\r\n     * @returns \"AbstractMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"AbstractMesh\";\r\n    }\r\n\r\n    /**\r\n     * Gets a string representation of the current mesh\r\n     * @param fullDetails defines a boolean indicating if full details must be included\r\n     * @returns a string representation of the current mesh\r\n     */\r\n    public override toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() !== \"InstancedMesh\" ? \"YES\" : \"NO\");\r\n        ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\r\n\r\n        const skeleton = this._internalAbstractMeshDataInfo._skeleton;\r\n        if (skeleton) {\r\n            ret += \", skeleton: \" + skeleton.name;\r\n        }\r\n        if (fullDetails) {\r\n            ret += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode];\r\n            ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected override _getEffectiveParent(): Nullable<Node> {\r\n        if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\r\n            return this._masterMesh;\r\n        }\r\n\r\n        return super._getEffectiveParent();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _getActionManagerForTrigger(trigger?: number, initialCall = true): Nullable<AbstractActionManager> {\r\n        if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\r\n            if (trigger) {\r\n                if (this.actionManager.hasSpecificTrigger(trigger)) {\r\n                    return this.actionManager;\r\n                }\r\n            } else {\r\n                return this.actionManager;\r\n            }\r\n        }\r\n\r\n        if (!this.parent) {\r\n            return null;\r\n        }\r\n\r\n        return this.parent._getActionManagerForTrigger(trigger, false);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _rebuild(dispose = false): void {\r\n        this.onRebuildObservable.notifyObservers(this);\r\n\r\n        if (this._occlusionQuery !== null) {\r\n            this._occlusionQuery = null;\r\n        }\r\n\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh._rebuild();\r\n        }\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /** @internal */\r\n    public _resyncLightSources(): void {\r\n        this._lightSources.length = 0;\r\n\r\n        for (const light of this.getScene().lights) {\r\n            if (!light.isEnabled()) {\r\n                continue;\r\n            }\r\n\r\n            if (light.canAffectMesh(this)) {\r\n                this._lightSources.push(light);\r\n            }\r\n        }\r\n\r\n        this._markSubMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _resyncLightSource(light: Light): void {\r\n        const isIn = light.isEnabled() && light.canAffectMesh(this);\r\n\r\n        const index = this._lightSources.indexOf(light);\r\n        let removed = false;\r\n        if (index === -1) {\r\n            if (!isIn) {\r\n                return;\r\n            }\r\n            this._lightSources.push(light);\r\n        } else {\r\n            if (isIn) {\r\n                return;\r\n            }\r\n            removed = true;\r\n            this._lightSources.splice(index, 1);\r\n        }\r\n\r\n        this._markSubMeshesAsLightDirty(removed);\r\n    }\r\n\r\n    /** @internal */\r\n    public _unBindEffect() {\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh.setEffect(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeLightSource(light: Light, dispose: boolean): void {\r\n        const index = this._lightSources.indexOf(light);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        this._lightSources.splice(index, 1);\r\n\r\n        this._markSubMeshesAsLightDirty(dispose);\r\n    }\r\n\r\n    private _markSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            for (let i = 0; i < subMesh._drawWrappers.length; ++i) {\r\n                const drawWrapper = subMesh._drawWrappers[i];\r\n                if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                    continue;\r\n                }\r\n                func(drawWrapper.defines as MaterialDefines);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _markSubMeshesAsLightDirty(dispose: boolean = false) {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));\r\n    }\r\n\r\n    /** @internal */\r\n    public _markSubMeshesAsAttributesDirty() {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());\r\n    }\r\n\r\n    /** @internal */\r\n    public _markSubMeshesAsMiscDirty() {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());\r\n    }\r\n\r\n    /**\r\n     * Flag the AbstractMesh as dirty (Forcing it to update everything)\r\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\r\n     * @returns this AbstractMesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override markAsDirty(property?: string): AbstractMesh {\r\n        this._currentRenderId = Number.MAX_VALUE;\r\n        super.markAsDirty(property);\r\n        this._isDirty = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes of this abstract mesh\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     * @param immediate If true, the effect will be released immediately, otherwise it will be released at the next frame\r\n     */\r\n    public resetDrawCache(passId?: number, immediate = false): void {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (const subMesh of this.subMeshes) {\r\n            subMesh.resetDrawCache(passId, immediate);\r\n        }\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Returns true if the mesh is blocked. Implemented by child classes\r\n     */\r\n    public get isBlocked(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh itself by default. Implemented by child classes\r\n     * @param camera defines the camera to use to pick the right LOD level\r\n     * @returns the currentAbstractMesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getLOD(camera: Camera): Nullable<AbstractMesh> {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns 0 by default. Implemented by child classes\r\n     * @returns an integer\r\n     */\r\n    public getTotalVertices(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns null by default. Implemented by child classes\r\n     * @returns null\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the array of the requested vertex data kind. Implemented by child classes\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns null\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getVerticesData(kind: string): Nullable<FloatArray> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Copies the requested vertex data kind into the given vertex data map. Float data is constructed if the map doesn't have the data.\r\n     * @param kind defines the vertex data kind to use\r\n     * @param vertexData defines the map that stores the resulting data\r\n     */\r\n    public abstract copyVerticesData(kind: string, vertexData: { [kind: string]: Float32Array }): void;\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * @param kind defines vertex data kind:\r\n     * * VertexBuffer.PositionKind\r\n     * * VertexBuffer.UVKind\r\n     * * VertexBuffer.UV2Kind\r\n     * * VertexBuffer.UV3Kind\r\n     * * VertexBuffer.UV4Kind\r\n     * * VertexBuffer.UV5Kind\r\n     * * VertexBuffer.UV6Kind\r\n     * * VertexBuffer.ColorKind\r\n     * * VertexBuffer.MatricesIndicesKind\r\n     * * VertexBuffer.MatricesIndicesExtraKind\r\n     * * VertexBuffer.MatricesWeightsKind\r\n     * * VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (or static)\r\n     * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * @param kind defines vertex data kind:\r\n     * * VertexBuffer.PositionKind\r\n     * * VertexBuffer.UVKind\r\n     * * VertexBuffer.UV2Kind\r\n     * * VertexBuffer.UV3Kind\r\n     * * VertexBuffer.UV4Kind\r\n     * * VertexBuffer.UV5Kind\r\n     * * VertexBuffer.UV6Kind\r\n     * * VertexBuffer.ColorKind\r\n     * * VertexBuffer.MatricesIndicesKind\r\n     * * VertexBuffer.MatricesIndicesExtraKind\r\n     * * VertexBuffer.MatricesWeightsKind\r\n     * * VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\r\n     * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices,\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\r\n     * @param totalVertices Defines the total number of vertices\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number>): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\r\n     * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\r\n     * However, if the mesh contains thin instances, it will be expanded to include them. If you want the \"raw\" bounding data instead, then use `getRawBoundingInfo()`.\r\n     * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\r\n     * @returns a BoundingInfo\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this._masterMesh) {\r\n            return this._masterMesh.getBoundingInfo();\r\n        }\r\n\r\n        if (this._boundingInfoIsDirty) {\r\n            this._boundingInfoIsDirty = false;\r\n            // this._boundingInfo is being created if undefined\r\n            this._updateBoundingInfo();\r\n        }\r\n        // cannot be null.\r\n        return this._boundingInfo!;\r\n    }\r\n\r\n    /**\r\n     * Returns the bounding info unnafected by instance data.\r\n     * @returns the bounding info of the mesh unaffected by instance data.\r\n     */\r\n    public getRawBoundingInfo() {\r\n        return this.rawBoundingInfo ?? this.getBoundingInfo();\r\n    }\r\n\r\n    /**\r\n     * Overwrite the current bounding info\r\n     * @param boundingInfo defines the new bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): AbstractMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there is already a bounding info\r\n     */\r\n    public get hasBoundingInfo(): boolean {\r\n        return this._boundingInfo !== null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new bounding info for the mesh\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     * @returns the new bounding info\r\n     */\r\n    public buildBoundingInfo(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n     * @returns the current mesh\r\n     */\r\n    public override normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate?: Nullable<(node: AbstractMesh) => boolean>): AbstractMesh {\r\n        return <AbstractMesh>super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);\r\n    }\r\n\r\n    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\r\n    public get useBones(): boolean {\r\n        return <boolean>(\r\n            (this.skeleton &&\r\n                this.getScene().skeletonsEnabled &&\r\n                this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) &&\r\n                this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind))\r\n        );\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _preActivateForIntermediateRendering(renderId: number): void {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        this._renderId = renderId;\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @internal */\r\n    public _freeze() {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @internal */\r\n    public _unFreeze() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Gets the current world matrix\r\n     * @returns a Matrix\r\n     */\r\n    public override getWorldMatrix(): Matrix {\r\n        if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\r\n            return this._masterMesh.getWorldMatrix();\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _getWorldMatrixDeterminant(): number {\r\n        if (this._masterMesh) {\r\n            return this._masterMesh._getWorldMatrixDeterminant();\r\n        }\r\n\r\n        return super._getWorldMatrixDeterminant();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh is an instance or a regular mesh\r\n     */\r\n    public get isAnInstance(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has instances\r\n     */\r\n    public get hasInstances(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has thin instances\r\n     */\r\n    public get hasThinInstances(): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ================================== Point of View Movement =================================\r\n\r\n    /**\r\n     * Perform relative position change from the point of view of behind the front of the mesh.\r\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\r\n     * @param amountRight defines the distance on the right axis\r\n     * @param amountUp defines the distance on the up axis\r\n     * @param amountForward defines the distance on the forward axis\r\n     * @returns the current mesh\r\n     */\r\n    public movePOV(amountRight: number, amountUp: number, amountForward: number): AbstractMesh {\r\n        this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calculate relative position change from the point of view of behind the front of the mesh.\r\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\r\n     * @param amountRight defines the distance on the right axis\r\n     * @param amountUp defines the distance on the up axis\r\n     * @param amountForward defines the distance on the forward axis\r\n     * @returns the new displacement vector\r\n     */\r\n    public calcMovePOV(amountRight: number, amountUp: number, amountForward: number): Vector3 {\r\n        const rotMatrix = new Matrix();\r\n        const rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\r\n        rotQuaternion.toRotationMatrix(rotMatrix);\r\n\r\n        const translationDelta = Vector3.Zero();\r\n        const defForwardMult = this.definedFacingForward ? -1 : 1;\r\n        Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\r\n        return translationDelta;\r\n    }\r\n    // ================================== Point of View Rotation =================================\r\n    /**\r\n     * Perform relative rotation change from the point of view of behind the front of the mesh.\r\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\r\n     * @param flipBack defines the flip\r\n     * @param twirlClockwise defines the twirl\r\n     * @param tiltRight defines the tilt\r\n     * @returns the current mesh\r\n     */\r\n    public rotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): AbstractMesh {\r\n        this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calculate relative rotation change from the point of view of behind the front of the mesh.\r\n     * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.\r\n     * @param flipBack defines the flip\r\n     * @param twirlClockwise defines the twirl\r\n     * @param tiltRight defines the tilt\r\n     * @returns the new rotation vector\r\n     */\r\n    public calcRotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): Vector3 {\r\n        const defForwardMult = this.definedFacingForward ? 1 : -1;\r\n        return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param options defines a set of options for computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public abstract refreshBoundingInfo(options: IMeshDataOptions): AbstractMesh;\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeletonOrOptions defines whether to apply the skeleton before computing the bounding info or a set of options\r\n     * @param applyMorph defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public abstract refreshBoundingInfo(applySkeletonOrOptions: boolean | IMeshDataOptions, applyMorph: boolean): AbstractMesh;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _refreshBoundingInfo(data: Nullable<FloatArray>, bias: Nullable<Vector2>): void {\r\n        if (data) {\r\n            const extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\r\n            if (this._boundingInfo) {\r\n                this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n            } else {\r\n                this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n            }\r\n        }\r\n\r\n        if (this.subMeshes) {\r\n            for (let index = 0; index < this.subMeshes.length; index++) {\r\n                this.subMeshes[index].refreshBoundingInfo(data);\r\n            }\r\n        }\r\n\r\n        this._updateBoundingInfo();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _refreshBoundingInfoDirect(extend: { minimum: Vector3; maximum: Vector3 }): void {\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n\r\n        if (this.subMeshes) {\r\n            for (let index = 0; index < this.subMeshes.length; index++) {\r\n                this.subMeshes[index].refreshBoundingInfo(null);\r\n            }\r\n        }\r\n\r\n        this._updateBoundingInfo();\r\n    }\r\n\r\n    // This function is only here so we can apply the nativeOverride decorator.\r\n    @nativeOverride.filter(\r\n        (...[data, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData]: Parameters<typeof AbstractMesh._ApplySkeleton>) =>\r\n            !Array.isArray(data) &&\r\n            !Array.isArray(matricesIndicesData) &&\r\n            !Array.isArray(matricesWeightsData) &&\r\n            !Array.isArray(matricesIndicesExtraData) &&\r\n            !Array.isArray(matricesWeightsExtraData)\r\n    )\r\n    private static _ApplySkeleton(\r\n        data: FloatArray,\r\n        kind: string,\r\n        skeletonMatrices: Float32Array,\r\n        matricesIndicesData: FloatArray,\r\n        matricesWeightsData: FloatArray,\r\n        matricesIndicesExtraData: Nullable<FloatArray>,\r\n        matricesWeightsExtraData: Nullable<FloatArray>\r\n    ): void {\r\n        applySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getData(options: IMeshDataOptions, data: Nullable<FloatArray>, kind: string = VertexBuffer.PositionKind): Nullable<FloatArray> {\r\n        const cache = options.cache;\r\n\r\n        const getVertexData = (kind: string): Nullable<FloatArray> => {\r\n            if (cache) {\r\n                const vertexData = (cache._vertexData ||= {});\r\n                if (!vertexData[kind]) {\r\n                    this.copyVerticesData(kind, vertexData);\r\n                }\r\n                return vertexData[kind];\r\n            }\r\n\r\n            return this.getVerticesData(kind);\r\n        };\r\n\r\n        data ||= getVertexData(kind);\r\n        if (!data) {\r\n            return null;\r\n        }\r\n\r\n        if (cache) {\r\n            if (cache._outputData) {\r\n                cache._outputData.set(data);\r\n            } else {\r\n                cache._outputData = new Float32Array(data);\r\n            }\r\n\r\n            data = cache._outputData;\r\n        } else if ((options.applyMorph && this.morphTargetManager) || (options.applySkeleton && this.skeleton)) {\r\n            data = data.slice();\r\n        }\r\n\r\n        if (options.applyMorph && this.morphTargetManager) {\r\n            applyMorph(data, kind, this.morphTargetManager);\r\n        }\r\n\r\n        if (options.applySkeleton && this.skeleton) {\r\n            const matricesIndicesData = getVertexData(VertexBuffer.MatricesIndicesKind);\r\n            const matricesWeightsData = getVertexData(VertexBuffer.MatricesWeightsKind);\r\n            if (matricesWeightsData && matricesIndicesData) {\r\n                const needExtras = this.numBoneInfluencers > 4;\r\n                const matricesIndicesExtraData = needExtras ? getVertexData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n                const matricesWeightsExtraData = needExtras ? getVertexData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n                const skeletonMatrices = this.skeleton.getTransformMatrices(this);\r\n                AbstractMesh._ApplySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData);\r\n            }\r\n        }\r\n\r\n        if (options.updatePositionsArray !== false && kind === VertexBuffer.PositionKind) {\r\n            const positions = this._internalAbstractMeshDataInfo._positions || [];\r\n            const previousLength = positions.length;\r\n            positions.length = data.length / 3;\r\n            if (previousLength < positions.length) {\r\n                for (let positionIndex = previousLength; positionIndex < positions.length; positionIndex++) {\r\n                    positions[positionIndex] = new Vector3();\r\n                }\r\n            }\r\n\r\n            for (let positionIndex = 0, dataIndex = 0; positionIndex < positions.length; positionIndex++, dataIndex += 3) {\r\n                positions[positionIndex].copyFromFloats(data[dataIndex], data[dataIndex + 1], data[dataIndex + 2]);\r\n            }\r\n\r\n            this._internalAbstractMeshDataInfo._positions = positions;\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Get the normals vertex data and optionally apply skeleton and morphing.\r\n     * @param applySkeleton defines whether to apply the skeleton\r\n     * @param applyMorph  defines whether to apply the morph target\r\n     * @returns the normals data\r\n     */\r\n    public getNormalsData(applySkeleton = false, applyMorph = false): Nullable<FloatArray> {\r\n        return this._getData({ applySkeleton, applyMorph, updatePositionsArray: false }, null, VertexBuffer.NormalKind);\r\n    }\r\n\r\n    /**\r\n     * Get the position vertex data and optionally apply skeleton and morphing.\r\n     * @param applySkeleton defines whether to apply the skeleton\r\n     * @param applyMorph  defines whether to apply the morph target\r\n     * @param data defines the position data to apply the skeleton and morph to\r\n     * @returns the position data\r\n     */\r\n    public getPositionData(applySkeleton: boolean = false, applyMorph: boolean = false, data: Nullable<FloatArray> = null): Nullable<FloatArray> {\r\n        return this._getData({ applySkeleton, applyMorph, updatePositionsArray: false }, data, VertexBuffer.PositionKind);\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.update(this.worldMatrixFromCache);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateSubMeshesBoundingInfo(matrix: DeepImmutable<Matrix>): AbstractMesh {\r\n        if (!this.subMeshes) {\r\n            return this;\r\n        }\r\n        const count = this.subMeshes.length;\r\n        for (let subIndex = 0; subIndex < count; subIndex++) {\r\n            const subMesh = this.subMeshes[subIndex];\r\n            if (count > 1 || !subMesh.IsGlobal) {\r\n                subMesh.updateBoundingInfo(matrix);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _afterComputeWorldMatrix(): void {\r\n        if (this.doNotSyncBoundingInfo) {\r\n            return;\r\n        }\r\n        // Bounding info\r\n        this._boundingInfoIsDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\r\n     * A mesh is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\r\n     * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is completely in the frustum planes\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * True if the mesh intersects another mesh or a SolidParticle object\r\n     * @param mesh defines a target mesh or SolidParticle to test\r\n     * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\r\n     * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMesh(mesh: AbstractMesh | SolidParticle, precise: boolean = false, includeDescendants?: boolean): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n        const otherBoundingInfo = mesh.getBoundingInfo();\r\n\r\n        if (boundingInfo.intersects(otherBoundingInfo, precise)) {\r\n            return true;\r\n        }\r\n\r\n        if (includeDescendants) {\r\n            for (const child of this.getChildMeshes()) {\r\n                if (child.intersectsMesh(mesh, precise, true)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the passed point (Vector3) is inside the mesh bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsPoint(point: Vector3): boolean {\r\n        return this.getBoundingInfo().intersectsPoint(point);\r\n    }\r\n\r\n    // Collisions\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can be used in the collision engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;\r\n    }\r\n\r\n    public set checkCollisions(collisionEnabled: boolean) {\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;\r\n    }\r\n\r\n    /**\r\n     * Gets Collider object used to compute collisions (not physics)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     */\r\n    public get collider(): Nullable<Collider> {\r\n        return this._internalAbstractMeshDataInfo._meshCollisionData._collider;\r\n    }\r\n\r\n    /**\r\n     * Move the mesh using collision engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\r\n     * @param displacement defines the requested displacement vector\r\n     * @returns the current mesh\r\n     */\r\n    public moveWithCollisions(displacement: Vector3): AbstractMesh {\r\n        const globalPosition = this.getAbsolutePosition();\r\n\r\n        globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n\r\n        if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;\r\n\r\n        coordinator.getNewPosition(\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,\r\n            displacement,\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._collider,\r\n            this.collisionRetryCount,\r\n            this,\r\n            this._onCollisionPositionChange,\r\n            this.uniqueId\r\n        );\r\n        return this;\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        newPosition.subtractToRef(\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,\r\n            this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions\r\n        );\r\n\r\n        if (this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > AbstractEngine.CollisionsEpsilon) {\r\n            this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\r\n        }\r\n\r\n        if (collidedMesh) {\r\n            this.onCollideObservable.notifyObservers(collidedMesh);\r\n        }\r\n\r\n        this.onCollisionPositionChangeObservable.notifyObservers(this.position);\r\n    };\r\n\r\n    // Collisions\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): AbstractMesh {\r\n        this._generatePointsArray();\r\n\r\n        if (!this._positions) {\r\n            return this;\r\n        }\r\n\r\n        // Transformation\r\n        if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix!.equals(transformMatrix)) {\r\n            subMesh._lastColliderTransformMatrix = transformMatrix.clone();\r\n            subMesh._lastColliderWorldVertices = [];\r\n            subMesh._trianglePlanes = [];\r\n            const start = subMesh.verticesStart;\r\n            const end = subMesh.verticesStart + subMesh.verticesCount;\r\n            for (let i = start; i < end; i++) {\r\n                subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\r\n            }\r\n        }\r\n\r\n        // Collide\r\n        collider._collide(\r\n            subMesh._trianglePlanes,\r\n            subMesh._lastColliderWorldVertices,\r\n            <IndicesArray>this.getIndices(),\r\n            subMesh.indexStart,\r\n            subMesh.indexStart + subMesh.indexCount,\r\n            subMesh.verticesStart,\r\n            !!subMesh.getMaterial(),\r\n            this,\r\n            this._shouldConvertRHS(),\r\n            subMesh.getMaterial()?.fillMode === Constants.MATERIAL_TriangleStripDrawMode\r\n        );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _processCollisionsForSubMeshes(collider: Collider, transformMatrix: Matrix): AbstractMesh {\r\n        const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\r\n        const len = subMeshes.length;\r\n\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n\r\n            // Bounding test\r\n            if (len > 1 && !subMesh._checkCollision(collider)) {\r\n                continue;\r\n            }\r\n\r\n            this._collideForSubMesh(subMesh, transformMatrix, collider);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldConvertRHS() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): AbstractMesh {\r\n        // Bounding box test\r\n        if (!this.getBoundingInfo()._checkCollision(collider)) {\r\n            return this;\r\n        }\r\n\r\n        // Transformation matrix\r\n        const collisionsScalingMatrix = TmpVectors.Matrix[0];\r\n        const collisionsTransformMatrix = TmpVectors.Matrix[1];\r\n        Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\r\n        this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\r\n        this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\r\n        return this;\r\n    }\r\n\r\n    // Picking\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the passed Ray intersects with the mesh. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param ray defines the ray to use. It should be in the mesh's LOCAL coordinate space.\r\n     * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     */\r\n    public intersects(\r\n        ray: Ray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const pickingInfo = new PickingInfo();\r\n        const className = this.getClassName();\r\n        const intersectionThreshold = className === \"InstancedLinesMesh\" || className === \"LinesMesh\" || className === \"GreasedLineMesh\" ? (this as any).intersectionThreshold : 0;\r\n        const boundingInfo = this.getBoundingInfo();\r\n        if (!this.subMeshes) {\r\n            return pickingInfo;\r\n        }\r\n        if (\r\n            !skipBoundingInfo &&\r\n            (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))\r\n        ) {\r\n            return pickingInfo;\r\n        }\r\n\r\n        if (onlyBoundingInfo) {\r\n            pickingInfo.hit = skipBoundingInfo ? false : true;\r\n            pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\r\n            pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\r\n            pickingInfo.subMeshId = 0;\r\n            return pickingInfo;\r\n        }\r\n\r\n        if (!this._generatePointsArray()) {\r\n            return pickingInfo;\r\n        }\r\n\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        const subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\r\n        const len: number = subMeshes.length;\r\n\r\n        // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\r\n        // if no submesh can be picked that way, then fallback to BBox picking\r\n        let anySubmeshSupportIntersect = false;\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n            const material = subMesh.getMaterial();\r\n            if (!material) {\r\n                continue;\r\n            }\r\n            if (\r\n                material.fillMode == Constants.MATERIAL_TriangleStripDrawMode ||\r\n                material.fillMode == Constants.MATERIAL_TriangleFillMode ||\r\n                material.fillMode == Constants.MATERIAL_WireFrameFillMode ||\r\n                material.fillMode == Constants.MATERIAL_PointFillMode ||\r\n                material.fillMode == Constants.MATERIAL_LineListDrawMode\r\n            ) {\r\n                anySubmeshSupportIntersect = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // no sub mesh support intersection, fallback to BBox that has already be done\r\n        if (!anySubmeshSupportIntersect) {\r\n            pickingInfo.hit = true;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\r\n            pickingInfo.subMeshId = -1;\r\n            return pickingInfo;\r\n        }\r\n\r\n        // at least 1 submesh supports intersection, keep going\r\n        for (let index = 0; index < len; index++) {\r\n            const subMesh = subMeshes.data[index];\r\n\r\n            // Bounding test\r\n            if (len > 1 && !skipBoundingInfo && !subMesh.canIntersects(ray)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = subMesh.intersects(ray, <Vector3[]>this._positions, <IndicesArray>this.getIndices(), fastCheck, trianglePredicate);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.subMeshId = index;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (intersectInfo) {\r\n            // Get picked point\r\n            const world = worldToUse ?? this.getWorldMatrix();\r\n            const worldOrigin = TmpVectors.Vector3[0];\r\n            const direction = TmpVectors.Vector3[1];\r\n            Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\r\n            ray.direction.scaleToRef(intersectInfo.distance, direction);\r\n            const worldDirection = Vector3.TransformNormal(direction, world);\r\n            const pickedPoint = worldDirection.addInPlace(worldOrigin);\r\n\r\n            // Return result\r\n            pickingInfo.hit = true;\r\n            pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\r\n            pickingInfo.pickedPoint = pickedPoint;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.bu = intersectInfo.bu || 0;\r\n            pickingInfo.bv = intersectInfo.bv || 0;\r\n            pickingInfo.subMeshFaceId = intersectInfo.faceId;\r\n            pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\r\n            pickingInfo.subMeshId = intersectInfo.subMeshId;\r\n            return pickingInfo;\r\n        }\r\n\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Clones the current mesh\r\n     * @param name defines the mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<AbstractMesh> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes all the submeshes of the current mesh\r\n     * @param immediate should dispose the effects immediately or not\r\n     * @returns the current mesh\r\n     */\r\n    public releaseSubMeshes(immediate = false): AbstractMesh {\r\n        if (this.subMeshes) {\r\n            while (this.subMeshes.length) {\r\n                this.subMeshes[0].dispose(immediate);\r\n            }\r\n        } else {\r\n            this.subMeshes = [] as SubMesh[];\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this abstract mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        let index: number;\r\n\r\n        const scene = this.getScene();\r\n\r\n        // mesh map release.\r\n        if (this._scene.useMaterialMeshMap) {\r\n            // remove from material mesh map id needed\r\n            if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\r\n                this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\r\n            }\r\n        }\r\n\r\n        // Smart Array Retainers.\r\n        scene.freeActiveMeshes();\r\n        scene.freeRenderingGroups();\r\n        if (scene.renderingManager.maintainStateBetweenFrames) {\r\n            scene.renderingManager.restoreDispachedFlags();\r\n        }\r\n\r\n        // Action manager\r\n        if (this.actionManager !== undefined && this.actionManager !== null) {\r\n            // If we are the only mesh using the action manager, dispose of the action manager too unless it has opted out from that behavior\r\n            if (this.actionManager.disposeWhenUnowned && !this._scene.meshes.some((m) => m !== this && m.actionManager === this.actionManager)) {\r\n                this.actionManager.dispose();\r\n            }\r\n            this.actionManager = null;\r\n        }\r\n\r\n        // Skeleton\r\n        this._internalAbstractMeshDataInfo._skeleton = null;\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n\r\n        // Intersections in progress\r\n        for (index = 0; index < this._intersectionsInProgress.length; index++) {\r\n            const other = this._intersectionsInProgress[index];\r\n\r\n            const pos = other._intersectionsInProgress.indexOf(this);\r\n            other._intersectionsInProgress.splice(pos, 1);\r\n        }\r\n\r\n        this._intersectionsInProgress.length = 0;\r\n\r\n        // Lights\r\n        const lights = scene.lights;\r\n\r\n        lights.forEach((light: Light) => {\r\n            let meshIndex = light.includedOnlyMeshes.indexOf(this);\r\n\r\n            if (meshIndex !== -1) {\r\n                light.includedOnlyMeshes.splice(meshIndex, 1);\r\n            }\r\n\r\n            meshIndex = light.excludedMeshes.indexOf(this);\r\n\r\n            if (meshIndex !== -1) {\r\n                light.excludedMeshes.splice(meshIndex, 1);\r\n            }\r\n\r\n            // Shadow generators\r\n            const generators = light.getShadowGenerators();\r\n            if (generators) {\r\n                const iterator = generators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const generator = key.value;\r\n                    const shadowMap = generator.getShadowMap();\r\n\r\n                    if (shadowMap && shadowMap.renderList) {\r\n                        meshIndex = shadowMap.renderList.indexOf(this);\r\n\r\n                        if (meshIndex !== -1) {\r\n                            shadowMap.renderList.splice(meshIndex, 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // SubMeshes\r\n        if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\r\n            this.releaseSubMeshes(true);\r\n        }\r\n\r\n        // Query\r\n        const engine = scene.getEngine();\r\n        if (this._occlusionQuery !== null) {\r\n            this.isOcclusionQueryInProgress = false;\r\n            engine.deleteQuery(this._occlusionQuery);\r\n            this._occlusionQuery = null;\r\n        }\r\n\r\n        // Engine\r\n        engine.wipeCaches();\r\n\r\n        // Remove from scene\r\n        scene.removeMesh(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.meshes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.meshes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (disposeMaterialAndTextures) {\r\n            if (this.material) {\r\n                if (this.material.getClassName() === \"MultiMaterial\") {\r\n                    this.material.dispose(false, true, true);\r\n                } else {\r\n                    this.material.dispose(false, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!doNotRecurse) {\r\n            // Particles\r\n            for (index = 0; index < scene.particleSystems.length; index++) {\r\n                if (scene.particleSystems[index].emitter === this) {\r\n                    scene.particleSystems[index].dispose();\r\n                    index--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // facet data\r\n        if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\r\n            this.disableFacetData();\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        this.onAfterWorldMatrixUpdateObservable.clear();\r\n        this.onCollideObservable.clear();\r\n        this.onCollisionPositionChangeObservable.clear();\r\n        this.onRebuildObservable.clear();\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    // Facet data\r\n    /** @internal */\r\n    private _initFacetData(): AbstractMesh {\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!data.facetNormals) {\r\n            data.facetNormals = [] as Vector3[];\r\n        }\r\n        if (!data.facetPositions) {\r\n            data.facetPositions = [] as Vector3[];\r\n        }\r\n        if (!data.facetPartitioning) {\r\n            data.facetPartitioning = new Array<number[]>();\r\n        }\r\n        data.facetNb = ((<IndicesArray>this.getIndices()).length / 3) | 0;\r\n        data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\r\n        data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\r\n        for (let f = 0; f < data.facetNb; f++) {\r\n            data.facetNormals[f] = Vector3.Zero();\r\n            data.facetPositions[f] = Vector3.Zero();\r\n        }\r\n        data.facetDataEnabled = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\r\n     * This method can be called within the render loop.\r\n     * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public updateFacetData(): AbstractMesh {\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!data.facetDataEnabled) {\r\n            this._initFacetData();\r\n        }\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const indices = this.getIndices();\r\n        const normals = this.getVerticesData(VertexBuffer.NormalKind);\r\n        const bInfo = this.getBoundingInfo();\r\n\r\n        if (data.facetDepthSort && !data.facetDepthSortEnabled) {\r\n            // init arrays, matrix and sort function on first call\r\n            data.facetDepthSortEnabled = true;\r\n            if (indices instanceof Uint16Array) {\r\n                data.depthSortedIndices = new Uint16Array(indices!);\r\n            } else if (indices instanceof Uint32Array) {\r\n                data.depthSortedIndices = new Uint32Array(indices!);\r\n            } else {\r\n                let needs32bits = false;\r\n                for (let i = 0; i < indices!.length; i++) {\r\n                    if (indices![i] > 65535) {\r\n                        needs32bits = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (needs32bits) {\r\n                    data.depthSortedIndices = new Uint32Array(indices!);\r\n                } else {\r\n                    data.depthSortedIndices = new Uint16Array(indices!);\r\n                }\r\n            }\r\n            data.facetDepthSortFunction = function (f1, f2) {\r\n                return f2.sqDistance - f1.sqDistance;\r\n            };\r\n            if (!data.facetDepthSortFrom) {\r\n                const camera = this.getScene().activeCamera;\r\n                data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();\r\n            }\r\n            data.depthSortedFacets = [];\r\n            for (let f = 0; f < data.facetNb; f++) {\r\n                const depthSortedFacet = { ind: f * 3, sqDistance: 0.0 };\r\n                data.depthSortedFacets.push(depthSortedFacet);\r\n            }\r\n            data.invertedMatrix = Matrix.Identity();\r\n            data.facetDepthSortOrigin = Vector3.Zero();\r\n        }\r\n\r\n        data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\r\n        data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\r\n        data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\r\n        let bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;\r\n        bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;\r\n        data.subDiv.max = data.partitioningSubdivisions;\r\n        data.subDiv.X = Math.floor((data.subDiv.max * data.bbSize.x) / bbSizeMax); // adjust the number of subdivisions per axis\r\n        data.subDiv.Y = Math.floor((data.subDiv.max * data.bbSize.y) / bbSizeMax); // according to each bbox size per axis\r\n        data.subDiv.Z = Math.floor((data.subDiv.max * data.bbSize.z) / bbSizeMax);\r\n        data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X; // at least one subdivision\r\n        data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\r\n        data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;\r\n        // set the parameters for ComputeNormals()\r\n        data.facetParameters.facetNormals = this.getFacetLocalNormals();\r\n        data.facetParameters.facetPositions = this.getFacetLocalPositions();\r\n        data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\r\n        data.facetParameters.bInfo = bInfo;\r\n        data.facetParameters.bbSize = data.bbSize;\r\n        data.facetParameters.subDiv = data.subDiv;\r\n        data.facetParameters.ratio = this.partitioningBBoxRatio;\r\n        data.facetParameters.depthSort = data.facetDepthSort;\r\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\r\n            this.computeWorldMatrix(true);\r\n            this._worldMatrix.invertToRef(data.invertedMatrix);\r\n            Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\r\n            data.facetParameters.distanceTo = data.facetDepthSortOrigin;\r\n        }\r\n        data.facetParameters.depthSortedFacets = data.depthSortedFacets;\r\n        if (normals) {\r\n            VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\r\n        }\r\n\r\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\r\n            data.depthSortedFacets.sort(data.facetDepthSortFunction);\r\n            const l = (data.depthSortedIndices.length / 3) | 0;\r\n            for (let f = 0; f < l; f++) {\r\n                const sind = data.depthSortedFacets[f].ind;\r\n                data.depthSortedIndices[f * 3] = indices![sind];\r\n                data.depthSortedIndices[f * 3 + 1] = indices![sind + 1];\r\n                data.depthSortedIndices[f * 3 + 2] = indices![sind + 2];\r\n            }\r\n            this.updateIndices(data.depthSortedIndices, undefined, true);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalNormals array.\r\n     * The normals are expressed in the mesh local spac\r\n     * @returns an array of Vector3\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetLocalNormals(): Vector3[] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!facetData.facetNormals) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetNormals;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalPositions array.\r\n     * The facet positions are expressed in the mesh local space\r\n     * @returns an array of Vector3\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetLocalPositions(): Vector3[] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!facetData.facetPositions) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetPositions;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalPartitioning array\r\n     * @returns an array of array of numbers\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetLocalPartitioning(): number[][] {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n\r\n        if (!facetData.facetPartitioning) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetPartitioning;\r\n    }\r\n\r\n    /**\r\n     * Returns the i-th facet position in the world system.\r\n     * This method allocates a new Vector3 per call\r\n     * @param i defines the facet index\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetPosition(i: number): Vector3 {\r\n        const pos = Vector3.Zero();\r\n        this.getFacetPositionToRef(i, pos);\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference Vector3 with the i-th facet position in the world system\r\n     * @param i defines the facet index\r\n     * @param ref defines the target vector\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetPositionToRef(i: number, ref: Vector3): AbstractMesh {\r\n        const localPos = this.getFacetLocalPositions()[i];\r\n        const world = this.getWorldMatrix();\r\n        Vector3.TransformCoordinatesToRef(localPos, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the i-th facet normal in the world system.\r\n     * This method allocates a new Vector3 per call\r\n     * @param i defines the facet index\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetNormal(i: number): Vector3 {\r\n        const norm = Vector3.Zero();\r\n        this.getFacetNormalToRef(i, norm);\r\n        return norm;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference Vector3 with the i-th facet normal in the world system\r\n     * @param i defines the facet index\r\n     * @param ref defines the target vector\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetNormalToRef(i: number, ref: Vector3) {\r\n        const localNorm = this.getFacetLocalNormals()[i];\r\n        Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @returns the array of facet indexes\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetsAtLocalCoordinates(x: number, y: number, z: number): Nullable<number[]> {\r\n        const bInfo = this.getBoundingInfo();\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n\r\n        const ox = Math.floor(((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio) / data.bbSize.x);\r\n        const oy = Math.floor(((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio) / data.bbSize.y);\r\n        const oz = Math.floor(((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio) / data.bbSize.z);\r\n        if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\r\n            return null;\r\n        }\r\n        return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\r\n    }\r\n\r\n    /**\r\n     * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @param projected sets as the (x,y,z) world projection on the facet\r\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n     * @returns the face index if found (or null instead)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getClosestFacetAtCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace: boolean = false, facing: boolean = true): Nullable<number> {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const invVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\r\n        const closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\r\n        if (projected) {\r\n            // transform the local computed projected vector to world coordinates\r\n            Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    /**\r\n     * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @param projected sets as the (x,y,z) local projection on the facet\r\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n     * @returns the face index if found (or null instead)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getClosestFacetAtLocalCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace: boolean = false, facing: boolean = true): Nullable<number> {\r\n        let closest = null;\r\n        let tmpx = 0.0;\r\n        let tmpy = 0.0;\r\n        let tmpz = 0.0;\r\n        let d = 0.0; // tmp dot facet normal * facet position\r\n        let t0 = 0.0;\r\n        let projx = 0.0;\r\n        let projy = 0.0;\r\n        let projz = 0.0;\r\n        // Get all the facets in the same partitioning block than (x, y, z)\r\n        const facetPositions = this.getFacetLocalPositions();\r\n        const facetNormals = this.getFacetLocalNormals();\r\n        const facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\r\n        if (!facetsInBlock) {\r\n            return null;\r\n        }\r\n        // Get the closest facet to (x, y, z)\r\n        let shortest = Number.MAX_VALUE; // init distance vars\r\n        let tmpDistance = shortest;\r\n        let fib; // current facet in the block\r\n        let norm; // current facet normal\r\n        let p0; // current facet barycenter position\r\n        // loop on all the facets in the current partitioning block\r\n        for (let idx = 0; idx < facetsInBlock.length; idx++) {\r\n            fib = facetsInBlock[idx];\r\n            norm = facetNormals[fib];\r\n            p0 = facetPositions[fib];\r\n\r\n            d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\r\n            if (!checkFace || (checkFace && facing && d >= 0.0) || (checkFace && !facing && d <= 0.0)) {\r\n                // compute (x,y,z) projection on the facet = (projx, projy, projz)\r\n                d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\r\n                t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\r\n                projx = x + norm.x * t0;\r\n                projy = y + norm.y * t0;\r\n                projz = z + norm.z * t0;\r\n\r\n                tmpx = projx - x;\r\n                tmpy = projy - y;\r\n                tmpz = projz - z;\r\n                tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\r\n                if (tmpDistance < shortest) {\r\n                    // just keep the closest facet to (x, y, z)\r\n                    shortest = tmpDistance;\r\n                    closest = fib;\r\n                    if (projected) {\r\n                        projected.x = projx;\r\n                        projected.y = projy;\r\n                        projected.z = projz;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    /**\r\n     * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\r\n     * @returns the parameters\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public getFacetDataParameters(): any {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetParameters;\r\n    }\r\n\r\n    /**\r\n     * Disables the feature FacetData and frees the related memory\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData\r\n     */\r\n    public disableFacetData(): AbstractMesh {\r\n        const facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (facetData.facetDataEnabled) {\r\n            facetData.facetDataEnabled = false;\r\n            facetData.facetPositions = [] as Vector3[];\r\n            facetData.facetNormals = [] as Vector3[];\r\n            facetData.facetPartitioning = new Array<number[]>();\r\n            facetData.facetParameters = {};\r\n            facetData.depthSortedIndices = new Uint32Array(0);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the AbstractMesh indices array\r\n     * @param indices defines the data source\r\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     * @returns the current mesh\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates new normals data for the mesh\r\n     * @param updatable defines if the normal vertex buffer must be flagged as updatable\r\n     * @returns the current mesh\r\n     */\r\n    public createNormals(updatable: boolean): AbstractMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        const indices = this.getIndices();\r\n        let normals: FloatArray;\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            normals = <FloatArray>this.getVerticesData(VertexBuffer.NormalKind);\r\n        } else {\r\n            normals = [];\r\n        }\r\n\r\n        VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });\r\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Optimize the indices order so that we keep the faces with similar indices together\r\n     * @returns the current mesh\r\n     */\r\n    public async optimizeIndicesAsync(): Promise<AbstractMesh> {\r\n        const indices = this.getIndices();\r\n\r\n        if (!indices) {\r\n            return this;\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        const { OptimizeIndices } = await import(\"./mesh.vertexData.functions\");\r\n\r\n        OptimizeIndices(indices);\r\n\r\n        this.setIndices(indices, this.getTotalVertices());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Align the mesh with a normal\r\n     * @param normal defines the normal to use\r\n     * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\r\n     * @returns the current mesh\r\n     */\r\n    public alignWithNormal(normal: Vector3, upDirection?: Vector3): AbstractMesh {\r\n        if (!upDirection) {\r\n            upDirection = Axis.Y;\r\n        }\r\n\r\n        const axisX = TmpVectors.Vector3[0];\r\n        const axisZ = TmpVectors.Vector3[1];\r\n        Vector3.CrossToRef(upDirection, normal, axisZ);\r\n        Vector3.CrossToRef(normal, axisZ, axisX);\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\r\n        } else {\r\n            Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkOcclusionQuery(): boolean {\r\n        // Will be replaced by correct code if Occlusion queries are referenced\r\n        return false;\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Disables the mesh edge rendering mode\r\n     * @returns the currentAbstractMesh\r\n     */\r\n    disableEdgesRendering(): AbstractMesh {\r\n        throw _WarnImport(\"EdgesRenderer\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Enables the edge rendering mode on the mesh.\r\n     * This mode makes the mesh edges visible\r\n     * @param epsilon defines the maximal distance between two angles to detect a face\r\n     * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\r\n     * @param options options to the edge renderer\r\n     * @returns the currentAbstractMesh\r\n     * @see https://www.babylonjs-playground.com/#19O9TU#0\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean, options?: IEdgesRendererOptions): AbstractMesh {\r\n        throw _WarnImport(\"EdgesRenderer\");\r\n    }\r\n\r\n    /**\r\n     * This function returns all of the particle systems in the scene that use the mesh as an emitter.\r\n     * @returns an array of particle systems in the scene that use the mesh as an emitter\r\n     */\r\n    public getConnectedParticleSystems(): IParticleSystem[] {\r\n        return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AbstractMesh\", AbstractMesh);\r\n", "import { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class that holds the different stencil states of a material\r\n * Usage example: https://playground.babylonjs.com/#CW5PRI#10\r\n */\r\nexport class MaterialStencilState implements IStencilState {\r\n    /**\r\n     * Creates a material stencil state instance\r\n     */\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Resets all the stencil states to default values\r\n     */\r\n    public reset() {\r\n        this.enabled = false;\r\n        this.mask = 0xff;\r\n\r\n        this.func = Constants.ALWAYS;\r\n        this.funcRef = 1;\r\n        this.funcMask = 0xff;\r\n\r\n        this.opStencilFail = Constants.KEEP;\r\n        this.opDepthFail = Constants.KEEP;\r\n        this.opStencilDepthPass = Constants.REPLACE;\r\n    }\r\n\r\n    private _func: number;\r\n    /**\r\n     * Gets or sets the stencil function\r\n     */\r\n    @serialize()\r\n    public get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public set func(value: number) {\r\n        this._func = value;\r\n    }\r\n\r\n    private _funcRef: number;\r\n    /**\r\n     * Gets or sets the stencil function reference\r\n     */\r\n    @serialize()\r\n    public get funcRef(): number {\r\n        return this._funcRef;\r\n    }\r\n\r\n    public set funcRef(value: number) {\r\n        this._funcRef = value;\r\n    }\r\n\r\n    private _funcMask: number;\r\n    /**\r\n     * Gets or sets the stencil function mask\r\n     */\r\n    @serialize()\r\n    public get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public set funcMask(value: number) {\r\n        this._funcMask = value;\r\n    }\r\n\r\n    private _opStencilFail: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil test fails\r\n     */\r\n    @serialize()\r\n    public get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public set opStencilFail(value: number) {\r\n        this._opStencilFail = value;\r\n    }\r\n\r\n    private _opDepthFail: number;\r\n    /**\r\n     * Gets or sets the operation when the depth test fails\r\n     */\r\n    @serialize()\r\n    public get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public set opDepthFail(value: number) {\r\n        this._opDepthFail = value;\r\n    }\r\n\r\n    private _opStencilDepthPass: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil+depth test succeeds\r\n     */\r\n    @serialize()\r\n    public get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public set opStencilDepthPass(value: number) {\r\n        this._opStencilDepthPass = value;\r\n    }\r\n\r\n    private _mask: number;\r\n    /**\r\n     * Gets or sets the stencil mask\r\n     */\r\n    @serialize()\r\n    public get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: number) {\r\n        this._mask = value;\r\n    }\r\n\r\n    private _enabled: boolean;\r\n    /**\r\n     * Enables or disables the stencil test\r\n     */\r\n    @serialize()\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enabled(value: boolean) {\r\n        this._enabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name, useful for serialization or dynamic coding.\r\n     * @returns \"MaterialStencilState\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialStencilState\";\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param stencilState defines stencil state where to copy the info\r\n     */\r\n    public copyTo(stencilState: MaterialStencilState): void {\r\n        SerializationHelper.Clone(() => stencilState, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this stencil configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a stencil state configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport type { ShadowDepthWrapper } from \"./shadowDepthWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { MaterialStencilState } from \"./materialStencilState\";\r\nimport { ScenePerformancePriority } from \"../scene\";\r\nimport type { Scene } from \"../scene\";\r\nimport type {\r\n    MaterialPluginDisposed,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginCreated,\r\n    MaterialPluginFillRenderTargetTextures,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginHardBindForSubMesh,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\n\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { BindSceneUniformBuffer } from \"./materialHelper.functions\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Options for compiling materials.\r\n */\r\nexport interface IMaterialCompilationOptions {\r\n    /**\r\n     * Defines whether clip planes are enabled.\r\n     */\r\n    clipPlane: boolean;\r\n\r\n    /**\r\n     * Defines whether instances are enabled.\r\n     */\r\n    useInstances: boolean;\r\n}\r\n\r\n/**\r\n * Options passed when calling customShaderNameResolve\r\n */\r\nexport interface ICustomShaderNameResolveOptions {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n}\r\n\r\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\r\nexport class Material implements IAnimatable, IClipPlanesHolder {\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly TriangleFillMode = Constants.MATERIAL_TriangleFillMode;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly WireFrameFillMode = Constants.MATERIAL_WireFrameFillMode;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly PointFillMode = Constants.MATERIAL_PointFillMode;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly PointListDrawMode = Constants.MATERIAL_PointListDrawMode;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly LineListDrawMode = Constants.MATERIAL_LineListDrawMode;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly LineLoopDrawMode = Constants.MATERIAL_LineLoopDrawMode;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly LineStripDrawMode = Constants.MATERIAL_LineStripDrawMode;\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly TriangleStripDrawMode = Constants.MATERIAL_TriangleStripDrawMode;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly TriangleFanDrawMode = Constants.MATERIAL_TriangleFanDrawMode;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly ClockWiseSideOrientation = Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly CounterClockWiseSideOrientation = Constants.MATERIAL_CounterClockWiseSideOrientation;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly TextureDirtyFlag = Constants.MATERIAL_TextureDirtyFlag;\r\n\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly LightDirtyFlag = Constants.MATERIAL_LightDirtyFlag;\r\n\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly FresnelDirtyFlag = Constants.MATERIAL_FresnelDirtyFlag;\r\n\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly AttributesDirtyFlag = Constants.MATERIAL_AttributesDirtyFlag;\r\n\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MiscDirtyFlag = Constants.MATERIAL_MiscDirtyFlag;\r\n\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly PrePassDirtyFlag = Constants.MATERIAL_PrePassDirtyFlag;\r\n\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly AllDirtyFlag = Constants.MATERIAL_AllDirtyFlag;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly MATERIAL_OPAQUE = 0;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly MATERIAL_ALPHATEST = 1;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly MATERIAL_ALPHABLEND = 2;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly MATERIAL_ALPHATESTANDBLEND = 3;\r\n\r\n    /**\r\n     * The Whiteout method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\r\n\r\n    /**\r\n     * The Reoriented Normal Mapping method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_RNM = 1;\r\n\r\n    /**\r\n     * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\r\n     */\r\n    public static OnEventObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * Custom callback helping to override the default shader used in the material.\r\n     */\r\n    public customShaderNameResolve: (\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ) => string;\r\n\r\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\r\n    public shadowDepthWrapper: Nullable<ShadowDepthWrapper> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\r\n    public allowShaderHotSwapping = true;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    protected _forceGLSL = false;\r\n\r\n    /** @internal */\r\n    public get _supportGlowLayer() {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _glowModeEnabled(value: boolean) {\r\n        // Do nothing here\r\n    }\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * The ID of the material\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the material\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n\r\n    /**\r\n     * The name of the material\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\r\n    @serialize()\r\n    public checkReadyOnEveryCall = false;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\r\n    @serialize()\r\n    public checkReadyOnlyOnce = false;\r\n\r\n    /**\r\n     * The state of the material\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\r\n    public get canRenderToMRT(): boolean {\r\n        // By default, shaders are not compatible with MRTs\r\n        // Base classes should override that if their shader supports MRT\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the material\r\n     */\r\n    @serialize(\"alpha\")\r\n    protected _alpha = 1.0;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Sets the alpha value of the material\r\n     */\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._alpha;\r\n        this._alpha = value;\r\n\r\n        // Only call dirty when there is a state change (no alpha / alpha)\r\n        if (oldValue === 1 || value === 1) {\r\n            this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha value of the material\r\n     */\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\r\n    @serialize(\"backFaceCulling\")\r\n    protected _backFaceCulling = true;\r\n\r\n    /**\r\n     * Sets the culling state (true to enable culling, false to disable)\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        if (this._backFaceCulling === value) {\r\n            return;\r\n        }\r\n        this._backFaceCulling = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the culling state\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back or front faces should be culled (when culling is enabled)\r\n     */\r\n    @serialize(\"cullBackFaces\")\r\n    protected _cullBackFaces = true;\r\n\r\n    /**\r\n     * Sets the type of faces that should be culled (true for back faces, false for front faces)\r\n     */\r\n    public set cullBackFaces(value: boolean) {\r\n        if (this._cullBackFaces === value) {\r\n            return;\r\n        }\r\n        this._cullBackFaces = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the type of faces that should be culled\r\n     */\r\n    public get cullBackFaces(): boolean {\r\n        return this._cullBackFaces;\r\n    }\r\n\r\n    private _blockDirtyMechanism = false;\r\n\r\n    /**\r\n     * Block the dirty-mechanism for this specific material\r\n     * When set to false after being true the material will be marked as dirty.\r\n     */\r\n    public get blockDirtyMechanism(): boolean {\r\n        return this._blockDirtyMechanism;\r\n    }\r\n\r\n    public set blockDirtyMechanism(value: boolean) {\r\n        if (this._blockDirtyMechanism === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockDirtyMechanism = value;\r\n\r\n        if (!value) {\r\n            this.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This allows you to modify the material without marking it as dirty after every change.\r\n     * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.\r\n     * The callback will pass the material as an argument, so you can make your changes to it.\r\n     * @param callback the callback to be executed that will update the material\r\n     */\r\n    public atomicMaterialsUpdate(callback: (material: this) => void): void {\r\n        this.blockDirtyMechanism = true;\r\n        try {\r\n            callback(this);\r\n        } finally {\r\n            this.blockDirtyMechanism = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the value for side orientation\r\n     */\r\n    @serialize()\r\n    public sideOrientation: Nullable<number> = null;\r\n\r\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\r\n    public getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>> = null;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        this._eventInfo.hasRenderTargetTextures = false;\r\n        this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n        return this._eventInfo.hasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _storeEffectOnSubMeshes = false;\r\n\r\n    /**\r\n     * Stores the animations for the material\r\n     */\r\n    public animations: Nullable<Array<Animation>> = null;\r\n\r\n    /**\r\n     * An event triggered when the material is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An observer which watches for dispose events\r\n     */\r\n    private _onDisposeObserver: Nullable<Observer<Material>> = null;\r\n    private _onUnBindObservable: Nullable<Observable<Material>> = null;\r\n\r\n    /**\r\n     * Called during a dispose event\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _onBindObservable: Nullable<Observable<AbstractMesh>>;\r\n\r\n    /**\r\n     * An event triggered when the material is bound\r\n     */\r\n    public get onBindObservable(): Observable<AbstractMesh> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<AbstractMesh>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An observer which watches for bind events\r\n     */\r\n    private _onBindObserver: Nullable<Observer<AbstractMesh>> = null;\r\n\r\n    /**\r\n     * Called during a bind event\r\n     */\r\n    public set onBind(callback: (Mesh: AbstractMesh) => void) {\r\n        if (this._onBindObserver) {\r\n            this.onBindObservable.remove(this._onBindObserver);\r\n        }\r\n        this._onBindObserver = this.onBindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the material is unbound\r\n     */\r\n    public get onUnBindObservable(): Observable<Material> {\r\n        if (!this._onUnBindObservable) {\r\n            this._onUnBindObservable = new Observable<Material>();\r\n        }\r\n\r\n        return this._onUnBindObservable;\r\n    }\r\n\r\n    protected _onEffectCreatedObservable: Nullable<Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n\r\n    /**\r\n     * An event triggered when the effect is (re)created\r\n     */\r\n    public get onEffectCreatedObservable(): Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }> {\r\n        if (!this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable = new Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>();\r\n        }\r\n\r\n        return this._onEffectCreatedObservable;\r\n    }\r\n\r\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\r\n    @serialize(\"alphaMode\")\r\n    private _alphaMode: number = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\r\n    public set alphaMode(value: number) {\r\n        if (this._alphaMode === value) {\r\n            return;\r\n        }\r\n        this._alphaMode = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\r\n    public get alphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\r\n    @serialize()\r\n    private _needDepthPrePass = false;\r\n\r\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\r\n    public set needDepthPrePass(value: boolean) {\r\n        if (this._needDepthPrePass === value) {\r\n            return;\r\n        }\r\n        this._needDepthPrePass = value;\r\n        if (this._needDepthPrePass) {\r\n            this.checkReadyOnEveryCall = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\r\n    public get needDepthPrePass(): boolean {\r\n        return this._needDepthPrePass;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableColorWrite = false;\r\n\r\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\r\n    @serialize()\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\r\n    @serialize()\r\n    public depthFunction = 0;\r\n\r\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\r\n    @serialize()\r\n    public separateCullingPass = false;\r\n\r\n    /**\r\n     * Stores the state specifying if fog should be enabled\r\n     */\r\n    @serialize(\"fogEnabled\")\r\n    private _fogEnabled = true;\r\n\r\n    /**\r\n     * Sets the state for enabling fog\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    /**\r\n     * Stores the size of points\r\n     */\r\n    @serialize()\r\n    public pointSize = 1.0;\r\n\r\n    /**\r\n     * Stores the z offset Factor value\r\n     */\r\n    @serialize()\r\n    public zOffset = 0;\r\n\r\n    /**\r\n     * Stores the z offset Units value\r\n     */\r\n    @serialize()\r\n    public zOffsetUnits = 0;\r\n\r\n    public get wireframe(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.WireFrameFillMode:\r\n            case Material.LineListDrawMode:\r\n            case Material.LineLoopDrawMode:\r\n            case Material.LineStripDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forceWireframe;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\r\n    public set wireframe(value: boolean) {\r\n        this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\r\n    @serialize()\r\n    public get pointsCloud(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.PointFillMode:\r\n            case Material.PointListDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\r\n    public set pointsCloud(value: boolean) {\r\n        this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the material fill mode\r\n     */\r\n    @serialize()\r\n    public get fillMode(): number {\r\n        return this._fillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the material fill mode\r\n     */\r\n    public set fillMode(value: number) {\r\n        if (this._fillMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._fillMode = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gives access to the stencil properties of the material\r\n     */\r\n    public readonly stencil = new MaterialStencilState();\r\n\r\n    protected _useLogarithmicDepth: boolean;\r\n\r\n    /**\r\n     * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n     * You can try switching to logarithmic depth.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer\r\n     */\r\n    @serialize()\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        const fragmentDepthSupported = this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n\r\n        if (value && !fragmentDepthSupported) {\r\n            Logger.Warn(\"Logarithmic depth has been requested for a material on a device that doesn't support it.\");\r\n        }\r\n\r\n        this._useLogarithmicDepth = value && fragmentDepthSupported;\r\n\r\n        this._markAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Stores the effects for the material\r\n     */\r\n    public _materialContext: IMaterialContext | undefined;\r\n\r\n    protected _drawWrapper: DrawWrapper;\r\n    /** @internal */\r\n    public _getDrawWrapper(): DrawWrapper {\r\n        return this._drawWrapper;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDrawWrapper(drawWrapper: DrawWrapper) {\r\n        this._drawWrapper = drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\r\n    private _useUBO: boolean = false;\r\n\r\n    /**\r\n     * Stores a reference to the scene\r\n     */\r\n    private _scene: Scene;\r\n    protected _needToBindSceneUbo: boolean;\r\n\r\n    /**\r\n     * Stores the fill mode state\r\n     */\r\n    private _fillMode = Material.TriangleFillMode;\r\n\r\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\r\n    private _cachedDepthWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\r\n    private _cachedColorWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\r\n    private _cachedDepthFunctionState: number = 0;\r\n\r\n    /**\r\n     * Stores the uniform buffer\r\n     * @internal\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _indexInSceneMaterialArray = -1;\r\n\r\n    /** @internal */\r\n    public meshMap: Nullable<{ [id: string]: AbstractMesh | undefined }> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /** @internal */\r\n    public _dirtyCallbacks: { [code: number]: () => void };\r\n\r\n    /** @internal */\r\n    public _uniformBufferLayoutBuilt = false;\r\n\r\n    protected _eventInfo: MaterialPluginCreated &\r\n        MaterialPluginDisposed &\r\n        MaterialPluginHasTexture &\r\n        MaterialPluginIsReadyForSubMesh &\r\n        MaterialPluginGetDefineNames &\r\n        MaterialPluginPrepareEffect &\r\n        MaterialPluginPrepareDefines &\r\n        MaterialPluginPrepareUniformBuffer &\r\n        MaterialPluginBindForSubMesh &\r\n        MaterialPluginGetAnimatables &\r\n        MaterialPluginGetActiveTextures &\r\n        MaterialPluginFillRenderTargetTextures &\r\n        MaterialPluginHasRenderTargetTextures &\r\n        MaterialPluginHardBindForSubMesh = {} as any; // will be initialized before each event notification\r\n\r\n    /** @internal */\r\n    public _callbackPluginEventGeneric: (\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventIsReadyForSubMesh: (eventData: MaterialPluginIsReadyForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefines: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefinesBeforeAttributes: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHardBindForSubMesh: (eventData: MaterialPluginHardBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventBindForSubMesh: (eventData: MaterialPluginBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHasRenderTargetTextures: (eventData: MaterialPluginHasRenderTargetTextures) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventFillRenderTargetTextures: (eventData: MaterialPluginFillRenderTargetTextures) => void = () => void 0;\r\n\r\n    /**\r\n     * Creates a material instance\r\n     * @param name defines the name of the material\r\n     * @param scene defines the scene to reference\r\n     * @param doNotAdd specifies if the material should be added to the scene\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(name: string, scene?: Nullable<Scene>, doNotAdd?: boolean, forceGLSL = false) {\r\n        this.name = name;\r\n        const setScene = scene || EngineStore.LastCreatedScene;\r\n        if (!setScene) {\r\n            return;\r\n        }\r\n        this._scene = setScene;\r\n        this._dirtyCallbacks = {};\r\n        this._forceGLSL = forceGLSL;\r\n\r\n        this._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag] = this._markAllSubMeshesAsTexturesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_LightDirtyFlag] = this._markAllSubMeshesAsLightsDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_FresnelDirtyFlag] = this._markAllSubMeshesAsFresnelDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AttributesDirtyFlag] = this._markAllSubMeshesAsAttributesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag] = this._markAllSubMeshesAsMiscDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag] = this._markAllSubMeshesAsPrePassDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag] = this._markAllSubMeshesAsAllDirty.bind(this);\r\n\r\n        this.id = name || Tools.RandomId();\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._materialContext = this._scene.getEngine().createMaterialContext();\r\n        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\r\n        this._drawWrapper.materialContext = this._materialContext;\r\n\r\n        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\r\n        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\r\n\r\n        this._createUniformBuffer();\r\n\r\n        if (!doNotAdd) {\r\n            this._scene.addMaterial(this);\r\n        }\r\n\r\n        if (this._scene.useMaterialMeshMap) {\r\n            this.meshMap = {};\r\n        }\r\n\r\n        Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\r\n    }\r\n\r\n    /** @internal */\r\n    public _createUniformBuffer() {\r\n        const engine = this.getScene().getEngine();\r\n\r\n        this._uniformBuffer?.dispose();\r\n\r\n        if (engine.isWebGPU && !this._forceGLSL) {\r\n            // Switch main UBO to non UBO to connect to leftovers UBO in webgpu\r\n            this._uniformBuffer = new UniformBuffer(engine, undefined, undefined, this.name, true);\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n        } else {\r\n            this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, this.name);\r\n        }\r\n\r\n        this._uniformBufferLayoutBuilt = false;\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the current material\r\n     * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n     * @returns a string with material information\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public toString(fullDetails?: boolean): string {\r\n        const ret = \"Name: \" + this.name;\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns a string with the class name of the material\r\n     */\r\n    public getClassName(): string {\r\n        return \"Material\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _isMaterial() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\r\n    public get isFrozen(): boolean {\r\n        return this.checkReadyOnlyOnce;\r\n    }\r\n\r\n    /**\r\n     * Locks updates for the material\r\n     */\r\n    public freeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = true;\r\n    }\r\n\r\n    /**\r\n     * Unlocks updates for the material\r\n     */\r\n    public unfreeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param useInstances specifies if instances should be used\r\n     * @returns a boolean indicating if the material is ready to be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const defines = subMesh.materialDefines;\r\n        if (!defines) {\r\n            return false;\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        return this._eventInfo.isReadyForSubMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the material effect\r\n     * @returns the effect associated with the material\r\n     */\r\n    public getEffect(): Nullable<Effect> {\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    /**\r\n     * Returns the current scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getEffectiveOrientation(mesh: Mesh): number {\r\n        return this.sideOrientation !== null ? this.sideOrientation : mesh.sideOrientation;\r\n    }\r\n\r\n    /**\r\n     * The transparency mode of the material.\r\n     */\r\n    protected _transparencyMode: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets the current transparency mode.\r\n     */\r\n    @serialize()\r\n    public get transparencyMode(): Nullable<number> {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\r\n    public set transparencyMode(value: Nullable<number>) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    protected get _hasTransparencyMode(): boolean {\r\n        return this._transparencyMode != null;\r\n    }\r\n\r\n    protected get _transparencyModeIsBlend(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_ALPHABLEND || this._transparencyMode === Material.MATERIAL_ALPHATESTANDBLEND;\r\n    }\r\n\r\n    protected get _transparencyModeIsTest(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_ALPHATEST || this._transparencyMode === Material.MATERIAL_ALPHATESTANDBLEND;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     * @deprecated Please use needAlphaBlendingForMesh instead\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the mesh will require alpha blending\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha blending is needed for the mesh\r\n     */\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (mesh.visibility < 1.0) {\r\n            return true;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return mesh.hasVertexAlpha || this.needAlphaBlending();\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     * @deprecated Please use needAlphaTestingForMesh instead\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if material alpha testing should be turned on for the mesh\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha testing should be turned on for the mesh\r\n     */\r\n    public needAlphaTestingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test\r\n     * @returns the texture to use for alpha testing\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.\r\n     */\r\n    public markDirty(forceMaterialDirty = false): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        drawWrapper._wasPreviouslyReady = false;\r\n                        drawWrapper._wasPreviouslyUsingInstances = null;\r\n                        drawWrapper._forceRebindOnNextCall = forceMaterialDirty;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (forceMaterialDirty) {\r\n            this.markAsDirty(Material.AllDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preBind(effect?: Effect | DrawWrapper, overrideOrientation: Nullable<number> = null): boolean {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\r\n        const reverse = orientation === Material.ClockWiseSideOrientation;\r\n\r\n        engine.enableEffect(effect ? effect : this._getDrawWrapper());\r\n        engine.setState(\r\n            this.backFaceCulling,\r\n            this.zOffset,\r\n            false,\r\n            reverse,\r\n            this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces,\r\n            this.stencil,\r\n            this.zOffsetUnits\r\n        );\r\n\r\n        return reverse;\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(world: Matrix, mesh?: Mesh): void {}\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        this._eventInfo.ubo = ubo;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\r\n\r\n        ubo.create();\r\n\r\n        this._uniformBufferLayoutBuilt = true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n        drawWrapper._forceRebindOnNextCall = false;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindOnlyWorldMatrix(world: Matrix): void {}\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     */\r\n    public bindView(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view projection and projection matrices to the effect\r\n     * @param effect defines the effect to bind the view projection and projection matrices to\r\n     */\r\n    public bindViewProjection(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n            effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public bindEyePosition(effect: Effect, variableName?: string): void {\r\n        if (!this._useUBO) {\r\n            this._scene.bindEyePosition(effect, variableName);\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes to execute after binding the material to a mesh\r\n     * @param mesh defines the rendered mesh\r\n     * @param effect defines the effect used to bind the material\r\n     * @param _subMesh defines the subMesh that the material has been bound for\r\n     */\r\n    protected _afterBind(mesh?: AbstractMesh, effect: Nullable<Effect> = null, _subMesh?: SubMesh): void {\r\n        this._scene._cachedMaterial = this;\r\n        if (this._needToBindSceneUbo) {\r\n            if (effect) {\r\n                this._needToBindSceneUbo = false;\r\n                BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        }\r\n        if (mesh) {\r\n            this._scene._cachedVisibility = mesh.visibility;\r\n        } else {\r\n            this._scene._cachedVisibility = 1;\r\n        }\r\n\r\n        if (this._onBindObservable && mesh) {\r\n            this._onBindObservable.notifyObservers(mesh);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthWriteState = engine.getDepthWrite();\r\n            engine.setDepthWrite(false);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedColorWriteState = engine.getColorWrite();\r\n            engine.setColorWrite(false);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\r\n            engine.setDepthFunction(this.depthFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        this._scene.getSceneUniformBuffer().unbindEffect();\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthFunction(this._cachedDepthFunctionState);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthWrite(this._cachedDepthWriteState);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setColorWrite(this._cachedColorWriteState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        this._eventInfo.animatables = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\r\n        return this._eventInfo.animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        this._eventInfo.activeTextures = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\r\n        return this._eventInfo.activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        this._eventInfo.hasTexture = false;\r\n        this._eventInfo.texture = texture;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\r\n        return this._eventInfo.hasTexture;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public clone(name: string): Nullable<Material> {\r\n        return null;\r\n    }\r\n\r\n    protected _clonePlugins(targetMaterial: Material, rootUrl: string) {\r\n        const serializationObject: any = {};\r\n\r\n        // Create plugins in targetMaterial in case they don't exist\r\n        this._serializePlugins(serializationObject);\r\n\r\n        Material._ParsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);\r\n\r\n        // Copy the properties of the current plugins to the cloned material's plugins\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                const targetPlugin = targetMaterial.pluginManager!.getPlugin(plugin.name);\r\n                if (targetPlugin) {\r\n                    plugin.copyTo(targetPlugin);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the meshes bound to the material\r\n     * @returns an array of meshes bound to the material\r\n     */\r\n    public getBindedMeshes(): AbstractMesh[] {\r\n        if (this.meshMap) {\r\n            const result: AbstractMesh[] = [];\r\n            for (const meshId in this.meshMap) {\r\n                const mesh = this.meshMap[meshId];\r\n                if (mesh) {\r\n                    result.push(mesh);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            const meshes = this._scene.meshes;\r\n            return meshes.filter((mesh) => mesh.material === this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh associated with this material\r\n     * @param onCompiled defines a function to execute once the material is compiled\r\n     * @param options defines the options to configure the compilation\r\n     * @param onError defines a function to execute if the material fails compiling\r\n     */\r\n    public forceCompilation(\r\n        mesh: AbstractMesh,\r\n        onCompiled?: (material: Material) => void,\r\n        options?: Partial<IMaterialCompilationOptions>,\r\n        onError?: (reason: string) => void\r\n    ): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        const currentHotSwapingState = this.allowShaderHotSwapping;\r\n        this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\r\n\r\n        const checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            const clipPlaneState = scene.clipPlane;\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = new Plane(0, 0, 0, 1);\r\n            }\r\n\r\n            if (this._storeEffectOnSubMeshes) {\r\n                let allDone = true,\r\n                    lastError = null;\r\n                if (mesh.subMeshes) {\r\n                    const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\r\n                    if (tempSubMesh.materialDefines) {\r\n                        tempSubMesh.materialDefines._renderId = -1;\r\n                    }\r\n                    if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\r\n                        if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\r\n                            lastError = tempSubMesh.effect.getCompilationError();\r\n                        } else {\r\n                            allDone = false;\r\n                            setTimeout(checkReady, 16);\r\n                        }\r\n                    }\r\n                }\r\n                if (allDone) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (lastError) {\r\n                        if (onError) {\r\n                            onError(lastError);\r\n                        }\r\n                    }\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isReady()) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                } else {\r\n                    setTimeout(checkReady, 16);\r\n                }\r\n            }\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = clipPlaneState;\r\n            }\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh that will use this material\r\n     * @param options defines additional options for compiling the shaders\r\n     * @returns a promise that resolves when the compilation completes\r\n     */\r\n    public forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.forceCompilation(\r\n                mesh,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                options,\r\n                (reason) => {\r\n                    reject(reason);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private static readonly _AllDirtyCallBack = (defines: MaterialDefines) => defines.markAllAsDirty();\r\n    private static readonly _ImageProcessingDirtyCallBack = (defines: MaterialDefines) => defines.markAsImageProcessingDirty();\r\n    private static readonly _TextureDirtyCallBack = (defines: MaterialDefines) => defines.markAsTexturesDirty();\r\n    private static readonly _FresnelDirtyCallBack = (defines: MaterialDefines) => defines.markAsFresnelDirty();\r\n    private static readonly _MiscDirtyCallBack = (defines: MaterialDefines) => defines.markAsMiscDirty();\r\n    private static readonly _PrePassDirtyCallBack = (defines: MaterialDefines) => defines.markAsPrePassDirty();\r\n    private static readonly _LightsDirtyCallBack = (defines: MaterialDefines) => defines.markAsLightDirty();\r\n    private static readonly _AttributeDirtyCallBack = (defines: MaterialDefines) => defines.markAsAttributesDirty();\r\n\r\n    private static _FresnelAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._FresnelDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static _TextureAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._TextureDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static readonly _DirtyCallbackArray: Array<(defines: MaterialDefines) => void> = [];\r\n    private static readonly _RunDirtyCallBacks = (defines: MaterialDefines) => {\r\n        for (const cb of Material._DirtyCallbackArray) {\r\n            cb(defines);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Marks a define in the material to indicate that it needs to be re-computed\r\n     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n     */\r\n    public markAsDirty(flag: number): void {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        Material._DirtyCallbackArray.length = 0;\r\n\r\n        if (flag & Material.TextureDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.LightDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.FresnelDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.AttributesDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.MiscDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.PrePassDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\r\n        }\r\n\r\n        if (Material._DirtyCallbackArray.length) {\r\n            this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\r\n        }\r\n\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes that are using this material\r\n     */\r\n    public resetDrawCache(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.resetDrawCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n     * @param func defines a function which checks material defines against the submeshes\r\n     */\r\n    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\r\n                if (subMesh.getMaterial(false) !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        func(drawWrapper.defines as MaterialDefines);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the scene should check if the rendering now needs a prepass\r\n     */\r\n    protected _markScenePrePassDirty() {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const prePassRenderer = this.getScene().enablePrePassRenderer();\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that we need to re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAllDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that image processing needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsImageProcessingDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that lights need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsLightsDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that attributes need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAttributesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that misc needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that prepass needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsPrePassDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\r\n    }\r\n\r\n    protected _checkScenePerformancePriority() {\r\n        if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\r\n            this.checkReadyOnlyOnce = true;\r\n            // re-set the flag when the perf priority changes\r\n            const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {\r\n                this.checkReadyOnlyOnce = false;\r\n            });\r\n            // if this material is disposed before the scene is disposed, cleanup the observer\r\n            this.onDisposeObservable.add(() => {\r\n                this._scene.onScenePerformancePriorityChangedObservable.remove(observer);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param _forceDisposeEffect kept for backward compat. We reference count the effect now.\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(_forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        const scene = this.getScene();\r\n        // Animations\r\n        scene.stopAnimation(this);\r\n        scene.freeProcessedMaterials();\r\n\r\n        // Remove from scene\r\n        scene.removeMaterial(this);\r\n\r\n        this._eventInfo.forceDisposeTextures = forceDisposeTextures;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.materials.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.materials.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (notBoundToMesh !== true) {\r\n            // Remove from meshes\r\n            if (this.meshMap) {\r\n                for (const meshId in this.meshMap) {\r\n                    const mesh = this.meshMap[meshId];\r\n                    this._disposeMeshResources(mesh);\r\n                }\r\n            } else {\r\n                const meshes = scene.meshes;\r\n                for (const mesh of meshes) {\r\n                    this._disposeMeshResources(mesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\r\n        if (this._drawWrapper.effect) {\r\n            if (!this._storeEffectOnSubMeshes) {\r\n                this._drawWrapper.effect.dispose();\r\n            }\r\n\r\n            this._drawWrapper.effect = null;\r\n        }\r\n\r\n        this.metadata = null;\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        if (this._onBindObservable) {\r\n            this._onBindObservable.clear();\r\n        }\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.clear();\r\n        }\r\n\r\n        if (this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable.clear();\r\n        }\r\n\r\n        if (this._eventInfo) {\r\n            this._eventInfo = {} as any;\r\n        }\r\n    }\r\n\r\n    private _disposeMeshResources(mesh: AbstractMesh | undefined) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const geometry = (<Mesh>mesh).geometry;\r\n        const materialForRenderPass = mesh._internalAbstractMeshDataInfo._materialForRenderPass;\r\n        if (this._storeEffectOnSubMeshes) {\r\n            if (mesh.subMeshes && materialForRenderPass) {\r\n                for (const subMesh of mesh.subMeshes) {\r\n                    const drawWrappers = subMesh._drawWrappers;\r\n                    for (let renderPassIndex = 0; renderPassIndex < drawWrappers.length; renderPassIndex++) {\r\n                        const effect = drawWrappers[renderPassIndex]?.effect;\r\n                        if (!effect) {\r\n                            continue;\r\n                        }\r\n                        const material = materialForRenderPass[renderPassIndex];\r\n                        if (material === this) {\r\n                            geometry?._releaseVertexArrayObject(effect);\r\n                            subMesh._removeDrawWrapper(renderPassIndex, true, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            geometry?._releaseVertexArrayObject(this._drawWrapper.effect);\r\n        }\r\n\r\n        if (mesh.material === this && !(mesh as InstancedMesh).sourceMesh) {\r\n            mesh.material = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this material\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.stencil = this.stencil.serialize();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        this._serializePlugins(serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    protected _serializePlugins(serializationObject: any) {\r\n        serializationObject.plugins = {};\r\n\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                if (!plugin.doNotSerialize) {\r\n                    serializationObject.plugins[plugin.getClassName()] = plugin.serialize();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedMaterial defines parsed material data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new material\r\n     */\r\n    public static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material> {\r\n        if (!parsedMaterial.customType) {\r\n            parsedMaterial.customType = \"BABYLON.StandardMaterial\";\r\n        } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\r\n            parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\r\n            if (!BABYLON.LegacyPBRMaterial) {\r\n                Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const materialType = Tools.Instantiate(parsedMaterial.customType);\r\n        const material = materialType.Parse(parsedMaterial, scene, rootUrl);\r\n        material._loadedUniqueId = parsedMaterial.uniqueId;\r\n\r\n        return material;\r\n    }\r\n\r\n    protected static _ParsePlugins(serializationObject: any, material: Material, scene: Scene, rootUrl: string) {\r\n        if (!serializationObject.plugins) {\r\n            return;\r\n        }\r\n\r\n        for (const pluginClassName in serializationObject.plugins) {\r\n            const pluginData = serializationObject.plugins[pluginClassName];\r\n\r\n            let plugin = material.pluginManager?.getPlugin(pluginData.name);\r\n\r\n            if (!plugin) {\r\n                const pluginClassType = Tools.Instantiate(\"BABYLON.\" + pluginClassName);\r\n                if (pluginClassType) {\r\n                    plugin = new pluginClassType(material);\r\n                }\r\n            }\r\n\r\n            plugin?.parse(pluginData, scene, rootUrl);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["_a", "transform", "translation", "kind", "applySkeleton", "applyMorph", "index"]
}
