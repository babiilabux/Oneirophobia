// node_modules/@babylonjs/core/Actions/actionEvent.js
var ActionEvent = class _ActionEvent {
  /**
   * Creates a new ActionEvent
   * @param source The mesh or sprite that triggered the action
   * @param pointerX The X mouse cursor position at the time of the event
   * @param pointerY The Y mouse cursor position at the time of the event
   * @param meshUnderPointer The mesh that is currently pointed at (can be null)
   * @param sourceEvent the original (browser) event that triggered the ActionEvent
   * @param additionalData additional data for the event
   */
  constructor(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
    this.source = source;
    this.pointerX = pointerX;
    this.pointerY = pointerY;
    this.meshUnderPointer = meshUnderPointer;
    this.sourceEvent = sourceEvent;
    this.additionalData = additionalData;
  }
  /**
   * Helper function to auto-create an ActionEvent from a source mesh.
   * @param source The source mesh that triggered the event
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNew(source, evt, additionalData) {
    const scene = source.getScene();
    return new _ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
  }
  /**
   * Helper function to auto-create an ActionEvent from a source sprite
   * @param source The source sprite that triggered the event
   * @param scene Scene associated with the sprite
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNewFromSprite(source, scene, evt, additionalData) {
    return new _ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
  }
  /**
   * Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew
   * @param scene the scene where the event occurred
   * @param evt The original (browser) event
   * @returns the new ActionEvent
   */
  static CreateNewFromScene(scene, evt) {
    return new _ActionEvent(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
  }
  /**
   * Helper function to auto-create an ActionEvent from a primitive
   * @param prim defines the target primitive
   * @param pointerPos defines the pointer position
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNewFromPrimitive(prim, pointerPos, evt, additionalData) {
    return new _ActionEvent(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
  }
};

// node_modules/@babylonjs/core/Actions/abstractActionManager.js
var AbstractActionManager = class _AbstractActionManager {
  constructor() {
    this.hoverCursor = "";
    this.actions = [];
    this.isRecursive = false;
    this.disposeWhenUnowned = true;
  }
  /**
   * Does exist one action manager with at least one trigger
   **/
  static get HasTriggers() {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does exist one action manager with at least one pick trigger
   **/
  static get HasPickTriggers() {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        const tAsInt = parseInt(t);
        if (tAsInt >= 1 && tAsInt <= 7) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Does exist one action manager that handles actions of a given trigger
   * @param trigger defines the trigger to be tested
   * @returns a boolean indicating whether the trigger is handled by at least one action manager
   **/
  static HasSpecificTrigger(trigger) {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        const tAsInt = parseInt(t);
        if (tAsInt === trigger) {
          return true;
        }
      }
    }
    return false;
  }
};
AbstractActionManager.Triggers = {};

export {
  ActionEvent,
  AbstractActionManager
};
//# sourceMappingURL=chunk-36UZTWIQ.js.map
