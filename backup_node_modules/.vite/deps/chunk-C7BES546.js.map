{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Data/flowGraphGetPropertyBlock.ts"],
  "sourcesContent": ["import type { AssetType, FlowGraphAssetType } from \"core/FlowGraph/flowGraphAssetsContext\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport { FlowGraphBlock } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\n\nexport interface IFlowGraphGetPropertyBlockConfiguration<O extends FlowGraphAssetType> extends IFlowGraphBlockConfiguration {\n    /**\n     * The name of the property that will be set\n     */\n    propertyName?: string;\n\n    /**\n     * The target asset from which the property will be retrieved\n     */\n    object?: AssetType<O>;\n\n    /**\n     * If true, the block will reset the output to the default value when the target asset is undefined.\n     */\n    resetToDefaultWhenUndefined?: boolean;\n}\n\n/**\n * This block will deliver a property of an asset, based on the property name and an input asset.\n * The property name can include dots (\".\"), which will be interpreted as a path to the property.\n *\n * For example, with an input of a mesh asset, the property name \"position.x\" will deliver the x component of the position of the mesh.\n *\n * Note that it is recommended to input the object on which you are working on (i.e. a material) rather than providing a mesh as object and then getting the material from it.\n */\nexport class FlowGraphGetPropertyBlock<P extends any, O extends FlowGraphAssetType> extends FlowGraphBlock {\n    /**\n     * Output connection: The value of the property.\n     */\n    public readonly value: FlowGraphDataConnection<P>;\n\n    /**\n     * Input connection: The asset from which the property will be retrieved\n     */\n    public readonly object: FlowGraphDataConnection<AssetType<O>>;\n\n    /**\n     * Input connection: The name of the property that will be set\n     */\n    public readonly propertyName: FlowGraphDataConnection<string>;\n\n    /**\n     * Output connection: Whether the value is valid.\n     */\n    public readonly isValid: FlowGraphDataConnection<boolean>;\n\n    /**\n     * Input connection: A function that can be used to get the value of the property.\n     * This will be used if defined, instead of the default get function.\n     */\n    public readonly customGetFunction: FlowGraphDataConnection<(target: AssetType<O>, propertyName: string, context: FlowGraphContext) => P | undefined>;\n\n    constructor(\n        /**\n         * the configuration of the block\n         */\n        public override config: IFlowGraphGetPropertyBlockConfiguration<O>\n    ) {\n        super(config);\n        this.object = this.registerDataInput(\"object\", RichTypeAny, config.object);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config.propertyName);\n        this.value = this.registerDataOutput(\"value\", RichTypeAny);\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeAny, false);\n        this.customGetFunction = this.registerDataInput(\"customGetFunction\", RichTypeAny);\n    }\n\n    public override _updateOutputs(context: FlowGraphContext): void {\n        const getter = this.customGetFunction.getValue(context);\n        let value;\n        if (getter) {\n            value = getter(this.object.getValue(context), this.propertyName.getValue(context), context);\n        } else {\n            const target = this.object.getValue(context);\n            const propertyName = this.propertyName.getValue(context);\n            value = target && propertyName ? this._getPropertyValue(target, propertyName) : undefined;\n        }\n        if (value === undefined) {\n            this.value.resetToDefaultValue(context);\n            this.isValid.setValue(false, context);\n        } else {\n            this.value.setValue(value, context);\n            this.isValid.setValue(true, context);\n        }\n    }\n\n    private _getPropertyValue(target: AssetType<O>, propertyName: string): P | undefined {\n        const path = propertyName.split(\".\");\n        let value: any = target;\n        for (const prop of path) {\n            value = value[prop];\n            if (value === undefined) {\n                return;\n            }\n        }\n        return value as P;\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.GetProperty;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.GetProperty, FlowGraphGetPropertyBlock);\n"],
  "mappings": ";;;;;;;;;AAkCM,IAAO,4BAAP,cAAsF,eAAc;EA2BtG,YAIoB,QAAkD;AAElE,UAAM,MAAM;AAFI,SAAA,SAAA;AAGhB,SAAK,SAAS,KAAK,kBAAkB,UAAU,aAAa,OAAO,MAAM;AACzE,SAAK,eAAe,KAAK,kBAAkB,gBAAgB,aAAa,OAAO,YAAY;AAC3F,SAAK,QAAQ,KAAK,mBAAmB,SAAS,WAAW;AACzD,SAAK,UAAU,KAAK,mBAAmB,WAAW,aAAa,KAAK;AACpE,SAAK,oBAAoB,KAAK,kBAAkB,qBAAqB,WAAW;EACpF;EAEgB,eAAe,SAAyB;AACpD,UAAM,SAAS,KAAK,kBAAkB,SAAS,OAAO;AACtD,QAAI;AACJ,QAAI,QAAQ;AACR,cAAQ,OAAO,KAAK,OAAO,SAAS,OAAO,GAAG,KAAK,aAAa,SAAS,OAAO,GAAG,OAAO;IAC9F,OAAO;AACH,YAAM,SAAS,KAAK,OAAO,SAAS,OAAO;AAC3C,YAAM,eAAe,KAAK,aAAa,SAAS,OAAO;AACvD,cAAQ,UAAU,eAAe,KAAK,kBAAkB,QAAQ,YAAY,IAAI;IACpF;AACA,QAAI,UAAU,QAAW;AACrB,WAAK,MAAM,oBAAoB,OAAO;AACtC,WAAK,QAAQ,SAAS,OAAO,OAAO;IACxC,OAAO;AACH,WAAK,MAAM,SAAS,OAAO,OAAO;AAClC,WAAK,QAAQ,SAAS,MAAM,OAAO;IACvC;EACJ;EAEQ,kBAAkB,QAAsB,cAAoB;AAChE,UAAM,OAAO,aAAa,MAAM,GAAG;AACnC,QAAI,QAAa;AACjB,eAAW,QAAQ,MAAM;AACrB,cAAQ,MAAM,IAAI;AAClB,UAAI,UAAU,QAAW;AACrB;MACJ;IACJ;AACA,WAAO;EACX;EAEgB,eAAY;AACxB,WAAA;EACJ;;AAGJ,cAAa,6BAAkC,yBAAyB;",
  "names": []
}
