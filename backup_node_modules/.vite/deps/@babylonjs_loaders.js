import {
  GLTFFileLoader,
  GLTFLoaderAnimationStartMode,
  GLTFLoaderCoordinateSystemMode,
  GLTFLoaderState,
  GLTFValidation,
  __exports,
  __exports2
} from "./chunk-T5ETOLD5.js";
import "./chunk-PMB5GQQP.js";
import "./chunk-KRF6YBV3.js";
import {
  GaussianSplattingMesh,
  PointsCloudSystem,
  Scalar
} from "./chunk-TNFRR5ZQ.js";
import "./chunk-BEPDLREQ.js";
import "./chunk-JTRWFDHQ.js";
import "./chunk-AOYJ33OV.js";
import "./chunk-67TRHIEO.js";
import "./chunk-OMNW7HZQ.js";
import "./chunk-I5BBEPRZ.js";
import "./chunk-IOS2TZDG.js";
import "./chunk-I6OM3CIO.js";
import "./chunk-IY4PVWUW.js";
import "./chunk-OWC6FO2G.js";
import "./chunk-Z3JR7L3D.js";
import "./chunk-4EWIKMHR.js";
import "./chunk-VS2T6M7R.js";
import "./chunk-P4YBURK3.js";
import "./chunk-F3L7WFPM.js";
import "./chunk-5XUC5YLD.js";
import "./chunk-AOR56DAK.js";
import "./chunk-ZHVJLRNA.js";
import "./chunk-TFICMMLP.js";
import "./chunk-IYZQD2T2.js";
import "./chunk-QYMANNDW.js";
import "./chunk-2CQYG4NC.js";
import "./chunk-JP7RZPEM.js";
import "./chunk-MM4X4US3.js";
import "./chunk-UN6RPNTZ.js";
import "./chunk-JMP4XLQW.js";
import "./chunk-CDAV7UBV.js";
import "./chunk-VJ7LLHSW.js";
import "./chunk-Z4SZSXAI.js";
import "./chunk-W7BX4MFA.js";
import "./chunk-UOYNNPUW.js";
import {
  AssetContainer,
  Geometry,
  Mesh,
  RegisterSceneLoaderPlugin,
  StandardMaterial
} from "./chunk-5EOZ3GYA.js";
import "./chunk-2TY2RX26.js";
import "./chunk-GWIHLVVL.js";
import "./chunk-QBVVNEQ7.js";
import "./chunk-HZXXKJYK.js";
import "./chunk-BUHHHWE6.js";
import "./chunk-3RTKBPX6.js";
import "./chunk-4QZSF2R2.js";
import "./chunk-Q3PEWXKM.js";
import "./chunk-QNTHIMQR.js";
import "./chunk-YOJG2XVT.js";
import "./chunk-MY6CLL3P.js";
import "./chunk-QDXIFF52.js";
import "./chunk-GIGCTCHJ.js";
import "./chunk-376V6KTI.js";
import "./chunk-22ISSOZX.js";
import "./chunk-SPI7UZDI.js";
import "./chunk-CTK2VLJT.js";
import "./chunk-WJMMKYZG.js";
import {
  VertexData
} from "./chunk-CILZ646M.js";
import "./chunk-BSSJ34GN.js";
import "./chunk-R7CDVIEH.js";
import "./chunk-SEFTBBPY.js";
import "./chunk-WKXRXUEO.js";
import "./chunk-KXXZ7MGC.js";
import "./chunk-FOJB2NDX.js";
import "./chunk-ZXVFJ3IO.js";
import "./chunk-TURWNHNE.js";
import "./chunk-CICZROG2.js";
import {
  Texture
} from "./chunk-YDA7SEAD.js";
import "./chunk-KDMQ7A26.js";
import "./chunk-LS3EXLWE.js";
import "./chunk-7MWCSIAI.js";
import {
  VertexBuffer
} from "./chunk-SGWWALOD.js";
import {
  Tools
} from "./chunk-2OIPT5LI.js";
import "./chunk-DZ3VQOIJ.js";
import "./chunk-IW7YW5OA.js";
import "./chunk-I2PO3XEU.js";
import "./chunk-2PMLUZ5B.js";
import "./chunk-ZGJ7GRVA.js";
import "./chunk-36UZTWIQ.js";
import "./chunk-2KMAKWRA.js";
import "./chunk-YQ2GI7HI.js";
import "./chunk-YC62VEDI.js";
import {
  Color3,
  Color4
} from "./chunk-QJYZAU53.js";
import {
  Vector2,
  Vector3
} from "./chunk-3LKPOCHD.js";
import "./chunk-QPP7FIQR.js";
import "./chunk-2ZEUD233.js";
import "./chunk-LMH7SWDS.js";
import "./chunk-4GUORC2E.js";
import "./chunk-6QZ75BYX.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import "./chunk-47GQF5OD.js";
import "./chunk-QS7N3A43.js";
import "./chunk-FX6MN5HL.js";
import "./chunk-PZ5AY32C.js";

// node_modules/@babylonjs/loaders/OBJ/mtlFileLoader.js
var MTLFileLoader = class _MTLFileLoader {
  constructor() {
    this.materials = [];
  }
  /**
   * This function will read the mtl file and create each material described inside
   * This function could be improve by adding :
   * -some component missing (Ni, Tf...)
   * -including the specific options available
   *
   * @param scene defines the scene the material will be created in
   * @param data defines the mtl data to parse
   * @param rootUrl defines the rooturl to use in order to load relative dependencies
   * @param assetContainer defines the asset container to store the material in (can be null)
   */
  parseMTL(scene, data, rootUrl, assetContainer) {
    if (data instanceof ArrayBuffer) {
      return;
    }
    const lines = data.split("\n");
    const delimiter_pattern = /\s+/;
    let color;
    let material = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      }
      const pos = line.indexOf(" ");
      let key = pos >= 0 ? line.substring(0, pos) : line;
      key = key.toLowerCase();
      const value = pos >= 0 ? line.substring(pos + 1).trim() : "";
      if (key === "newmtl") {
        if (material) {
          this.materials.push(material);
        }
        scene._blockEntityCollection = !!assetContainer;
        material = new StandardMaterial(value, scene);
        material._parentContainer = assetContainer;
        scene._blockEntityCollection = false;
      } else if (key === "kd" && material) {
        color = value.split(delimiter_pattern, 3).map(parseFloat);
        material.diffuseColor = Color3.FromArray(color);
      } else if (key === "ka" && material) {
        color = value.split(delimiter_pattern, 3).map(parseFloat);
        material.ambientColor = Color3.FromArray(color);
      } else if (key === "ks" && material) {
        color = value.split(delimiter_pattern, 3).map(parseFloat);
        material.specularColor = Color3.FromArray(color);
      } else if (key === "ke" && material) {
        color = value.split(delimiter_pattern, 3).map(parseFloat);
        material.emissiveColor = Color3.FromArray(color);
      } else if (key === "ns" && material) {
        material.specularPower = parseFloat(value);
      } else if (key === "d" && material) {
        material.alpha = parseFloat(value);
      } else if (key === "map_ka" && material) {
        material.ambientTexture = _MTLFileLoader._GetTexture(rootUrl, value, scene);
      } else if (key === "map_kd" && material) {
        material.diffuseTexture = _MTLFileLoader._GetTexture(rootUrl, value, scene);
      } else if (key === "map_ks" && material) {
        material.specularTexture = _MTLFileLoader._GetTexture(rootUrl, value, scene);
      } else if (key === "map_ns") {
      } else if (key === "map_bump" && material) {
        const values = value.split(delimiter_pattern);
        const bumpMultiplierIndex = values.indexOf("-bm");
        let bumpMultiplier = null;
        if (bumpMultiplierIndex >= 0) {
          bumpMultiplier = values[bumpMultiplierIndex + 1];
          values.splice(bumpMultiplierIndex, 2);
        }
        material.bumpTexture = _MTLFileLoader._GetTexture(rootUrl, values.join(" "), scene);
        if (material.bumpTexture && bumpMultiplier !== null) {
          material.bumpTexture.level = parseFloat(bumpMultiplier);
        }
      } else if (key === "map_d" && material) {
        material.opacityTexture = _MTLFileLoader._GetTexture(rootUrl, value, scene);
      } else if (key === "illum") {
        if (value === "0") {
        } else if (value === "1") {
        } else if (value === "2") {
        } else if (value === "3") {
        } else if (value === "4") {
        } else if (value === "5") {
        } else if (value === "6") {
        } else if (value === "7") {
        } else if (value === "8") {
        } else if (value === "9") {
        } else if (value === "10") {
        }
      } else {
      }
    }
    if (material) {
      this.materials.push(material);
    }
  }
  /**
   * Gets the texture for the material.
   *
   * If the material is imported from input file,
   * We sanitize the url to ensure it takes the texture from aside the material.
   *
   * @param rootUrl The root url to load from
   * @param value The value stored in the mtl
   * @param scene
   * @returns The Texture
   */
  static _GetTexture(rootUrl, value, scene) {
    if (!value) {
      return null;
    }
    let url = rootUrl;
    if (rootUrl === "file:") {
      let lastDelimiter = value.lastIndexOf("\\");
      if (lastDelimiter === -1) {
        lastDelimiter = value.lastIndexOf("/");
      }
      if (lastDelimiter > -1) {
        url += value.substring(lastDelimiter + 1);
      } else {
        url += value;
      }
    } else {
      url += value;
    }
    return new Texture(url, scene, false, _MTLFileLoader.INVERT_TEXTURE_Y);
  }
};
MTLFileLoader.INVERT_TEXTURE_Y = true;

// node_modules/@babylonjs/loaders/OBJ/solidParser.js
var SolidParser = class _SolidParser {
  /**
   * Creates a new SolidParser
   * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)
   * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)
   * @param loadingOptions defines the loading options to use
   */
  constructor(materialToUse, babylonMeshesArray, loadingOptions) {
    this._positions = [];
    this._normals = [];
    this._uvs = [];
    this._colors = [];
    this._extColors = [];
    this._meshesFromObj = [];
    this._indicesForBabylon = [];
    this._wrappedPositionForBabylon = [];
    this._wrappedUvsForBabylon = [];
    this._wrappedColorsForBabylon = [];
    this._wrappedNormalsForBabylon = [];
    this._tuplePosNorm = [];
    this._curPositionInIndices = 0;
    this._hasMeshes = false;
    this._unwrappedPositionsForBabylon = [];
    this._unwrappedColorsForBabylon = [];
    this._unwrappedNormalsForBabylon = [];
    this._unwrappedUVForBabylon = [];
    this._triangles = [];
    this._materialNameFromObj = "";
    this._objMeshName = "";
    this._increment = 1;
    this._isFirstMaterial = true;
    this._grayColor = new Color4(0.5, 0.5, 0.5, 1);
    this._hasLineData = false;
    this._materialToUse = materialToUse;
    this._babylonMeshesArray = babylonMeshesArray;
    this._loadingOptions = loadingOptions;
  }
  /**
   * Search for obj in the given array.
   * This function is called to check if a couple of data already exists in an array.
   *
   * If found, returns the index of the founded tuple index. Returns -1 if not found
   * @param arr Array<{ normals: Array<number>, idx: Array<number> }>
   * @param obj Array<number>
   * @returns {boolean}
   */
  _isInArray(arr, obj) {
    if (!arr[obj[0]]) {
      arr[obj[0]] = { normals: [], idx: [] };
    }
    const idx = arr[obj[0]].normals.indexOf(obj[1]);
    return idx === -1 ? -1 : arr[obj[0]].idx[idx];
  }
  _isInArrayUV(arr, obj) {
    if (!arr[obj[0]]) {
      arr[obj[0]] = { normals: [], idx: [], uv: [] };
    }
    const idx = arr[obj[0]].normals.indexOf(obj[1]);
    if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {
      return arr[obj[0]].idx[idx];
    }
    return -1;
  }
  /**
   * This function set the data for each triangle.
   * Data are position, normals and uvs
   * If a tuple of (position, normal) is not set, add the data into the corresponding array
   * If the tuple already exist, add only their indice
   *
   * @param indicePositionFromObj Integer The index in positions array
   * @param indiceUvsFromObj Integer The index in uvs array
   * @param indiceNormalFromObj Integer The index in normals array
   * @param positionVectorFromOBJ Vector3 The value of position at index objIndice
   * @param textureVectorFromOBJ Vector3 The value of uvs
   * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale
   * @param positionColorsFromOBJ
   */
  _setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {
    let _index;
    if (this._loadingOptions.optimizeWithUV) {
      _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);
    } else {
      _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);
    }
    if (_index === -1) {
      this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);
      this._wrappedPositionForBabylon.push(positionVectorFromOBJ);
      textureVectorFromOBJ = textureVectorFromOBJ ?? new Vector2(0, 0);
      this._wrappedUvsForBabylon.push(textureVectorFromOBJ);
      this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);
      if (positionColorsFromOBJ !== void 0) {
        this._wrappedColorsForBabylon.push(positionColorsFromOBJ);
      }
      this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);
      this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);
      if (this._loadingOptions.optimizeWithUV) {
        this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);
      }
    } else {
      this._indicesForBabylon.push(_index);
    }
  }
  /**
   * Transform Vector() and BABYLON.Color() objects into numbers in an array
   */
  _unwrapData() {
    try {
      for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {
        this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x * this._handednessSign, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);
        this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x * this._handednessSign, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);
        this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y);
        if (this._loadingOptions.importVertexColors) {
          this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);
        }
      }
      this._wrappedPositionForBabylon.length = 0;
      this._wrappedNormalsForBabylon.length = 0;
      this._wrappedUvsForBabylon.length = 0;
      this._wrappedColorsForBabylon.length = 0;
      this._tuplePosNorm.length = 0;
      this._curPositionInIndices = 0;
    } catch (e) {
      throw new Error("Unable to unwrap data while parsing OBJ data.");
    }
  }
  /**
   * Create triangles from polygons
   * It is important to notice that a triangle is a polygon
   * We get 5 patterns of face defined in OBJ File :
   * facePattern1 = ["1","2","3","4","5","6"]
   * facePattern2 = ["1/1","2/2","3/3","4/4","5/5","6/6"]
   * facePattern3 = ["1/1/1","2/2/2","3/3/3","4/4/4","5/5/5","6/6/6"]
   * facePattern4 = ["1//1","2//2","3//3","4//4","5//5","6//6"]
   * facePattern5 = ["-1/-1/-1","-2/-2/-2","-3/-3/-3","-4/-4/-4","-5/-5/-5","-6/-6/-6"]
   * Each pattern is divided by the same method
   * @param faces Array[String] The indices of elements
   * @param v Integer The variable to increment
   */
  _getTriangles(faces, v) {
    for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {
      this._pushTriangle(faces, faceIndex);
    }
  }
  /**
   * To get color between color and extension color
   * @param index Integer The index of the element in the array
   * @returns value of target color
   */
  _getColor(index) {
    if (this._loadingOptions.importVertexColors) {
      return this._extColors[index] ?? this._colors[index];
    } else {
      return void 0;
    }
  }
  /**
   * Create triangles and push the data for each polygon for the pattern 1
   * In this pattern we get vertice positions
   * @param face
   * @param v
   */
  _setDataForCurrentFaceWithPattern1(face, v) {
    this._getTriangles(face, v);
    for (let k = 0; k < this._triangles.length; k++) {
      const indicePositionFromObj = parseInt(this._triangles[k]) - 1;
      this._setData(
        indicePositionFromObj,
        0,
        0,
        // In the pattern 1, normals and uvs are not defined
        this._positions[indicePositionFromObj],
        // Get the vectors data
        Vector2.Zero(),
        Vector3.Up(),
        // Create default vectors
        this._getColor(indicePositionFromObj)
      );
    }
    this._triangles.length = 0;
  }
  /**
   * Create triangles and push the data for each polygon for the pattern 2
   * In this pattern we get vertice positions and uvs
   * @param face
   * @param v
   */
  _setDataForCurrentFaceWithPattern2(face, v) {
    this._getTriangles(face, v);
    for (let k = 0; k < this._triangles.length; k++) {
      const point = this._triangles[k].split("/");
      const indicePositionFromObj = parseInt(point[0]) - 1;
      const indiceUvsFromObj = parseInt(point[1]) - 1;
      this._setData(
        indicePositionFromObj,
        indiceUvsFromObj,
        0,
        //Default value for normals
        this._positions[indicePositionFromObj],
        //Get the values for each element
        this._uvs[indiceUvsFromObj] ?? Vector2.Zero(),
        Vector3.Up(),
        //Default value for normals
        this._getColor(indicePositionFromObj)
      );
    }
    this._triangles.length = 0;
  }
  /**
   * Create triangles and push the data for each polygon for the pattern 3
   * In this pattern we get vertice positions, uvs and normals
   * @param face
   * @param v
   */
  _setDataForCurrentFaceWithPattern3(face, v) {
    this._getTriangles(face, v);
    for (let k = 0; k < this._triangles.length; k++) {
      const point = this._triangles[k].split("/");
      const indicePositionFromObj = parseInt(point[0]) - 1;
      const indiceUvsFromObj = parseInt(point[1]) - 1;
      const indiceNormalFromObj = parseInt(point[2]) - 1;
      this._setData(
        indicePositionFromObj,
        indiceUvsFromObj,
        indiceNormalFromObj,
        this._positions[indicePositionFromObj],
        this._uvs[indiceUvsFromObj] ?? Vector2.Zero(),
        this._normals[indiceNormalFromObj] ?? Vector3.Up()
        //Set the vector for each component
      );
    }
    this._triangles.length = 0;
  }
  /**
   * Create triangles and push the data for each polygon for the pattern 4
   * In this pattern we get vertice positions and normals
   * @param face
   * @param v
   */
  _setDataForCurrentFaceWithPattern4(face, v) {
    this._getTriangles(face, v);
    for (let k = 0; k < this._triangles.length; k++) {
      const point = this._triangles[k].split("//");
      const indicePositionFromObj = parseInt(point[0]) - 1;
      const indiceNormalFromObj = parseInt(point[1]) - 1;
      this._setData(
        indicePositionFromObj,
        1,
        //Default value for uv
        indiceNormalFromObj,
        this._positions[indicePositionFromObj],
        //Get each vector of data
        Vector2.Zero(),
        this._normals[indiceNormalFromObj],
        this._getColor(indicePositionFromObj)
      );
    }
    this._triangles.length = 0;
  }
  /*
   * Create triangles and push the data for each polygon for the pattern 3
   * In this pattern we get vertice positions, uvs and normals
   * @param face
   * @param v
   */
  _setDataForCurrentFaceWithPattern5(face, v) {
    this._getTriangles(face, v);
    for (let k = 0; k < this._triangles.length; k++) {
      const point = this._triangles[k].split("/");
      const indicePositionFromObj = this._positions.length + parseInt(point[0]);
      const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);
      const indiceNormalFromObj = this._normals.length + parseInt(point[2]);
      this._setData(
        indicePositionFromObj,
        indiceUvsFromObj,
        indiceNormalFromObj,
        this._positions[indicePositionFromObj],
        this._uvs[indiceUvsFromObj],
        this._normals[indiceNormalFromObj],
        //Set the vector for each component
        this._getColor(indicePositionFromObj)
      );
    }
    this._triangles.length = 0;
  }
  _addPreviousObjMesh() {
    if (this._meshesFromObj.length > 0) {
      this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];
      this._unwrapData();
      if (this._loadingOptions.useLegacyBehavior) {
        this._indicesForBabylon.reverse();
      }
      this._handledMesh.indices = this._indicesForBabylon.slice();
      this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();
      this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();
      this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();
      this._handledMesh.hasLines = this._hasLineData;
      if (this._loadingOptions.importVertexColors) {
        this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();
      }
      this._indicesForBabylon.length = 0;
      this._unwrappedPositionsForBabylon.length = 0;
      this._unwrappedColorsForBabylon.length = 0;
      this._unwrappedNormalsForBabylon.length = 0;
      this._unwrappedUVForBabylon.length = 0;
      this._hasLineData = false;
    }
  }
  _optimizeNormals(mesh) {
    const positions = mesh.getVerticesData(VertexBuffer.PositionKind);
    const normals = mesh.getVerticesData(VertexBuffer.NormalKind);
    const mapVertices = {};
    if (!positions || !normals) {
      return;
    }
    for (let i = 0; i < positions.length / 3; i++) {
      const x = positions[i * 3 + 0];
      const y = positions[i * 3 + 1];
      const z = positions[i * 3 + 2];
      const key = x + "_" + y + "_" + z;
      let lst = mapVertices[key];
      if (!lst) {
        lst = [];
        mapVertices[key] = lst;
      }
      lst.push(i);
    }
    const normal = new Vector3();
    for (const key in mapVertices) {
      const lst = mapVertices[key];
      if (lst.length < 2) {
        continue;
      }
      const v0Idx = lst[0];
      for (let i = 1; i < lst.length; ++i) {
        const vIdx = lst[i];
        normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];
        normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];
        normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];
      }
      normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);
      normal.normalize();
      for (let i = 0; i < lst.length; ++i) {
        const vIdx = lst[i];
        normals[vIdx * 3 + 0] = normal.x;
        normals[vIdx * 3 + 1] = normal.y;
        normals[vIdx * 3 + 2] = normal.z;
      }
    }
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
  }
  static _IsLineElement(line) {
    return line.startsWith("l");
  }
  static _IsObjectElement(line) {
    return line.startsWith("o");
  }
  static _IsGroupElement(line) {
    return line.startsWith("g");
  }
  static _GetZbrushMRGB(line, notParse) {
    if (!line.startsWith("mrgb"))
      return null;
    line = line.replace("mrgb", "").trim();
    if (notParse)
      return [];
    const regex = /[a-z0-9]/g;
    const regArray = line.match(regex);
    if (!regArray || regArray.length % 8 !== 0) {
      return [];
    }
    const array = [];
    for (let regIndex = 0; regIndex < regArray.length / 8; regIndex++) {
      const r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];
      const g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];
      const b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];
      array.push(new Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));
    }
    return array;
  }
  /**
   * Function used to parse an OBJ string
   * @param meshesNames defines the list of meshes to load (all if not defined)
   * @param data defines the OBJ string
   * @param scene defines the hosting scene
   * @param assetContainer defines the asset container to load data in
   * @param onFileToLoadFound defines a callback that will be called if a MTL file is found
   */
  parse(meshesNames, data, scene, assetContainer, onFileToLoadFound) {
    var _a;
    data = data.replace(/#MRGB/g, "mrgb");
    data = data.replace(/#.*$/gm, "").trim();
    if (this._loadingOptions.useLegacyBehavior) {
      this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);
      this._handednessSign = 1;
    } else if (scene.useRightHandedSystem) {
      this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);
      this._handednessSign = 1;
    } else {
      this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);
      this._handednessSign = -1;
    }
    const linesOBJ = data.split("\n");
    const lineLines = [];
    let currentGroup = [];
    lineLines.push(currentGroup);
    for (let i = 0; i < linesOBJ.length; i++) {
      const line = linesOBJ[i].trim().replace(/\s\s/g, " ");
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      }
      if (_SolidParser._IsGroupElement(line) || _SolidParser._IsObjectElement(line)) {
        currentGroup = [];
        lineLines.push(currentGroup);
      }
      if (_SolidParser._IsLineElement(line)) {
        const lineValues = line.split(" ");
        for (let i2 = 1; i2 < lineValues.length - 1; i2++) {
          currentGroup.push(`l ${lineValues[i2]} ${lineValues[i2 + 1]}`);
        }
      } else {
        currentGroup.push(line);
      }
    }
    const lines = lineLines.flat();
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim().replace(/\s\s/g, " ");
      let result;
      if (line.length === 0 || line.charAt(0) === "#") {
        continue;
      } else if (_SolidParser.VertexPattern.test(line)) {
        result = line.match(/[^ ]+/g);
        this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
        if (this._loadingOptions.importVertexColors) {
          if (result.length >= 7) {
            const r = parseFloat(result[4]);
            const g = parseFloat(result[5]);
            const b = parseFloat(result[6]);
            this._colors.push(new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === void 0 ? 1 : parseFloat(result[7])));
          } else {
            this._colors.push(this._grayColor);
          }
        }
      } else if ((result = _SolidParser.NormalPattern.exec(line)) !== null) {
        this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
      } else if ((result = _SolidParser.UVPattern.exec(line)) !== null) {
        this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));
      } else if ((result = _SolidParser.FacePattern3.exec(line)) !== null) {
        this._setDataForCurrentFaceWithPattern3(
          result[1].trim().split(" "),
          // ["1/1/1", "2/2/2", "3/3/3"]
          1
        );
      } else if ((result = _SolidParser.FacePattern4.exec(line)) !== null) {
        this._setDataForCurrentFaceWithPattern4(
          result[1].trim().split(" "),
          // ["1//1", "2//2", "3//3"]
          1
        );
      } else if ((result = _SolidParser.FacePattern5.exec(line)) !== null) {
        this._setDataForCurrentFaceWithPattern5(
          result[1].trim().split(" "),
          // ["-1/-1/-1", "-2/-2/-2", "-3/-3/-3"]
          1
        );
      } else if ((result = _SolidParser.FacePattern2.exec(line)) !== null) {
        this._setDataForCurrentFaceWithPattern2(
          result[1].trim().split(" "),
          // ["1/1", "2/2", "3/3"]
          1
        );
      } else if ((result = _SolidParser.FacePattern1.exec(line)) !== null) {
        this._setDataForCurrentFaceWithPattern1(
          result[1].trim().split(" "),
          // ["1", "2", "3"]
          1
        );
      } else if ((result = _SolidParser.LinePattern1.exec(line)) !== null) {
        this._setDataForCurrentFaceWithPattern1(
          result[1].trim().split(" "),
          // ["1", "2"]
          0
        );
        this._hasLineData = true;
      } else if ((result = _SolidParser.LinePattern2.exec(line)) !== null) {
        this._setDataForCurrentFaceWithPattern2(
          result[1].trim().split(" "),
          // ["1/1", "2/2"]
          0
        );
        this._hasLineData = true;
      } else if (result = _SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors)) {
        result.forEach((element) => {
          this._extColors.push(element);
        });
      } else if ((result = _SolidParser.LinePattern3.exec(line)) !== null) {
        this._setDataForCurrentFaceWithPattern3(
          result[1].trim().split(" "),
          // ["1/1/1", "2/2/2"]
          0
        );
        this._hasLineData = true;
      } else if (_SolidParser.GroupDescriptor.test(line) || _SolidParser.ObjectDescriptor.test(line)) {
        const objMesh = {
          name: line.substring(2).trim(),
          //Set the name of the current obj mesh
          indices: null,
          positions: null,
          normals: null,
          uvs: null,
          colors: null,
          materialName: this._materialNameFromObj,
          isObject: _SolidParser.ObjectDescriptor.test(line)
        };
        this._addPreviousObjMesh();
        this._meshesFromObj.push(objMesh);
        this._hasMeshes = true;
        this._isFirstMaterial = true;
        this._increment = 1;
      } else if (_SolidParser.UseMtlDescriptor.test(line)) {
        this._materialNameFromObj = line.substring(7).trim();
        if (!this._isFirstMaterial || !this._hasMeshes) {
          this._addPreviousObjMesh();
          const objMesh = (
            //Set the name of the current obj mesh
            {
              name: (this._objMeshName || "mesh") + "_mm" + this._increment.toString(),
              //Set the name of the current obj mesh
              indices: null,
              positions: null,
              normals: null,
              uvs: null,
              colors: null,
              materialName: this._materialNameFromObj,
              isObject: false
            }
          );
          this._increment++;
          this._meshesFromObj.push(objMesh);
          this._hasMeshes = true;
        }
        if (this._hasMeshes && this._isFirstMaterial) {
          this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;
          this._isFirstMaterial = false;
        }
      } else if (_SolidParser.MtlLibGroupDescriptor.test(line)) {
        onFileToLoadFound(line.substring(7).trim());
      } else if (_SolidParser.SmoothDescriptor.test(line)) {
      } else {
        Logger.Log("Unhandled expression at line : " + line);
      }
    }
    if (this._hasMeshes) {
      this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];
      if (this._loadingOptions.useLegacyBehavior) {
        this._indicesForBabylon.reverse();
      }
      this._unwrapData();
      this._handledMesh.indices = this._indicesForBabylon;
      this._handledMesh.positions = this._unwrappedPositionsForBabylon;
      this._handledMesh.normals = this._unwrappedNormalsForBabylon;
      this._handledMesh.uvs = this._unwrappedUVForBabylon;
      this._handledMesh.hasLines = this._hasLineData;
      if (this._loadingOptions.importVertexColors) {
        this._handledMesh.colors = this._unwrappedColorsForBabylon;
      }
    }
    if (!this._hasMeshes) {
      let newMaterial = null;
      if (this._indicesForBabylon.length) {
        if (this._loadingOptions.useLegacyBehavior) {
          this._indicesForBabylon.reverse();
        }
        this._unwrapData();
      } else {
        for (const pos of this._positions) {
          this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);
        }
        if (this._normals.length) {
          for (const normal of this._normals) {
            this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);
          }
        }
        if (this._uvs.length) {
          for (const uv of this._uvs) {
            this._unwrappedUVForBabylon.push(uv.x, uv.y);
          }
        }
        if (this._extColors.length) {
          for (const color of this._extColors) {
            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);
          }
        } else {
          if (this._colors.length) {
            for (const color of this._colors) {
              this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);
            }
          }
        }
        if (!this._materialNameFromObj) {
          newMaterial = new StandardMaterial(Geometry.RandomId(), scene);
          newMaterial.pointsCloud = true;
          this._materialNameFromObj = newMaterial.name;
          if (!this._normals.length) {
            newMaterial.disableLighting = true;
            newMaterial.emissiveColor = Color3.White();
          }
        }
      }
      this._meshesFromObj.push({
        name: Geometry.RandomId(),
        indices: this._indicesForBabylon,
        positions: this._unwrappedPositionsForBabylon,
        colors: this._unwrappedColorsForBabylon,
        normals: this._unwrappedNormalsForBabylon,
        uvs: this._unwrappedUVForBabylon,
        materialName: this._materialNameFromObj,
        directMaterial: newMaterial,
        isObject: true,
        hasLines: this._hasLineData
      });
    }
    for (let j = 0; j < this._meshesFromObj.length; j++) {
      if (meshesNames && this._meshesFromObj[j].name) {
        if (meshesNames instanceof Array) {
          if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {
            continue;
          }
        } else {
          if (this._meshesFromObj[j].name !== meshesNames) {
            continue;
          }
        }
      }
      this._handledMesh = this._meshesFromObj[j];
      scene._blockEntityCollection = !!assetContainer;
      const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);
      babylonMesh._parentContainer = assetContainer;
      scene._blockEntityCollection = false;
      this._handledMesh._babylonMesh = babylonMesh;
      if (!this._handledMesh.isObject) {
        for (let k = j - 1; k >= 0; --k) {
          if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {
            babylonMesh.parent = this._meshesFromObj[k]._babylonMesh;
            break;
          }
        }
      }
      this._materialToUse.push(this._meshesFromObj[j].materialName);
      if (this._handledMesh.hasLines) {
        babylonMesh._internalMetadata ?? (babylonMesh._internalMetadata = {});
        babylonMesh._internalMetadata["_isLine"] = true;
      }
      if (((_a = this._handledMesh.positions) == null ? void 0 : _a.length) === 0) {
        this._babylonMeshesArray.push(babylonMesh);
        continue;
      }
      const vertexData = new VertexData();
      vertexData.uvs = this._handledMesh.uvs;
      vertexData.indices = this._handledMesh.indices;
      vertexData.positions = this._handledMesh.positions;
      if (this._loadingOptions.computeNormals) {
        const normals = new Array();
        VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);
        vertexData.normals = normals;
      } else {
        vertexData.normals = this._handledMesh.normals;
      }
      if (this._loadingOptions.importVertexColors) {
        vertexData.colors = this._handledMesh.colors;
      }
      vertexData.applyToMesh(babylonMesh);
      if (this._loadingOptions.invertY) {
        babylonMesh.scaling.y *= -1;
      }
      if (this._loadingOptions.optimizeNormals) {
        this._optimizeNormals(babylonMesh);
      }
      this._babylonMeshesArray.push(babylonMesh);
      if (this._handledMesh.directMaterial) {
        babylonMesh.material = this._handledMesh.directMaterial;
      }
    }
  }
};
SolidParser.ObjectDescriptor = /^o/;
SolidParser.GroupDescriptor = /^g/;
SolidParser.MtlLibGroupDescriptor = /^mtllib /;
SolidParser.UseMtlDescriptor = /^usemtl /;
SolidParser.SmoothDescriptor = /^s /;
SolidParser.VertexPattern = /^v(\s+[\d|.|+|\-|e|E]+){3,7}/;
SolidParser.NormalPattern = /^vn(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/;
SolidParser.UVPattern = /^vt(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/;
SolidParser.FacePattern1 = /^f\s+(([\d]{1,}[\s]?){3,})+/;
SolidParser.FacePattern2 = /^f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
SolidParser.FacePattern3 = /^f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
SolidParser.FacePattern4 = /^f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/;
SolidParser.FacePattern5 = /^f\s+(((-[\d]{1,}\/-[\d]{1,}\/-[\d]{1,}[\s]?){3,})+)/;
SolidParser.LinePattern1 = /^l\s+(([\d]{1,}[\s]?){2,})+/;
SolidParser.LinePattern2 = /^l\s+((([\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;
SolidParser.LinePattern3 = /^l\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;

// node_modules/@babylonjs/loaders/OBJ/objFileLoader.metadata.js
var OBJFileLoaderMetadata = {
  name: "obj",
  extensions: ".obj"
};

// node_modules/@babylonjs/loaders/OBJ/objFileLoader.js
var OBJFileLoader = class _OBJFileLoader {
  /**
   * Invert Y-Axis of referenced textures on load
   */
  static get INVERT_TEXTURE_Y() {
    return MTLFileLoader.INVERT_TEXTURE_Y;
  }
  static set INVERT_TEXTURE_Y(value) {
    MTLFileLoader.INVERT_TEXTURE_Y = value;
  }
  /**
   * Creates loader for .OBJ files
   *
   * @param loadingOptions options for loading and parsing OBJ/MTL files.
   */
  constructor(loadingOptions) {
    this.name = OBJFileLoaderMetadata.name;
    this.extensions = OBJFileLoaderMetadata.extensions;
    this._assetContainer = null;
    this._loadingOptions = loadingOptions || _OBJFileLoader._DefaultLoadingOptions;
  }
  static get _DefaultLoadingOptions() {
    return {
      computeNormals: _OBJFileLoader.COMPUTE_NORMALS,
      optimizeNormals: _OBJFileLoader.OPTIMIZE_NORMALS,
      importVertexColors: _OBJFileLoader.IMPORT_VERTEX_COLORS,
      invertY: _OBJFileLoader.INVERT_Y,
      invertTextureY: _OBJFileLoader.INVERT_TEXTURE_Y,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      UVScaling: _OBJFileLoader.UV_SCALING,
      materialLoadingFailsSilently: _OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,
      optimizeWithUV: _OBJFileLoader.OPTIMIZE_WITH_UV,
      skipMaterials: _OBJFileLoader.SKIP_MATERIALS,
      useLegacyBehavior: _OBJFileLoader.USE_LEGACY_BEHAVIOR
    };
  }
  /**
   * Calls synchronously the MTL file attached to this obj.
   * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.
   * Without this function materials are not displayed in the first frame (but displayed after).
   * In consequence it is impossible to get material information in your HTML file
   *
   * @param url The URL of the MTL file
   * @param rootUrl defines where to load data from
   * @param onSuccess Callback function to be called when the MTL file is loaded
   * @param onFailure
   */
  _loadMTL(url, rootUrl, onSuccess, onFailure) {
    const pathOfFile = rootUrl + url;
    Tools.LoadFile(pathOfFile, onSuccess, void 0, void 0, false, (request, exception) => {
      onFailure(pathOfFile, exception);
    });
  }
  /**
   * Instantiates a OBJ file loader plugin.
   * @returns the created plugin
   */
  createPlugin() {
    return new _OBJFileLoader(_OBJFileLoader._DefaultLoadingOptions);
  }
  /**
   * If the data string can be loaded directly.
   * @returns if the data can be loaded directly
   */
  canDirectLoad() {
    return false;
  }
  /**
   * Imports one or more meshes from the loaded OBJ data and adds them to the scene
   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
   * @param scene the scene the meshes should be added to
   * @param data the OBJ data to load
   * @param rootUrl root url to load from
   * @returns a promise containing the loaded meshes, particles, skeletons and animations
   */
  importMeshAsync(meshesNames, scene, data, rootUrl) {
    return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {
      return {
        meshes,
        particleSystems: [],
        skeletons: [],
        animationGroups: [],
        transformNodes: [],
        geometries: [],
        lights: [],
        spriteManagers: []
      };
    });
  }
  /**
   * Imports all objects from the loaded OBJ data and adds them to the scene
   * @param scene the scene the objects should be added to
   * @param data the OBJ data to load
   * @param rootUrl root url to load from
   * @returns a promise which completes when objects have been loaded to the scene
   */
  loadAsync(scene, data, rootUrl) {
    return this.importMeshAsync(null, scene, data, rootUrl).then(() => {
    });
  }
  /**
   * Load into an asset container.
   * @param scene The scene to load into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @returns The loaded asset container
   */
  loadAssetContainerAsync(scene, data, rootUrl) {
    const container = new AssetContainer(scene);
    this._assetContainer = container;
    return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {
      result.meshes.forEach((mesh) => container.meshes.push(mesh));
      result.meshes.forEach((mesh) => {
        const material = mesh.material;
        if (material) {
          if (container.materials.indexOf(material) == -1) {
            container.materials.push(material);
            const textures = material.getActiveTextures();
            textures.forEach((t) => {
              if (container.textures.indexOf(t) == -1) {
                container.textures.push(t);
              }
            });
          }
        }
      });
      this._assetContainer = null;
      return container;
    }).catch((ex) => {
      this._assetContainer = null;
      throw ex;
    });
  }
  /**
   * Read the OBJ file and create an Array of meshes.
   * Each mesh contains all information given by the OBJ and the MTL file.
   * i.e. vertices positions and indices, optional normals values, optional UV values, optional material
   * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file
   * @param scene defines the scene where are displayed the data
   * @param data defines the content of the obj file
   * @param rootUrl defines the path to the folder
   * @returns the list of loaded meshes
   */
  _parseSolid(meshesNames, scene, data, rootUrl) {
    let fileToLoad = "";
    const materialsFromMTLFile = new MTLFileLoader();
    const materialToUse = [];
    const babylonMeshesArray = [];
    data = data.replace(/#.*$/gm, "").trim();
    const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);
    solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName) => {
      fileToLoad = fileName;
    });
    const mtlPromises = [];
    if (fileToLoad !== "" && !this._loadingOptions.skipMaterials) {
      mtlPromises.push(new Promise((resolve, reject) => {
        this._loadMTL(fileToLoad, rootUrl, (dataLoaded) => {
          try {
            materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);
            for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {
              let startIndex = 0;
              const _indices = [];
              let _index;
              while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {
                _indices.push(_index);
                startIndex = _index + 1;
              }
              if (_index === -1 && _indices.length === 0) {
                materialsFromMTLFile.materials[n].dispose();
              } else {
                for (let o = 0; o < _indices.length; o++) {
                  const mesh = babylonMeshesArray[_indices[o]];
                  const material = materialsFromMTLFile.materials[n];
                  mesh.material = material;
                  if (!mesh.getTotalIndices()) {
                    material.pointsCloud = true;
                  }
                }
              }
            }
            resolve();
          } catch (e) {
            Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);
            if (this._loadingOptions.materialLoadingFailsSilently) {
              resolve();
            } else {
              reject(e);
            }
          }
        }, (pathOfFile, exception) => {
          Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);
          if (this._loadingOptions.materialLoadingFailsSilently) {
            resolve();
          } else {
            reject(exception);
          }
        });
      }));
    }
    return Promise.all(mtlPromises).then(() => {
      const isLine = (mesh) => {
        var _a;
        return Boolean(((_a = mesh._internalMetadata) == null ? void 0 : _a["_isLine"]) ?? false);
      };
      babylonMeshesArray.forEach((mesh) => {
        if (isLine(mesh)) {
          let mat = mesh.material ?? new StandardMaterial(mesh.name + "_line", scene);
          const needClone = mat.getBindedMeshes().filter((e) => !isLine(e)).length > 0;
          if (needClone) {
            mat = mat.clone(mat.name + "_line") ?? mat;
          }
          mat.wireframe = true;
          mesh.material = mat;
          if (mesh._internalMetadata) {
            mesh._internalMetadata["_isLine"] = void 0;
          }
        }
      });
      return babylonMeshesArray;
    });
  }
};
OBJFileLoader.OPTIMIZE_WITH_UV = true;
OBJFileLoader.INVERT_Y = false;
OBJFileLoader.IMPORT_VERTEX_COLORS = false;
OBJFileLoader.COMPUTE_NORMALS = false;
OBJFileLoader.OPTIMIZE_NORMALS = false;
OBJFileLoader.UV_SCALING = new Vector2(1, 1);
OBJFileLoader.SKIP_MATERIALS = false;
OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;
OBJFileLoader.USE_LEGACY_BEHAVIOR = false;
RegisterSceneLoaderPlugin(new OBJFileLoader());

// node_modules/@babylonjs/loaders/STL/stlFileLoader.metadata.js
var STLFileLoaderMetadata = {
  name: "stl",
  extensions: {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".stl": { isBinary: true }
  }
};

// node_modules/@babylonjs/loaders/STL/stlFileLoader.js
var STLFileLoader = class _STLFileLoader {
  constructor() {
    this.solidPattern = /solid (\S*)([\S\s]*?)endsolid[ ]*(\S*)/g;
    this.facetsPattern = /facet([\s\S]*?)endfacet/g;
    this.normalPattern = /normal[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
    this.vertexPattern = /vertex[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
    this.name = STLFileLoaderMetadata.name;
    this.extensions = STLFileLoaderMetadata.extensions;
  }
  /**
   * Import meshes into a scene.
   * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
   * @param scene The scene to import into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @param meshes The meshes array to import into
   * @returns True if successful or false otherwise
   */
  importMesh(meshesNames, scene, data, rootUrl, meshes) {
    let matches;
    if (typeof data !== "string") {
      if (this._isBinary(data)) {
        const babylonMesh = new Mesh("stlmesh", scene);
        this._parseBinary(babylonMesh, data);
        if (meshes) {
          meshes.push(babylonMesh);
        }
        return true;
      }
      data = new TextDecoder().decode(new Uint8Array(data));
    }
    while (matches = this.solidPattern.exec(data)) {
      let meshName = matches[1];
      const meshNameFromEnd = matches[3];
      if (meshNameFromEnd && meshName != meshNameFromEnd) {
        Tools.Error("Error in STL, solid name != endsolid name");
        return false;
      }
      if (meshesNames && meshName) {
        if (meshesNames instanceof Array) {
          if (!meshesNames.indexOf(meshName)) {
            continue;
          }
        } else {
          if (meshName !== meshesNames) {
            continue;
          }
        }
      }
      meshName = meshName || "stlmesh";
      const babylonMesh = new Mesh(meshName, scene);
      this._parseASCII(babylonMesh, matches[2]);
      if (meshes) {
        meshes.push(babylonMesh);
      }
    }
    return true;
  }
  /**
   * Load into a scene.
   * @param scene The scene to load into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @returns true if successful or false otherwise
   */
  load(scene, data, rootUrl) {
    const result = this.importMesh(null, scene, data, rootUrl, null);
    return result;
  }
  /**
   * Load into an asset container.
   * @param scene The scene to load into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @returns The loaded asset container
   */
  loadAssetContainer(scene, data, rootUrl) {
    const container = new AssetContainer(scene);
    scene._blockEntityCollection = true;
    this.importMesh(null, scene, data, rootUrl, container.meshes);
    scene._blockEntityCollection = false;
    return container;
  }
  _isBinary(data) {
    const reader = new DataView(data);
    if (reader.byteLength <= 80) {
      return false;
    }
    const faceSize = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
    const nFaces = reader.getUint32(80, true);
    if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {
      return true;
    }
    const ascii = [115, 111, 108, 105, 100];
    for (let off = 0; off < 5; off++) {
      if (reader.getUint8(off) !== ascii[off]) {
        return true;
      }
    }
    return false;
  }
  _parseBinary(mesh, data) {
    const reader = new DataView(data);
    const faces = reader.getUint32(80, true);
    const dataOffset = 84;
    const faceLength = 12 * 4 + 2;
    let offset = 0;
    const positions = new Float32Array(faces * 3 * 3);
    const normals = new Float32Array(faces * 3 * 3);
    const indices = new Uint32Array(faces * 3);
    let indicesCount = 0;
    for (let face = 0; face < faces; face++) {
      const start = dataOffset + face * faceLength;
      const normalX = reader.getFloat32(start, true);
      const normalY = reader.getFloat32(start + 4, true);
      const normalZ = reader.getFloat32(start + 8, true);
      for (let i = 1; i <= 3; i++) {
        const vertexstart = start + i * 12;
        positions[offset] = reader.getFloat32(vertexstart, true);
        normals[offset] = normalX;
        if (!_STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
          positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);
          positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);
          normals[offset + 2] = normalY;
          normals[offset + 1] = normalZ;
        } else {
          positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);
          positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);
          normals[offset + 1] = normalY;
          normals[offset + 2] = normalZ;
        }
        offset += 3;
      }
      if (_STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
        indices[indicesCount] = indicesCount;
        indices[indicesCount + 1] = indicesCount + 2;
        indices[indicesCount + 2] = indicesCount + 1;
        indicesCount += 3;
      } else {
        indices[indicesCount] = indicesCount++;
        indices[indicesCount] = indicesCount++;
        indices[indicesCount] = indicesCount++;
      }
    }
    mesh.setVerticesData(VertexBuffer.PositionKind, positions);
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
    mesh.setIndices(indices);
    mesh.computeWorldMatrix(true);
  }
  _parseASCII(mesh, solidData) {
    const positions = [];
    const normals = [];
    const indices = [];
    let indicesCount = 0;
    let matches;
    while (matches = this.facetsPattern.exec(solidData)) {
      const facet = matches[1];
      const normalMatches = this.normalPattern.exec(facet);
      this.normalPattern.lastIndex = 0;
      if (!normalMatches) {
        continue;
      }
      const normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];
      let vertexMatch;
      while (vertexMatch = this.vertexPattern.exec(facet)) {
        if (!_STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
          positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));
          normals.push(normal[0], normal[1], normal[2]);
        } else {
          positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));
          normals.push(normal[0], normal[2], normal[1]);
        }
      }
      if (_STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
        indices.push(indicesCount, indicesCount + 2, indicesCount + 1);
        indicesCount += 3;
      } else {
        indices.push(indicesCount++, indicesCount++, indicesCount++);
      }
      this.vertexPattern.lastIndex = 0;
    }
    this.facetsPattern.lastIndex = 0;
    mesh.setVerticesData(VertexBuffer.PositionKind, positions);
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
    mesh.setIndices(indices);
    mesh.computeWorldMatrix(true);
  }
};
STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES = false;
RegisterSceneLoaderPlugin(new STLFileLoader());

// node_modules/@babylonjs/loaders/SPLAT/splatFileLoader.metadata.js
var SPLATFileLoaderMetadata = {
  name: "splat",
  extensions: {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".splat": { isBinary: true },
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".ply": { isBinary: true },
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".spz": { isBinary: true }
  }
};

// node_modules/@babylonjs/loaders/SPLAT/splatFileLoader.js
var Mode;
(function(Mode2) {
  Mode2[Mode2["Splat"] = 0] = "Splat";
  Mode2[Mode2["PointCloud"] = 1] = "PointCloud";
  Mode2[Mode2["Mesh"] = 2] = "Mesh";
  Mode2[Mode2["Reject"] = 3] = "Reject";
})(Mode || (Mode = {}));
var SPLATFileLoader = class _SPLATFileLoader {
  /**
   * Creates loader for gaussian splatting files
   * @param loadingOptions options for loading and parsing splat and PLY files.
   */
  constructor(loadingOptions = _SPLATFileLoader._DefaultLoadingOptions) {
    this.name = SPLATFileLoaderMetadata.name;
    this._assetContainer = null;
    this.extensions = SPLATFileLoaderMetadata.extensions;
    this._loadingOptions = loadingOptions;
  }
  /** @internal */
  createPlugin(options) {
    return new _SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);
  }
  /**
   * Imports  from the loaded gaussian splatting data and adds them to the scene
   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
   * @param scene the scene the meshes should be added to
   * @param data the gaussian splatting data to load
   * @param rootUrl root url to load from
   * @param onProgress callback called while file is loading
   * @param fileName Defines the name of the file to load
   * @returns a promise containing the loaded meshes, particles, skeletons and animations
   */
  async importMeshAsync(meshesNames, scene, data, rootUrl, onProgress, fileName) {
    return this._parse(meshesNames, scene, data, rootUrl).then((meshes) => {
      return {
        meshes,
        particleSystems: [],
        skeletons: [],
        animationGroups: [],
        transformNodes: [],
        geometries: [],
        lights: [],
        spriteManagers: []
      };
    });
  }
  static _BuildPointCloud(pointcloud, data) {
    if (!data.byteLength) {
      return false;
    }
    const uBuffer = new Uint8Array(data);
    const fBuffer = new Float32Array(data);
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const vertexCount = uBuffer.length / rowLength;
    const pointcloudfunc = function(particle, i) {
      const x = fBuffer[8 * i + 0];
      const y = fBuffer[8 * i + 1];
      const z = fBuffer[8 * i + 2];
      particle.position = new Vector3(x, y, z);
      const r = uBuffer[rowLength * i + 24 + 0] / 255;
      const g = uBuffer[rowLength * i + 24 + 1] / 255;
      const b = uBuffer[rowLength * i + 24 + 2] / 255;
      particle.color = new Color4(r, g, b, 1);
    };
    pointcloud.addPoints(vertexCount, pointcloudfunc);
    return true;
  }
  static _BuildMesh(scene, parsedPLY) {
    const mesh = new Mesh("PLYMesh", scene);
    const uBuffer = new Uint8Array(parsedPLY.data);
    const fBuffer = new Float32Array(parsedPLY.data);
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const vertexCount = uBuffer.length / rowLength;
    const positions = [];
    const vertexData = new VertexData();
    for (let i = 0; i < vertexCount; i++) {
      const x = fBuffer[8 * i + 0];
      const y = fBuffer[8 * i + 1];
      const z = fBuffer[8 * i + 2];
      positions.push(x, y, z);
    }
    if (parsedPLY.hasVertexColors) {
      const colors = new Float32Array(vertexCount * 4);
      for (let i = 0; i < vertexCount; i++) {
        const r = uBuffer[rowLength * i + 24 + 0] / 255;
        const g = uBuffer[rowLength * i + 24 + 1] / 255;
        const b = uBuffer[rowLength * i + 24 + 2] / 255;
        colors[i * 4 + 0] = r;
        colors[i * 4 + 1] = g;
        colors[i * 4 + 2] = b;
        colors[i * 4 + 3] = 1;
      }
      vertexData.colors = colors;
    }
    vertexData.positions = positions;
    vertexData.indices = parsedPLY.faces;
    vertexData.applyToMesh(mesh);
    return mesh;
  }
  _parseSPZ(data, scene) {
    const ubuf = new Uint8Array(data);
    const ubufu32 = new Uint32Array(data);
    const splatCount = ubufu32[2];
    const shDegree = ubuf[12];
    const fractionalBits = ubuf[13];
    const reserved = ubuf[15];
    if (reserved || ubufu32[0] != 1347635022 || ubufu32[1] != 2) {
      return new Promise((resolve) => {
        resolve({ mode: 3, data: buffer, hasVertexColors: false });
      });
    }
    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4;
    const buffer = new ArrayBuffer(rowOutputLength * splatCount);
    const positionScale = 1 / (1 << fractionalBits);
    const int32View = new Int32Array(1);
    const uint8View = new Uint8Array(int32View.buffer);
    const read24bComponent = function(u8, offset) {
      uint8View[0] = u8[offset + 0];
      uint8View[1] = u8[offset + 1];
      uint8View[2] = u8[offset + 2];
      uint8View[3] = u8[offset + 2] & 128 ? 255 : 0;
      return int32View[0] * positionScale;
    };
    let byteOffset = 16;
    const position = new Float32Array(buffer);
    const scale = new Float32Array(buffer);
    const rgba = new Uint8ClampedArray(buffer);
    const rot = new Uint8ClampedArray(buffer);
    let coordinateSign = 1;
    let quaternionOffset = 0;
    if (!this._loadingOptions.flipY) {
      coordinateSign = -1;
      quaternionOffset = 255;
    }
    for (let i = 0; i < splatCount; i++) {
      position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);
      position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);
      position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);
      byteOffset += 9;
    }
    const SH_C0 = 0.282;
    for (let i = 0; i < splatCount; i++) {
      for (let component = 0; component < 3; component++) {
        const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];
        const value = (byteValue - 127.5) / (0.15 * 255);
        rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + SH_C0 * value) * 255, 0, 255);
      }
      rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];
    }
    byteOffset += splatCount * 4;
    for (let i = 0; i < splatCount; i++) {
      scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16 - 10);
      scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16 - 10);
      scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16 - 10);
      byteOffset += 3;
    }
    for (let i = 0; i < splatCount; i++) {
      const x = ubuf[byteOffset + 0];
      const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;
      const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;
      const nx = x / 127.5 - 1;
      const ny = y / 127.5 - 1;
      const nz = z / 127.5 - 1;
      rot[i * 32 + 28 + 1] = x;
      rot[i * 32 + 28 + 2] = y;
      rot[i * 32 + 28 + 3] = z;
      const v = 1 - (nx * nx + ny * ny + nz * nz);
      rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;
      byteOffset += 3;
    }
    if (shDegree) {
      const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;
      const shComponentCount = shVectorCount * 3;
      const textureCount = Math.ceil(shComponentCount / 16);
      let shIndexRead = byteOffset;
      const sh = [];
      const engine = scene.getEngine();
      const width = engine.getCaps().maxTextureSize;
      const height = Math.ceil(splatCount / width);
      for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {
        const texture = new Uint8Array(height * width * 4 * 4);
        sh.push(texture);
      }
      for (let i = 0; i < splatCount; i++) {
        for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {
          const shValue = ubuf[shIndexRead++];
          const textureIndex = Math.floor(shIndexWrite / 16);
          const shArray = sh[textureIndex];
          const byteIndexInTexture = shIndexWrite % 16;
          const offsetPerSplat = i * 16;
          shArray[byteIndexInTexture + offsetPerSplat] = shValue;
        }
      }
      return new Promise((resolve) => {
        resolve({ mode: 0, data: buffer, hasVertexColors: false, sh });
      });
    }
    return new Promise((resolve) => {
      resolve({ mode: 0, data: buffer, hasVertexColors: false });
    });
  }
  _parse(meshesNames, scene, data, rootUrl) {
    const babylonMeshesArray = [];
    const readableStream = new ReadableStream({
      start(controller) {
        controller.enqueue(new Uint8Array(data));
        controller.close();
      }
    });
    const decompressionStream = new DecompressionStream("gzip");
    const decompressedStream = readableStream.pipeThrough(decompressionStream);
    return new Promise((resolve) => {
      new Response(decompressedStream).arrayBuffer().then((buffer) => {
        this._parseSPZ(buffer, scene).then((parsedSPZ) => {
          const gaussianSplatting = new GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
          gaussianSplatting._parentContainer = this._assetContainer;
          babylonMeshesArray.push(gaussianSplatting);
          gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);
        });
        resolve(babylonMeshesArray);
      }).catch(() => {
        _SPLATFileLoader._ConvertPLYToSplat(data).then(async (parsedPLY) => {
          switch (parsedPLY.mode) {
            case 0:
              {
                const gaussianSplatting = new GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
                gaussianSplatting._parentContainer = this._assetContainer;
                babylonMeshesArray.push(gaussianSplatting);
                gaussianSplatting.updateData(parsedPLY.data);
              }
              break;
            case 1:
              {
                const pointcloud = new PointsCloudSystem("PointCloud", 1, scene);
                if (_SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {
                  await pointcloud.buildMeshAsync().then((mesh) => {
                    babylonMeshesArray.push(mesh);
                  });
                } else {
                  pointcloud.dispose();
                }
              }
              break;
            case 2:
              {
                if (parsedPLY.faces) {
                  babylonMeshesArray.push(_SPLATFileLoader._BuildMesh(scene, parsedPLY));
                } else {
                  throw new Error("PLY mesh doesn't contain face informations.");
                }
              }
              break;
            default:
              throw new Error("Unsupported Splat mode");
          }
          resolve(babylonMeshesArray);
        });
      });
    });
  }
  /**
   * Load into an asset container.
   * @param scene The scene to load into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @returns The loaded asset container
   */
  loadAssetContainerAsync(scene, data, rootUrl) {
    const container = new AssetContainer(scene);
    this._assetContainer = container;
    return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {
      result.meshes.forEach((mesh) => container.meshes.push(mesh));
      this._assetContainer = null;
      return container;
    }).catch((ex) => {
      this._assetContainer = null;
      throw ex;
    });
  }
  /**
   * Imports all objects from the loaded OBJ data and adds them to the scene
   * @param scene the scene the objects should be added to
   * @param data the OBJ data to load
   * @param rootUrl root url to load from
   * @returns a promise which completes when objects have been loaded to the scene
   */
  loadAsync(scene, data, rootUrl) {
    return this.importMeshAsync(null, scene, data, rootUrl).then(() => {
    });
  }
  /**
   * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license
   * Converts a .ply data array buffer to splat
   * if data array buffer is not ply, returns the original buffer
   * @param data the .ply data to load
   * @returns the loaded splat buffer
   */
  static _ConvertPLYToSplat(data) {
    const ubuf = new Uint8Array(data);
    const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
    const headerEnd = "end_header\n";
    const headerEndIndex = header.indexOf(headerEnd);
    if (headerEndIndex < 0 || !header) {
      return new Promise((resolve) => {
        resolve({ mode: 0, data });
      });
    }
    const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
    const faceElement = /element face (\d+)\n/.exec(header);
    let faceCount = 0;
    if (faceElement) {
      faceCount = parseInt(faceElement[1]);
    }
    const chunkElement = /element chunk (\d+)\n/.exec(header);
    let chunkCount = 0;
    if (chunkElement) {
      chunkCount = parseInt(chunkElement[1]);
    }
    let rowVertexOffset = 0;
    let rowChunkOffset = 0;
    const offsets = {
      double: 8,
      int: 4,
      uint: 4,
      float: 4,
      short: 2,
      ushort: 2,
      uchar: 1,
      list: 0
    };
    let ElementMode;
    (function(ElementMode2) {
      ElementMode2[ElementMode2["Vertex"] = 0] = "Vertex";
      ElementMode2[ElementMode2["Chunk"] = 1] = "Chunk";
    })(ElementMode || (ElementMode = {}));
    let chunkMode = 1;
    const vertexProperties = [];
    const chunkProperties = [];
    const filtered = header.slice(0, headerEndIndex).split("\n");
    for (const prop of filtered) {
      if (prop.startsWith("property ")) {
        const [, type, name] = prop.split(" ");
        if (chunkMode == 1) {
          chunkProperties.push({ name, type, offset: rowChunkOffset });
          rowChunkOffset += offsets[type];
        } else if (chunkMode == 0) {
          vertexProperties.push({ name, type, offset: rowVertexOffset });
          rowVertexOffset += offsets[type];
        }
        if (!offsets[type]) {
          Logger.Warn(`Unsupported property type: ${type}.`);
        }
      } else if (prop.startsWith("element ")) {
        const [, type] = prop.split(" ");
        if (type == "chunk") {
          chunkMode = 1;
        } else if (type == "vertex") {
          chunkMode = 0;
        }
      }
    }
    const rowVertexLength = rowVertexOffset;
    const rowChunkLength = rowChunkOffset;
    return GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then((splatsData) => {
      const dataView = new DataView(data, headerEndIndex + headerEnd.length);
      let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;
      const faces = [];
      if (faceCount) {
        for (let i = 0; i < faceCount; i++) {
          const faceVertexCount = dataView.getUint8(offset);
          if (faceVertexCount != 3) {
            continue;
          }
          offset += 1;
          for (let j = 0; j < faceVertexCount; j++) {
            const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true);
            faces.push(vertexIndex);
          }
          offset += 12;
        }
      }
      if (chunkCount) {
        return new Promise((resolve) => {
          resolve({ mode: 0, data: splatsData.buffer, sh: splatsData.sh, faces, hasVertexColors: false });
        });
      }
      let propertyCount = 0;
      let propertyColorCount = 0;
      const splatProperties = ["x", "y", "z", "scale_0", "scale_1", "scale_2", "opacity", "rot_0", "rot_1", "rot_2", "rot_3"];
      const splatColorProperties = ["red", "green", "blue", "f_dc_0", "f_dc_1", "f_dc_2"];
      for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {
        const property = vertexProperties[propertyIndex];
        if (splatProperties.includes(property.name)) {
          propertyCount++;
        }
        if (splatColorProperties.includes(property.name)) {
          propertyColorCount++;
        }
      }
      const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;
      const currentMode = faceCount ? 2 : hasMandatoryProperties ? 0 : 1;
      return new Promise((resolve) => {
        resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces, hasVertexColors: !!propertyColorCount });
      });
    });
  }
};
SPLATFileLoader._DefaultLoadingOptions = {
  keepInRam: false,
  flipY: false
};
RegisterSceneLoaderPlugin(new SPLATFileLoader());
export {
  __exports as GLTF1,
  __exports2 as GLTF2,
  GLTFFileLoader,
  GLTFLoaderAnimationStartMode,
  GLTFLoaderCoordinateSystemMode,
  GLTFLoaderState,
  GLTFValidation,
  MTLFileLoader,
  OBJFileLoader,
  SPLATFileLoader,
  STLFileLoader,
  SolidParser
};
//# sourceMappingURL=@babylonjs_loaders.js.map
