import {
  Animation
} from "./chunk-ZGJ7GRVA.js";
import {
  AbstractActionManager
} from "./chunk-36UZTWIQ.js";
import {
  Color3,
  Color4
} from "./chunk-QJYZAU53.js";
import {
  Matrix,
  Quaternion,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-3LKPOCHD.js";
import {
  DeepCopier
} from "./chunk-QPP7FIQR.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import {
  EngineStore,
  Observable
} from "./chunk-6QZ75BYX.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";

// node_modules/@babylonjs/core/Actions/action.js
var Action = class {
  /**
   * Creates a new Action
   * @param triggerOptions the trigger, with or without parameters, for the action
   * @param condition an optional determinant of action
   */
  constructor(triggerOptions, condition) {
    this.triggerOptions = triggerOptions;
    this.onBeforeExecuteObservable = new Observable();
    if (triggerOptions.parameter) {
      this.trigger = triggerOptions.trigger;
      this._triggerParameter = triggerOptions.parameter;
    } else if (triggerOptions.trigger) {
      this.trigger = triggerOptions.trigger;
    } else {
      this.trigger = triggerOptions;
    }
    this._nextActiveAction = this;
    this._condition = condition;
  }
  /**
   * Internal only
   * @internal
   */
  _prepare() {
  }
  /**
   * Gets the trigger parameter
   * @returns the trigger parameter
   */
  getTriggerParameter() {
    return this._triggerParameter;
  }
  /**
   * Sets the trigger parameter
   * @param value defines the new trigger parameter
   */
  setTriggerParameter(value) {
    this._triggerParameter = value;
  }
  /**
   * Internal only - Returns if the current condition allows to run the action
   * @internal
   */
  _evaluateConditionForCurrentFrame() {
    const condition = this._condition;
    if (!condition) {
      return true;
    }
    const currentRenderId = this._actionManager.getScene().getRenderId();
    if (condition._evaluationId !== currentRenderId) {
      condition._evaluationId = currentRenderId;
      condition._currentResult = condition.isValid();
    }
    return condition._currentResult;
  }
  /**
   * Internal only - executes current action event
   * @internal
   */
  _executeCurrent(evt) {
    const isConditionValid = this._evaluateConditionForCurrentFrame();
    if (!isConditionValid) {
      return;
    }
    this.onBeforeExecuteObservable.notifyObservers(this);
    this._nextActiveAction.execute(evt);
    this.skipToNextActiveAction();
  }
  /**
   * Execute placeholder for child classes
   * @param evt optional action event
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  execute(evt) {
  }
  /**
   * Skips to next active action
   */
  skipToNextActiveAction() {
    if (this._nextActiveAction._child) {
      if (!this._nextActiveAction._child._actionManager) {
        this._nextActiveAction._child._actionManager = this._actionManager;
      }
      this._nextActiveAction = this._nextActiveAction._child;
    } else {
      this._nextActiveAction = this;
    }
  }
  /**
   * Adds action to chain of actions, may be a DoNothingAction
   * @param action defines the next action to execute
   * @returns The action passed in
   * @see https://www.babylonjs-playground.com/#1T30HR#0
   */
  then(action) {
    this._child = action;
    action._actionManager = this._actionManager;
    action._prepare();
    return action;
  }
  /**
   * Internal only
   * @internal
   */
  _getProperty(propertyPath) {
    return this._actionManager._getProperty(propertyPath);
  }
  /**
   * @internal
   */
  _getEffectiveTarget(target, propertyPath) {
    return this._actionManager._getEffectiveTarget(target, propertyPath);
  }
  /**
   * Serialize placeholder for child classes
   * @param parent of child
   * @returns the serialized object
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  serialize(parent) {
    return null;
  }
  /**
   * Internal only called by serialize
   * @internal
   */
  _serialize(serializedAction, parent) {
    const serializationObject = {
      type: 1,
      children: [],
      name: serializedAction.name,
      properties: serializedAction.properties || []
    };
    if (this._child) {
      this._child.serialize(serializationObject);
    }
    if (this._condition) {
      const serializedCondition = this._condition.serialize();
      serializedCondition.children.push(serializationObject);
      if (parent) {
        parent.children.push(serializedCondition);
      }
      return serializedCondition;
    }
    if (parent) {
      parent.children.push(serializationObject);
    }
    return serializationObject;
  }
};
Action._SerializeValueAsString = (value) => {
  if (typeof value === "number") {
    return value.toString();
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  if (value instanceof Vector2) {
    return value.x + ", " + value.y;
  }
  if (value instanceof Vector3) {
    return value.x + ", " + value.y + ", " + value.z;
  }
  if (value instanceof Color3) {
    return value.r + ", " + value.g + ", " + value.b;
  }
  if (value instanceof Color4) {
    return value.r + ", " + value.g + ", " + value.b + ", " + value.a;
  }
  return value;
};
Action._GetTargetProperty = (target) => {
  return {
    name: "target",
    targetType: target._isMesh ? "MeshProperties" : target._isLight ? "LightProperties" : target._isCamera ? "CameraProperties" : target._isMaterial ? "MaterialProperties" : "SceneProperties",
    value: target._isScene ? "Scene" : target.name
  };
};
RegisterClass("BABYLON.Action", Action);

// node_modules/@babylonjs/core/Actions/condition.js
var Condition = class {
  /**
   * Creates a new Condition
   * @param actionManager the manager of the action the condition is applied to
   */
  constructor(actionManager) {
    this._actionManager = actionManager;
  }
  /**
   * Check if the current condition is valid
   * @returns a boolean
   */
  isValid() {
    return true;
  }
  /**
   * @internal
   */
  _getProperty(propertyPath) {
    return this._actionManager._getProperty(propertyPath);
  }
  /**
   * @internal
   */
  _getEffectiveTarget(target, propertyPath) {
    return this._actionManager._getEffectiveTarget(target, propertyPath);
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Serialize placeholder for child classes
   * @returns the serialized object
   */
  serialize() {
  }
  /**
   * @internal
   */
  _serialize(serializedCondition) {
    return {
      type: 2,
      // Condition
      children: [],
      name: serializedCondition.name,
      properties: serializedCondition.properties
    };
  }
};
var ValueCondition = class _ValueCondition extends Condition {
  /**
   * returns the number for IsEqual
   */
  static get IsEqual() {
    return _ValueCondition._IsEqual;
  }
  /**
   * Returns the number for IsDifferent
   */
  static get IsDifferent() {
    return _ValueCondition._IsDifferent;
  }
  /**
   * Returns the number for IsGreater
   */
  static get IsGreater() {
    return _ValueCondition._IsGreater;
  }
  /**
   * Returns the number for IsLesser
   */
  static get IsLesser() {
    return _ValueCondition._IsLesser;
  }
  /**
   * Creates a new ValueCondition
   * @param actionManager manager for the action the condition applies to
   * @param target for the action
   * @param propertyPath path to specify the property of the target the conditional operator uses
   * @param value the value compared by the conditional operator against the current value of the property
   * @param operator the conditional operator, default ValueCondition.IsEqual
   */
  constructor(actionManager, target, propertyPath, value, operator = _ValueCondition.IsEqual) {
    super(actionManager);
    this.propertyPath = propertyPath;
    this.value = value;
    this.operator = operator;
    this._target = target;
    this._effectiveTarget = this._getEffectiveTarget(target, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  /**
   * Compares the given value with the property value for the specified conditional operator
   * @returns the result of the comparison
   */
  isValid() {
    switch (this.operator) {
      case _ValueCondition.IsGreater:
        return this._effectiveTarget[this._property] > this.value;
      case _ValueCondition.IsLesser:
        return this._effectiveTarget[this._property] < this.value;
      case _ValueCondition.IsEqual:
      case _ValueCondition.IsDifferent: {
        let check;
        if (this.value.equals) {
          check = this.value.equals(this._effectiveTarget[this._property]);
        } else {
          check = this.value === this._effectiveTarget[this._property];
        }
        return this.operator === _ValueCondition.IsEqual ? check : !check;
      }
    }
    return false;
  }
  /**
   * Serialize the ValueCondition into a JSON compatible object
   * @returns serialization object
   */
  serialize() {
    return this._serialize({
      name: "ValueCondition",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) },
        { name: "operator", value: _ValueCondition.GetOperatorName(this.operator) }
      ]
    });
  }
  /**
   * Gets the name of the conditional operator for the ValueCondition
   * @param operator the conditional operator
   * @returns the name
   */
  static GetOperatorName(operator) {
    switch (operator) {
      case _ValueCondition._IsEqual:
        return "IsEqual";
      case _ValueCondition._IsDifferent:
        return "IsDifferent";
      case _ValueCondition._IsGreater:
        return "IsGreater";
      case _ValueCondition._IsLesser:
        return "IsLesser";
      default:
        return "";
    }
  }
};
ValueCondition._IsEqual = 0;
ValueCondition._IsDifferent = 1;
ValueCondition._IsGreater = 2;
ValueCondition._IsLesser = 3;
var PredicateCondition = class extends Condition {
  /**
   * Creates a new PredicateCondition
   * @param actionManager manager for the action the condition applies to
   * @param predicate defines the predicate function used to validate the condition
   */
  constructor(actionManager, predicate) {
    super(actionManager);
    this.predicate = predicate;
  }
  /**
   * @returns the validity of the predicate condition
   */
  isValid() {
    return this.predicate();
  }
};
var StateCondition = class extends Condition {
  /**
   * Creates a new StateCondition
   * @param actionManager manager for the action the condition applies to
   * @param target of the condition
   * @param value to compare with target state
   */
  constructor(actionManager, target, value) {
    super(actionManager);
    this.value = value;
    this._target = target;
  }
  /**
   * Gets a boolean indicating if the current condition is met
   * @returns the validity of the state
   */
  isValid() {
    return this._target.state === this.value;
  }
  /**
   * Serialize the StateCondition into a JSON compatible object
   * @returns serialization object
   */
  serialize() {
    return this._serialize({
      name: "StateCondition",
      properties: [Action._GetTargetProperty(this._target), { name: "value", value: this.value }]
    });
  }
};
RegisterClass("BABYLON.ValueCondition", ValueCondition);
RegisterClass("BABYLON.PredicateCondition", PredicateCondition);
RegisterClass("BABYLON.StateCondition", StateCondition);

// node_modules/@babylonjs/core/Actions/directActions.js
var SwitchBooleanAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the boolean
   * @param propertyPath defines the path to the boolean property in the target object
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, propertyPath, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this._target = this._effectiveTarget = target;
  }
  /** @internal */
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  /**
   * Execute the action toggle the boolean value.
   */
  execute() {
    this._effectiveTarget[this._property] = !this._effectiveTarget[this._property];
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "SwitchBooleanAction",
      properties: [Action._GetTargetProperty(this._target), { name: "propertyPath", value: this.propertyPath }]
    }, parent);
  }
};
var SetStateAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the state property
   * @param value defines the value to store in the state field
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, value, condition) {
    super(triggerOptions, condition);
    this.value = value;
    this._target = target;
  }
  /**
   * Execute the action and store the value on the target state property.
   */
  execute() {
    this._target.state = this.value;
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "SetStateAction",
      properties: [Action._GetTargetProperty(this._target), { name: "value", value: this.value }]
    }, parent);
  }
};
var SetValueAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the property
   * @param propertyPath defines the path of the property to set in the target
   * @param value defines the value to set in the property
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, propertyPath, value, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this.value = value;
    this._target = this._effectiveTarget = target;
  }
  /** @internal */
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  /**
   * Execute the action and set the targeted property to the desired value.
   */
  execute() {
    this._effectiveTarget[this._property] = this.value;
    if (this._target.markAsDirty) {
      this._target.markAsDirty(this._property);
    }
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "SetValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) }
      ]
    }, parent);
  }
};
var IncrementValueAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the property
   * @param propertyPath defines the path of the property to increment in the target
   * @param value defines the value value we should increment the property by
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, propertyPath, value, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this.value = value;
    this._target = this._effectiveTarget = target;
  }
  /** @internal */
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
    if (typeof this._effectiveTarget[this._property] !== "number") {
      Logger.Warn("Warning: IncrementValueAction can only be used with number values");
    }
  }
  /**
   * Execute the action and increment the target of the value amount.
   */
  execute() {
    this._effectiveTarget[this._property] += this.value;
    if (this._target.markAsDirty) {
      this._target.markAsDirty(this._property);
    }
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "IncrementValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) }
      ]
    }, parent);
  }
};
var PlayAnimationAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the target animation or animation name
   * @param from defines from where the animation should start (animation frame)
   * @param to defines where the animation should stop (animation frame)
   * @param loop defines if the animation should loop or stop after the first play
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, from, to, loop, condition) {
    super(triggerOptions, condition);
    this.from = from;
    this.to = to;
    this.loop = loop;
    this._target = target;
  }
  /** @internal */
  _prepare() {
  }
  /**
   * Execute the action and play the animation.
   */
  execute() {
    const scene = this._actionManager.getScene();
    scene.beginAnimation(this._target, this.from, this.to, this.loop);
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "PlayAnimationAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "from", value: String(this.from) },
        { name: "to", value: String(this.to) },
        { name: "loop", value: Action._SerializeValueAsString(this.loop) || false }
      ]
    }, parent);
  }
};
var StopAnimationAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the target animation or animation name
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, condition) {
    super(triggerOptions, condition);
    this._target = target;
  }
  /** @internal */
  _prepare() {
  }
  /**
   * Execute the action and stop the animation.
   */
  execute() {
    const scene = this._actionManager.getScene();
    scene.stopAnimation(this._target);
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "StopAnimationAction",
      properties: [Action._GetTargetProperty(this._target)]
    }, parent);
  }
};
var DoNothingAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions = 0, condition) {
    super(triggerOptions, condition);
  }
  /**
   * Execute the action and do nothing.
   */
  execute() {
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "DoNothingAction",
      properties: []
    }, parent);
  }
};
var CombineAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param children defines the list of aggregated animations to run
   * @param condition defines the trigger related conditions
   * @param enableChildrenConditions defines if the children actions conditions should be check before execution
   */
  constructor(triggerOptions, children, condition, enableChildrenConditions = true) {
    super(triggerOptions, condition);
    this.children = children;
    this.enableChildrenConditions = enableChildrenConditions;
  }
  /** @internal */
  _prepare() {
    for (let index = 0; index < this.children.length; index++) {
      this.children[index]._actionManager = this._actionManager;
      this.children[index]._prepare();
    }
  }
  /**
   * Execute the action and executes all the aggregated actions.
   * @param evt event to execute
   */
  execute(evt) {
    for (const action of this.children) {
      if (!this.enableChildrenConditions || action._evaluateConditionForCurrentFrame()) {
        action.execute(evt);
      }
    }
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    const serializationObject = super._serialize({
      name: "CombineAction",
      properties: [],
      combine: []
    }, parent);
    for (let i = 0; i < this.children.length; i++) {
      serializationObject.combine.push(this.children[i].serialize(null));
    }
    return serializationObject;
  }
};
var ExecuteCodeAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param func defines the callback function to run
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, func, condition) {
    super(triggerOptions, condition);
    this.func = func;
  }
  /**
   * Execute the action and run the attached code.
   * @param evt event to execute
   */
  execute(evt) {
    this.func(evt);
  }
};
var SetParentAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the target containing the parent property
   * @param parent defines from where the animation should start (animation frame)
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, parent, condition) {
    super(triggerOptions, condition);
    this._target = target;
    this._parent = parent;
  }
  /** @internal */
  _prepare() {
  }
  /**
   * Execute the action and set the parent property.
   */
  execute() {
    if (this._target.parent === this._parent) {
      return;
    }
    const invertParentWorldMatrix = this._parent.getWorldMatrix().clone();
    invertParentWorldMatrix.invert();
    this._target.position = Vector3.TransformCoordinates(this._target.position, invertParentWorldMatrix);
    this._target.parent = this._parent;
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "SetParentAction",
      properties: [Action._GetTargetProperty(this._target), Action._GetTargetProperty(this._parent)]
    }, parent);
  }
};
RegisterClass("BABYLON.SetParentAction", SetParentAction);
RegisterClass("BABYLON.ExecuteCodeAction", ExecuteCodeAction);
RegisterClass("BABYLON.DoNothingAction", DoNothingAction);
RegisterClass("BABYLON.StopAnimationAction", StopAnimationAction);
RegisterClass("BABYLON.PlayAnimationAction", PlayAnimationAction);
RegisterClass("BABYLON.IncrementValueAction", IncrementValueAction);
RegisterClass("BABYLON.SetValueAction", SetValueAction);
RegisterClass("BABYLON.SetStateAction", SetStateAction);
RegisterClass("BABYLON.SetParentAction", SetParentAction);
RegisterClass("BABYLON.SwitchBooleanAction", SwitchBooleanAction);
RegisterClass("BABYLON.CombineAction", CombineAction);

// node_modules/@babylonjs/core/Actions/actionManager.js
var ActionManager = class _ActionManager extends AbstractActionManager {
  /**
   * Creates a new action manager
   * @param scene defines the hosting scene
   */
  constructor(scene) {
    super();
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this._scene = scene;
    scene.actionManagers.push(this);
  }
  // Methods
  /**
   * Releases all associated resources
   */
  dispose() {
    const sceneIndex = this._scene.actionManagers.indexOf(this);
    for (let i = 0; i < this.actions.length; i++) {
      const action = this.actions[i];
      _ActionManager.Triggers[action.trigger]--;
      if (_ActionManager.Triggers[action.trigger] === 0) {
        delete _ActionManager.Triggers[action.trigger];
      }
    }
    this.actions.length = 0;
    if (sceneIndex > -1) {
      this._scene.actionManagers.splice(sceneIndex, 1);
    }
    const ownerMeshes = this._scene.meshes.filter((m) => m.actionManager === this);
    for (const ownerMesh of ownerMeshes) {
      ownerMesh.actionManager = null;
    }
  }
  /**
   * Gets hosting scene
   * @returns the hosting scene
   */
  getScene() {
    return this._scene;
  }
  /**
   * Does this action manager handles actions of any of the given triggers
   * @param triggers defines the triggers to be tested
   * @returns a boolean indicating whether one (or more) of the triggers is handled
   */
  hasSpecificTriggers(triggers) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (triggers.indexOf(action.trigger) > -1) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does this action manager handles actions of any of the given triggers. This function takes two arguments for
   * speed.
   * @param triggerA defines the trigger to be tested
   * @param triggerB defines the trigger to be tested
   * @returns a boolean indicating whether one (or more) of the triggers is handled
   */
  hasSpecificTriggers2(triggerA, triggerB) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (triggerA == action.trigger || triggerB == action.trigger) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does this action manager handles actions of a given trigger
   * @param trigger defines the trigger to be tested
   * @param parameterPredicate defines an optional predicate to filter triggers by parameter
   * @returns whether the trigger is handled
   */
  hasSpecificTrigger(trigger, parameterPredicate) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger === trigger) {
        if (parameterPredicate) {
          if (parameterPredicate(action.getTriggerParameter())) {
            return true;
          }
        } else {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Does this action manager has pointer triggers
   */
  get hasPointerTriggers() {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger >= _ActionManager.OnPickTrigger && action.trigger <= _ActionManager.OnPointerOutTrigger) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does this action manager has pick triggers
   */
  get hasPickTriggers() {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger >= _ActionManager.OnPickTrigger && action.trigger <= _ActionManager.OnPickUpTrigger) {
        return true;
      }
    }
    return false;
  }
  /**
   * Registers an action to this action manager
   * @param action defines the action to be registered
   * @returns the action amended (prepared) after registration
   */
  registerAction(action) {
    if (action.trigger === _ActionManager.OnEveryFrameTrigger) {
      if (this.getScene().actionManager !== this) {
        Logger.Warn("OnEveryFrameTrigger can only be used with scene.actionManager");
        return null;
      }
    }
    this.actions.push(action);
    this.getScene()._registeredActions++;
    if (_ActionManager.Triggers[action.trigger]) {
      _ActionManager.Triggers[action.trigger]++;
    } else {
      _ActionManager.Triggers[action.trigger] = 1;
    }
    action._actionManager = this;
    action._prepare();
    return action;
  }
  /**
   * Unregisters an action to this action manager
   * @param action defines the action to be unregistered
   * @returns a boolean indicating whether the action has been unregistered
   */
  unregisterAction(action) {
    const index = this.actions.indexOf(action);
    if (index !== -1) {
      this.actions.splice(index, 1);
      _ActionManager.Triggers[action.trigger] -= 1;
      if (_ActionManager.Triggers[action.trigger] === 0) {
        delete _ActionManager.Triggers[action.trigger];
      }
      action._actionManager = null;
      this.getScene()._registeredActions--;
      return true;
    }
    return false;
  }
  /**
   * Process a specific trigger
   * @param trigger defines the trigger to process
   * @param evt defines the event details to be processed
   */
  processTrigger(trigger, evt) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger === trigger) {
        if (evt) {
          if (trigger === _ActionManager.OnKeyUpTrigger || trigger === _ActionManager.OnKeyDownTrigger) {
            const parameter = action.getTriggerParameter();
            if (typeof parameter === "function") {
              if (!parameter(evt)) {
                continue;
              }
            } else if (parameter && parameter !== evt.sourceEvent.keyCode) {
              if (!parameter.toLowerCase) {
                continue;
              }
              const lowerCase = parameter.toLowerCase();
              if (lowerCase !== evt.sourceEvent.key) {
                const unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;
                const actualkey = String.fromCharCode(unicode).toLowerCase();
                if (actualkey !== lowerCase) {
                  continue;
                }
              }
            }
          }
        }
        action._executeCurrent(evt);
      }
    }
  }
  /**
   * @internal
   */
  _getEffectiveTarget(target, propertyPath) {
    const properties = propertyPath.split(".");
    for (let index = 0; index < properties.length - 1; index++) {
      target = target[properties[index]];
    }
    return target;
  }
  /**
   * @internal
   */
  _getProperty(propertyPath) {
    const properties = propertyPath.split(".");
    return properties[properties.length - 1];
  }
  /**
   * Serialize this manager to a JSON object
   * @param name defines the property name to store this manager
   * @returns a JSON representation of this manager
   */
  serialize(name) {
    const root = {
      children: new Array(),
      name,
      type: 3,
      // Root node
      properties: new Array()
      // Empty for root but required
    };
    for (let i = 0; i < this.actions.length; i++) {
      const triggerObject = {
        type: 0,
        // Trigger
        children: new Array(),
        name: _ActionManager.GetTriggerName(this.actions[i].trigger),
        properties: new Array()
      };
      const triggerOptions = this.actions[i].triggerOptions;
      if (triggerOptions && typeof triggerOptions !== "number") {
        if (triggerOptions.parameter instanceof Node) {
          triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));
        } else if (typeof triggerOptions.parameter === "object") {
          const parameter = {};
          DeepCopier.DeepCopy(triggerOptions.parameter, parameter, ["mesh"]);
          if (triggerOptions.parameter && triggerOptions.parameter.mesh) {
            parameter._meshId = triggerOptions.parameter.mesh.id;
          }
          triggerObject.properties.push({ name: "parameter", targetType: null, value: parameter });
        } else {
          triggerObject.properties.push({ name: "parameter", targetType: null, value: triggerOptions.parameter });
        }
      }
      this.actions[i].serialize(triggerObject);
      root.children.push(triggerObject);
    }
    return root;
  }
  /**
   * Creates a new ActionManager from a JSON data
   * @param parsedActions defines the JSON data to read from
   * @param object defines the hosting mesh
   * @param scene defines the hosting scene
   */
  static Parse(parsedActions, object, scene) {
    const actionManager = new _ActionManager(scene);
    if (object === null) {
      scene.actionManager = actionManager;
    } else {
      object.actionManager = actionManager;
    }
    const instantiate = (name, params) => {
      const internalClassType = GetClass("BABYLON." + name);
      return internalClassType && new internalClassType(...params);
    };
    const parseParameter = (name, value, target, propertyPath) => {
      if (propertyPath === null) {
        const floatValue = parseFloat(value);
        if (value === "true" || value === "false") {
          return value === "true";
        } else {
          return isNaN(floatValue) ? value : floatValue;
        }
      }
      const effectiveTarget = propertyPath.split(".");
      const values = value.split(",");
      for (let i = 0; i < effectiveTarget.length; i++) {
        target = target[effectiveTarget[i]];
      }
      if (typeof target === "boolean") {
        return values[0] === "true";
      }
      if (typeof target === "string") {
        return values[0];
      }
      const split = [];
      for (let i = 0; i < values.length; i++) {
        split.push(parseFloat(values[i]));
      }
      if (target instanceof Vector3) {
        return Vector3.FromArray(split);
      }
      if (target instanceof Vector4) {
        return Vector4.FromArray(split);
      }
      if (target instanceof Color3) {
        return Color3.FromArray(split);
      }
      if (target instanceof Color4) {
        return Color4.FromArray(split);
      }
      return parseFloat(values[0]);
    };
    const traverse = (parsedAction, trigger, condition, action, combineArray = null) => {
      if (parsedAction.detached) {
        return;
      }
      const parameters = [];
      let target = null;
      let propertyPath = null;
      const combine = parsedAction.combine && parsedAction.combine.length > 0;
      if (parsedAction.type === 2) {
        parameters.push(actionManager);
      } else {
        parameters.push(trigger);
      }
      if (combine) {
        const actions = [];
        for (let j = 0; j < parsedAction.combine.length; j++) {
          traverse(parsedAction.combine[j], _ActionManager.NothingTrigger, condition, action, actions);
        }
        parameters.push(actions);
      } else {
        for (let i = 0; i < parsedAction.properties.length; i++) {
          let value = parsedAction.properties[i].value;
          const name = parsedAction.properties[i].name;
          const targetType = parsedAction.properties[i].targetType;
          if (name === "target") {
            if (targetType === "SceneProperties") {
              value = target = scene;
            } else if (targetType === "MaterialProperties") {
              value = target = scene.getMaterialByName(value);
            } else {
              value = target = scene.getNodeByName(value);
            }
          } else if (name === "parent") {
            value = scene.getNodeByName(value);
          } else if (name === "sound") {
            if (scene.getSoundByName) {
              value = scene.getSoundByName(value);
            }
          } else if (name !== "propertyPath") {
            if (parsedAction.type === 2 && name === "operator") {
              value = ValueCondition[value];
            } else {
              value = parseParameter(name, value, target, name === "value" ? propertyPath : null);
            }
          } else {
            propertyPath = value;
          }
          parameters.push(value);
        }
      }
      if (combineArray === null) {
        parameters.push(condition);
      } else {
        parameters.push(null);
      }
      if (parsedAction.name === "InterpolateValueAction") {
        const param = parameters[parameters.length - 2];
        parameters[parameters.length - 1] = param;
        parameters[parameters.length - 2] = condition;
      }
      let newAction = instantiate(parsedAction.name, parameters);
      if (newAction instanceof Condition && condition !== null) {
        const nothing = new DoNothingAction(trigger, condition);
        if (action) {
          action.then(nothing);
        } else {
          actionManager.registerAction(nothing);
        }
        action = nothing;
      }
      if (combineArray === null) {
        if (newAction instanceof Condition) {
          condition = newAction;
          newAction = action;
        } else {
          condition = null;
          if (action) {
            action.then(newAction);
          } else {
            actionManager.registerAction(newAction);
          }
        }
      } else {
        combineArray.push(newAction);
      }
      for (let i = 0; i < parsedAction.children.length; i++) {
        traverse(parsedAction.children[i], trigger, condition, newAction, null);
      }
    };
    for (let i = 0; i < parsedActions.children.length; i++) {
      let triggerParams;
      const trigger = parsedActions.children[i];
      if (trigger.properties.length > 0) {
        const param = trigger.properties[0].value;
        const value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);
        if (value._meshId) {
          value.mesh = scene.getMeshById(value._meshId);
        }
        triggerParams = { trigger: _ActionManager[trigger.name], parameter: value };
      } else {
        triggerParams = _ActionManager[trigger.name];
      }
      for (let j = 0; j < trigger.children.length; j++) {
        if (!trigger.detached) {
          traverse(trigger.children[j], triggerParams, null, null);
        }
      }
    }
  }
  /**
   * Get a trigger name by index
   * @param trigger defines the trigger index
   * @returns a trigger name
   */
  static GetTriggerName(trigger) {
    switch (trigger) {
      case 0:
        return "NothingTrigger";
      case 1:
        return "OnPickTrigger";
      case 2:
        return "OnLeftPickTrigger";
      case 3:
        return "OnRightPickTrigger";
      case 4:
        return "OnCenterPickTrigger";
      case 5:
        return "OnPickDownTrigger";
      case 6:
        return "OnDoublePickTrigger";
      // start;
      case 7:
        return "OnPickUpTrigger";
      case 8:
        return "OnLongPressTrigger";
      case 9:
        return "OnPointerOverTrigger";
      case 10:
        return "OnPointerOutTrigger";
      case 11:
        return "OnEveryFrameTrigger";
      case 12:
        return "OnIntersectionEnterTrigger";
      case 13:
        return "OnIntersectionExitTrigger";
      case 14:
        return "OnKeyDownTrigger";
      case 15:
        return "OnKeyUpTrigger";
      case 16:
        return "OnPickOutTrigger";
      default:
        return "";
    }
  }
};
ActionManager.NothingTrigger = 0;
ActionManager.OnPickTrigger = 1;
ActionManager.OnLeftPickTrigger = 2;
ActionManager.OnRightPickTrigger = 3;
ActionManager.OnCenterPickTrigger = 4;
ActionManager.OnPickDownTrigger = 5;
ActionManager.OnDoublePickTrigger = 6;
ActionManager.OnPickUpTrigger = 7;
ActionManager.OnPickOutTrigger = 16;
ActionManager.OnLongPressTrigger = 8;
ActionManager.OnPointerOverTrigger = 9;
ActionManager.OnPointerOutTrigger = 10;
ActionManager.OnEveryFrameTrigger = 11;
ActionManager.OnIntersectionEnterTrigger = 12;
ActionManager.OnIntersectionExitTrigger = 13;
ActionManager.OnKeyDownTrigger = 14;
ActionManager.OnKeyUpTrigger = 15;

// node_modules/@babylonjs/core/Actions/directAudioActions.js
var PlaySoundAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param sound defines the sound to play
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, sound, condition) {
    super(triggerOptions, condition);
    this._sound = sound;
  }
  /** @internal */
  _prepare() {
  }
  /**
   * Execute the action and play the sound.
   */
  execute() {
    if (this._sound !== void 0) {
      this._sound.play();
    }
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "PlaySoundAction",
      properties: [{ name: "sound", value: this._sound.name }]
    }, parent);
  }
};
var StopSoundAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param sound defines the sound to stop
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, sound, condition) {
    super(triggerOptions, condition);
    this._sound = sound;
  }
  /** @internal */
  _prepare() {
  }
  /**
   * Execute the action and stop the sound.
   */
  execute() {
    if (this._sound !== void 0) {
      this._sound.stop();
    }
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "StopSoundAction",
      properties: [{ name: "sound", value: this._sound.name }]
    }, parent);
  }
};
RegisterClass("BABYLON.PlaySoundAction", PlaySoundAction);
RegisterClass("BABYLON.StopSoundAction", StopSoundAction);

// node_modules/@babylonjs/core/Actions/interpolateValueAction.js
var InterpolateValueAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the value to interpolate
   * @param propertyPath defines the path to the property in the target object
   * @param value defines the target value at the end of the interpolation
   * @param duration defines the time it will take for the property to interpolate to the value.
   * @param condition defines the trigger related conditions
   * @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered
   * @param onInterpolationDone defines a callback raised once the interpolation animation has been done
   */
  constructor(triggerOptions, target, propertyPath, value, duration = 1e3, condition, stopOtherAnimations, onInterpolationDone) {
    super(triggerOptions, condition);
    this.duration = 1e3;
    this.onInterpolationDoneObservable = new Observable();
    this.propertyPath = propertyPath;
    this.value = value;
    this.duration = duration;
    this.stopOtherAnimations = stopOtherAnimations;
    this.onInterpolationDone = onInterpolationDone;
    this._target = this._effectiveTarget = target;
  }
  /** @internal */
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  /**
   * Execute the action starts the value interpolation.
   */
  execute() {
    const scene = this._actionManager.getScene();
    const keys = [
      {
        frame: 0,
        value: this._effectiveTarget[this._property]
      },
      {
        frame: 100,
        value: this.value
      }
    ];
    let dataType;
    if (typeof this.value === "number") {
      dataType = Animation.ANIMATIONTYPE_FLOAT;
    } else if (this.value instanceof Color3) {
      dataType = Animation.ANIMATIONTYPE_COLOR3;
    } else if (this.value instanceof Vector3) {
      dataType = Animation.ANIMATIONTYPE_VECTOR3;
    } else if (this.value instanceof Matrix) {
      dataType = Animation.ANIMATIONTYPE_MATRIX;
    } else if (this.value instanceof Quaternion) {
      dataType = Animation.ANIMATIONTYPE_QUATERNION;
    } else {
      Logger.Warn("InterpolateValueAction: Unsupported type (" + typeof this.value + ")");
      return;
    }
    const animation = new Animation("InterpolateValueAction", this._property, 100 * (1e3 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);
    animation.setKeys(keys);
    if (this.stopOtherAnimations) {
      scene.stopAnimation(this._effectiveTarget);
    }
    const wrapper = () => {
      this.onInterpolationDoneObservable.notifyObservers(this);
      if (this.onInterpolationDone) {
        this.onInterpolationDone();
      }
    };
    scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "InterpolateValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) },
        { name: "duration", value: Action._SerializeValueAsString(this.duration) },
        { name: "stopOtherAnimations", value: Action._SerializeValueAsString(this.stopOtherAnimations) || false }
      ]
    }, parent);
  }
};
RegisterClass("BABYLON.InterpolateValueAction", InterpolateValueAction);

export {
  Action,
  Condition,
  ValueCondition,
  PredicateCondition,
  StateCondition,
  SwitchBooleanAction,
  SetStateAction,
  SetValueAction,
  IncrementValueAction,
  PlayAnimationAction,
  StopAnimationAction,
  DoNothingAction,
  CombineAction,
  ExecuteCodeAction,
  SetParentAction,
  ActionManager,
  PlaySoundAction,
  StopSoundAction,
  InterpolateValueAction
};
//# sourceMappingURL=chunk-KYD3MFOT.js.map
